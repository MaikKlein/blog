<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Blog</title>
    <link>https://maikklein.github.io/post/</link>
    <description>Recent content in Posts on Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sat, 05 Nov 2016 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://maikklein.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>My first steps with Future-rs</title>
      <link>https://maikklein.github.io/post/futures-rs/</link>
      <pubDate>Sat, 05 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>https://maikklein.github.io/post/futures-rs/</guid>
      <description>&lt;p&gt;A few months ago I have written a small task system, it looks like this.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;let res = TaskPool::submit(|| {
    println!(&amp;quot;Before long running task&amp;quot;);
    let r = TaskPool::submit(|| {
        std::thread::sleep(Duration::from_secs(10));
        return 42;
    });
    // Waits for the long running task to complete, does not block other tasks!
    println!(&amp;quot;After long running task {}&amp;quot;, r.await());
    42
});
println!(&amp;quot;{}&amp;quot;, res.await());
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;It is possible to spawn tasks inside tasks&lt;/li&gt;
&lt;li&gt;Calling &lt;code&gt;.await()&lt;/code&gt; on the main thread will block&lt;/li&gt;
&lt;li&gt;Calling &lt;code&gt;.await()&lt;/code&gt; inside the task pool will reschedule the task&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The task system was inspired by &lt;a href=&#34;http://www.gdcvault.com/play/1022186/Parallelizing-the-Naughty-Dog-Engine&#34;&gt;Naughty Dog&amp;rsquo;s Task system&lt;/a&gt; but since then &lt;code&gt;future-rs&lt;/code&gt; was released. Today I finally had time to test it out.&lt;/p&gt;

&lt;p&gt;Instead of spawning tasks inside tasks you create &lt;code&gt;futures&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;let some_future = futures::finished::&amp;lt;i32, ()&amp;gt;(42).map(|i| i + 42);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can think of them as a finite state machine.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;let pool = CpuPool::new(3);
let some_future = futures::finished::&amp;lt;i32, ()&amp;gt;(42).map(|i| i + 42);
let cpu_future = pool.spawn(some_future);
println!(&amp;quot;{}&amp;quot;, cpu_future.wait().unwrap());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The biggest difference here is that submitting and creating work is completely separated.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Futures&lt;/code&gt; can be composed together&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;fn future_test(id: i32) -&amp;gt; impl futures::Future&amp;lt;Item=i32, Error=()&amp;gt; {
    futures::finished::&amp;lt;i32, ()&amp;gt;(42)
        .map(move |i| {
            println!(&amp;quot;1st map id {}  {:?}&amp;quot;, id, thread_id::get());
            i + 1
        })
        .map(move |i| {
            println!(&amp;quot;2nd map id {}  {:?}&amp;quot;, id, thread_id::get());
            i + 2
        })
        .map(move |i| {
            println!(&amp;quot;3rd map id {}  {:?}&amp;quot;, id, thread_id::get());
            i + 3
        })
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Though you probably want to make use of &lt;code&gt;impl trait&lt;/code&gt; if you compose multiple futures together. Above I used the &lt;code&gt;thread-id&lt;/code&gt; crate to see on which thread the future will execute.&lt;/p&gt;

&lt;p&gt;I am currently writing a rendering engine in Vulkan and I need to record &lt;code&gt;CommandBuffers&lt;/code&gt; on different threads. This means I have to figure out how I actually submit futures onto different threads.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;let c: Vec&amp;lt;_&amp;gt; = (0 .. 10).map(|i| future_test(i)).collect();
let r = pool.spawn(futures::collect(c));
println!(&amp;quot;{:?}&amp;quot;, r.wait());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will print:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;1st map id 0  140444805625600
2nd map id 0  140444805625600
3rd map id 0  140444805625600
1st map id 1  140444805625600
2nd map id 1  140444805625600
3rd map id 1  140444805625600
1st map id 2  140444805625600
2nd map id 2  140444805625600
3rd map id 2  140444805625600
1st map id 3  140444805625600
2nd map id 3  140444805625600
3rd map id 3  140444805625600
1st map id 4  140444805625600
2nd map id 4  140444805625600
3rd map id 4  140444805625600
1st map id 5  140444805625600
2nd map id 5  140444805625600
3rd map id 5  140444805625600
1st map id 6  140444805625600
2nd map id 6  140444805625600
3rd map id 6  140444805625600
1st map id 7  140444805625600
2nd map id 7  140444805625600
3rd map id 7  140444805625600
1st map id 8  140444805625600
2nd map id 8  140444805625600
3rd map id 8  140444805625600
1st map id 9  140444805625600
2nd map id 9  140444805625600
3rd map id 9  140444805625600
Ok([48, 48, 48, 48, 48, 48, 48, 48, 48, 48])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You may notice that the thread id is always the same. This is because a &lt;code&gt;future&lt;/code&gt; will currently execute only on 1 thread. This is not what I wanted to achieve.&lt;/p&gt;

&lt;p&gt;If you want parallelism you should probably not submit one giant future but more smaller ones.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;let c: Vec&amp;lt;i32&amp;gt; =
    (0..10).map(|i| pool.spawn(future_test(i))).collect::&amp;lt;Vec&amp;lt;_&amp;gt;&amp;gt;().into_iter()
           .map(|f| f.wait().unwrap()).collect();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This code will print:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;1st map id 0  139959187011328
2nd map id 0  139959187011328
3rd map id 0  139959187011328
1st map id 1  139959184910080
2nd map id 1  139959184910080
3rd map id 1  139959184910080
1st map id 2  139959182808832
2nd map id 2  139959182808832
3rd map id 2  139959182808832
1st map id 3  139959187011328
2nd map id 3  139959187011328
3rd map id 3  139959187011328
1st map id 4  139959184910080
2nd map id 4  139959184910080
3rd map id 4  139959184910080
1st map id 5  139959182808832
2nd map id 5  139959182808832
3rd map id 5  139959182808832
1st map id 6  139959187011328
2nd map id 6  139959187011328
3rd map id 6  139959187011328
1st map id 7  139959184910080
2nd map id 7  139959184910080
3rd map id 7  139959184910080
1st map id 8  139959182808832
2nd map id 8  139959182808832
3rd map id 8  139959182808832
1st map id 9  139959187011328
2nd map id 9  139959187011328
3rd map id 9  139959187011328
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The code creates 10 &lt;code&gt;Futures&lt;/code&gt; from &lt;code&gt;future_test&lt;/code&gt; and immediately spawns them with &lt;code&gt;pool.spawn(future_test(i))&lt;/code&gt; which returns a &lt;code&gt;CpuFuture&lt;/code&gt;. It then waits sequentially on the result and writes its result into a vector.&lt;/p&gt;

&lt;p&gt;You might also notice that every &lt;code&gt;Future&lt;/code&gt; from &lt;code&gt;future_test&lt;/code&gt; will execute on the same thread.&lt;/p&gt;

&lt;p&gt;I haven&amp;rsquo;t spent too much time with &lt;code&gt;Future-rs&lt;/code&gt; but it looks very promising. The next thing I will look into is how I can safely share stack references inside &lt;code&gt;Futures&lt;/code&gt;. This was one part where I struggled with my &lt;code&gt;TaskPool&lt;/code&gt; implementation and I will probably run into the same issues with &lt;code&gt;Future-rs&lt;/code&gt; and &lt;code&gt;TaskPool&lt;/code&gt; because &lt;code&gt;spawn&lt;/code&gt; has &lt;code&gt;&#39;static&lt;/code&gt; lifetime requirements.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;fn spawn&amp;lt;F&amp;gt;(&amp;amp;self, f: F) -&amp;gt; CpuFuture&amp;lt;F::Item, F::Error&amp;gt;
where F: Future + Send + &#39;static, F::Item: Send + &#39;static, F::Error: Send + &#39;static
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/nikomatsakis/rayon&#34;&gt;Rayon&lt;/a&gt; does seem to offer this&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;/// Increment all values in slice.
fn increment_all(slice: &amp;amp;mut [i32]) {
    if slice.len() &amp;lt; 1000 {
        for p in slice { *p += 1; }
    } else {
        let mid_point = slice.len() / 2;
        let (left, right) = slice.split_at_mut(mid_point);
        rayon::join(|| increment_all(left), || increment_all(right));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Luckily &lt;code&gt;futures-cpupool&lt;/code&gt; is only a few 100 lines and therefore easy to make changes. I might have to remove the &lt;code&gt;Send&lt;/code&gt; requirement from &lt;code&gt;.spawn&lt;/code&gt; in order to have stack borrows. Mostly because it would be very bad if you create a future that has a borrow on the stack and you send it to a different thread. But it should be safe if it only gets send to the taskpool because you will get back another future which also doesn&amp;rsquo;t implement &lt;code&gt;Send&lt;/code&gt;. Then you could call &lt;code&gt;.wait()&lt;/code&gt; in the destructor but I see I
am already getting ahead of myself.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>My first steps with Future-rs</title>
      <link>https://maikklein.github.io/post/nom/</link>
      <pubDate>Sat, 05 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>https://maikklein.github.io/post/nom/</guid>
      <description>&lt;p&gt;A few months ago I have written a small task system, it looks like this.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;let res = TaskPool::submit(|| {
    println!(&amp;quot;Before long running task&amp;quot;);
    let r = TaskPool::submit(|| {
        std::thread::sleep(Duration::from_secs(10));
        return 42;
    });
    // Waits for the long running task to complete, does not block other tasks!
    println!(&amp;quot;After long running task {}&amp;quot;, r.await());
    42
});
println!(&amp;quot;{}&amp;quot;, res.await());
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;It is possible to spawn tasks inside tasks&lt;/li&gt;
&lt;li&gt;Calling &lt;code&gt;.await()&lt;/code&gt; on the main thread will block&lt;/li&gt;
&lt;li&gt;Calling &lt;code&gt;.await()&lt;/code&gt; inside the task pool will reschedule the task&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The task system was inspired by &lt;a href=&#34;http://www.gdcvault.com/play/1022186/Parallelizing-the-Naughty-Dog-Engine&#34;&gt;Naughty Dog&amp;rsquo;s Task system&lt;/a&gt; but since then &lt;code&gt;future-rs&lt;/code&gt; was released. Today I finally had time to test it out.&lt;/p&gt;

&lt;p&gt;Instead of spawning tasks inside tasks you create &lt;code&gt;futures&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;let some_future = futures::finished::&amp;lt;i32, ()&amp;gt;(42).map(|i| i + 42);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can think of them as a finite state machine.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;let pool = CpuPool::new(3);
let some_future = futures::finished::&amp;lt;i32, ()&amp;gt;(42).map(|i| i + 42);
let cpu_future = pool.spawn(some_future);
println!(&amp;quot;{}&amp;quot;, cpu_future.wait().unwrap());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The biggest difference here is that submitting and creating work is completely separated.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Futures&lt;/code&gt; can be composed together&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;fn future_test(id: i32) -&amp;gt; impl futures::Future&amp;lt;Item=i32, Error=()&amp;gt; {
    futures::finished::&amp;lt;i32, ()&amp;gt;(42)
        .map(move |i| {
            println!(&amp;quot;1st map id {}  {:?}&amp;quot;, id, thread_id::get());
            i + 1
        })
        .map(move |i| {
            println!(&amp;quot;2nd map id {}  {:?}&amp;quot;, id, thread_id::get());
            i + 2
        })
        .map(move |i| {
            println!(&amp;quot;3rd map id {}  {:?}&amp;quot;, id, thread_id::get());
            i + 3
        })
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Though you probably want to make use of &lt;code&gt;impl trait&lt;/code&gt; if you compose multiple futures together. Above I used the &lt;code&gt;thread-id&lt;/code&gt; crate to see on which thread the future will execute.&lt;/p&gt;

&lt;p&gt;I am currently writing a rendering engine in Vulkan and I need to record &lt;code&gt;CommandBuffers&lt;/code&gt; on different threads. This means I have to figure out how I actually submit futures onto different threads.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;let c: Vec&amp;lt;_&amp;gt; = (0 .. 10).map(|i| future_test(i)).collect();
let r = pool.spawn(futures::collect(c));
println!(&amp;quot;{:?}&amp;quot;, r.wait());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will print:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;1st map id 0  140444805625600
2nd map id 0  140444805625600
3rd map id 0  140444805625600
1st map id 1  140444805625600
2nd map id 1  140444805625600
3rd map id 1  140444805625600
1st map id 2  140444805625600
2nd map id 2  140444805625600
3rd map id 2  140444805625600
1st map id 3  140444805625600
2nd map id 3  140444805625600
3rd map id 3  140444805625600
1st map id 4  140444805625600
2nd map id 4  140444805625600
3rd map id 4  140444805625600
1st map id 5  140444805625600
2nd map id 5  140444805625600
3rd map id 5  140444805625600
1st map id 6  140444805625600
2nd map id 6  140444805625600
3rd map id 6  140444805625600
1st map id 7  140444805625600
2nd map id 7  140444805625600
3rd map id 7  140444805625600
1st map id 8  140444805625600
2nd map id 8  140444805625600
3rd map id 8  140444805625600
1st map id 9  140444805625600
2nd map id 9  140444805625600
3rd map id 9  140444805625600
Ok([48, 48, 48, 48, 48, 48, 48, 48, 48, 48])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You may notice that the thread id is always the same. This is because a &lt;code&gt;future&lt;/code&gt; will currently execute only on 1 thread. This is not what I wanted to achieve.&lt;/p&gt;

&lt;p&gt;If you want parallelism you should probably not submit one giant future but more smaller ones.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;let c: Vec&amp;lt;i32&amp;gt; =
    (0..10).map(|i| pool.spawn(future_test(i))).collect::&amp;lt;Vec&amp;lt;_&amp;gt;&amp;gt;().into_iter()
           .map(|f| f.wait().unwrap()).collect();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This code will print:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;1st map id 0  139959187011328
2nd map id 0  139959187011328
3rd map id 0  139959187011328
1st map id 1  139959184910080
2nd map id 1  139959184910080
3rd map id 1  139959184910080
1st map id 2  139959182808832
2nd map id 2  139959182808832
3rd map id 2  139959182808832
1st map id 3  139959187011328
2nd map id 3  139959187011328
3rd map id 3  139959187011328
1st map id 4  139959184910080
2nd map id 4  139959184910080
3rd map id 4  139959184910080
1st map id 5  139959182808832
2nd map id 5  139959182808832
3rd map id 5  139959182808832
1st map id 6  139959187011328
2nd map id 6  139959187011328
3rd map id 6  139959187011328
1st map id 7  139959184910080
2nd map id 7  139959184910080
3rd map id 7  139959184910080
1st map id 8  139959182808832
2nd map id 8  139959182808832
3rd map id 8  139959182808832
1st map id 9  139959187011328
2nd map id 9  139959187011328
3rd map id 9  139959187011328
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The code creates 10 &lt;code&gt;Futures&lt;/code&gt; from &lt;code&gt;future_test&lt;/code&gt; and immediately spawns them with &lt;code&gt;pool.spawn(future_test(i))&lt;/code&gt; which returns a &lt;code&gt;CpuFuture&lt;/code&gt;. It then waits sequentially on the result and writes its result into a vector.&lt;/p&gt;

&lt;p&gt;You might also notice that every &lt;code&gt;Future&lt;/code&gt; from &lt;code&gt;future_test&lt;/code&gt; will execute on the same thread.&lt;/p&gt;

&lt;p&gt;I haven&amp;rsquo;t spent too much time with &lt;code&gt;Future-rs&lt;/code&gt; but it looks very promising. The next thing I will look into is how I can safely share stack references inside &lt;code&gt;Futures&lt;/code&gt;. This was one part where I struggled with my &lt;code&gt;TaskPool&lt;/code&gt; implementation and I will probably run into the same issues with &lt;code&gt;Future-rs&lt;/code&gt; and &lt;code&gt;TaskPool&lt;/code&gt; because &lt;code&gt;spawn&lt;/code&gt; has &lt;code&gt;&#39;static&lt;/code&gt; lifetime requirements.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;fn spawn&amp;lt;F&amp;gt;(&amp;amp;self, f: F) -&amp;gt; CpuFuture&amp;lt;F::Item, F::Error&amp;gt;
where F: Future + Send + &#39;static, F::Item: Send + &#39;static, F::Error: Send + &#39;static
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/nikomatsakis/rayon&#34;&gt;Rayon&lt;/a&gt; does seem to offer this&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;/// Increment all values in slice.
fn increment_all(slice: &amp;amp;mut [i32]) {
    if slice.len() &amp;lt; 1000 {
        for p in slice { *p += 1; }
    } else {
        let mid_point = slice.len() / 2;
        let (left, right) = slice.split_at_mut(mid_point);
        rayon::join(|| increment_all(left), || increment_all(right));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Luckily &lt;code&gt;futures-cpupool&lt;/code&gt; is only a few 100 lines and therefore easy to make changes. I might have to remove the &lt;code&gt;Send&lt;/code&gt; requirement from &lt;code&gt;.spawn&lt;/code&gt; in order to have stack borrows. Mostly because it would be very bad if you create a future that has a borrow on the stack and you send it to a different thread. But it should be safe if it only gets send to the taskpool because you will get back another future which also doesn&amp;rsquo;t implement &lt;code&gt;Send&lt;/code&gt;. Then you could call &lt;code&gt;.wait()&lt;/code&gt; in the destructor but I see I
am already getting ahead of myself.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Comparison between Rust and D</title>
      <link>https://maikklein.github.io/post/cmp-rust-d/</link>
      <pubDate>Thu, 23 Jun 2016 00:00:00 +0000</pubDate>
      
      <guid>https://maikklein.github.io/post/cmp-rust-d/</guid>
      <description>

&lt;h1 id=&#34;comparison-between-rust-and-d:a33c6a773242a076961a1afafbd9aef7&#34;&gt;Comparison between Rust and D&lt;/h1&gt;

&lt;p&gt;I will try to compare &lt;code&gt;Rust&lt;/code&gt; and &lt;code&gt;D&lt;/code&gt; as objectively as possible. I will mostly focus the language parts that can actually be compared.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Rust currently is at version 1.9 and D is at version 2.071.0.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;move-and-copy-semantics:a33c6a773242a076961a1afafbd9aef7&#34;&gt;Move and copy semantics&lt;/h3&gt;

&lt;p&gt;Rust moves by default or copies if the &lt;code&gt;Copy&lt;/code&gt; trait is implemented.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;fn test(v: Vec&amp;lt;i32&amp;gt;){
}
fn main() {
    let v = vec![1, 2, 3];
    test(v); // v has moved into test
    // v can not be used
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Explicit &lt;code&gt;copies&lt;/code&gt; are done in Rust with the &lt;code&gt;Clone&lt;/code&gt; trait.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;fn test(v: Vec&amp;lt;i32&amp;gt;){
}
fn main() {
    let v = vec![1, 2, 3];
    test(v.clone()); // the cloned vec has moved into test
    // v can still be used here
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;D does a shallow copy by default&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-D&#34;&gt;import std.container: Array;

void test(Array!int arr){
    arr.insert(4);
}
void main()
{
    auto arr = Array!int(1, 2, 3);
    test(arr); // only does a shallow copy
    // Array contains now elements 1, 2, 3, 4
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Explicit copying has to be implemented manually. &lt;code&gt;Array&lt;/code&gt; exposes a &lt;code&gt;dup&lt;/code&gt; method that can be used to duplicate an array.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-D&#34;&gt;import std.container: Array;

void test(Array!int arr){
    arr.insert(4);
}
void main()
{
    auto arr = Array!int(1, 2, 3);
    test(arr.dup);
    //arr still has 3 elements
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Moves have to be done explicitly with &lt;code&gt;move&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-D&#34;&gt;import std.container: Array;
import std.algorithm.mutation: move;

void test(Array!int arr){
    arr.insert(4);
}
void main()
{
    auto arr = Array!int(1, 2, 3);
    test(arr.move);
    // arr can still be used but is empty
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Moved values in D can still be used because they are reset to their default state.&lt;/p&gt;

&lt;p&gt;It is also possible to reject lvalues for specific functions.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-D&#34;&gt;import std.container: Array;
import std.algorithm.mutation: move;

@disable void test(ref Array!int arr);
void test(Array!int arr){
    arr.insert(4);
}
void main()
{
    auto arr = Array!int(1, 2, 3);
    // test(arr); does not accept an lvalue
    test(arr.move); // still works
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;mutability:a33c6a773242a076961a1afafbd9aef7&#34;&gt;Mutability&lt;/h3&gt;

&lt;p&gt;Types in Rust are immutable by default.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;fn main() {
    let v = vec![1, 2, 3];
    //v.push(1); // does not work
    let mut v1 = vec![1, 2, 3];
    v1.push(1);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;D requires the &lt;code&gt;immutable&lt;/code&gt; keyword.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-D&#34;&gt;void main()
{
    immutable i = 42;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;D does not allow interior mutability as far as I know, which means it is not possible to create an immutable &lt;code&gt;Array&lt;/code&gt;. Interior mutability in Rust can be implemented with &lt;a href=&#34;https://doc.rust-lang.org/std/cell/&#34;&gt;Cell&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;D has another keyword &lt;code&gt;const&lt;/code&gt; to restrict exterior mutability.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void main()
{
   const arr = Array!int(1, 2, 3);
   //arr.insert(1); does not compile
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;From the &lt;a href=&#34;https://dlang.org/spec/const3.html#const_and_immutable&#34;&gt;D spec&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;immutable applies to data that cannot change. Immutable data values, once constructed, remain the same for the duration of the program&amp;rsquo;s execution. Immutable data can be placed in ROM (Read Only Memory) or in memory pages marked by the hardware as read only. Since immutable data does not change, it enables many opportunities for program optimization, and has applications in functional style programming.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!-- --&gt;

&lt;blockquote&gt;
&lt;p&gt;const applies to data that cannot be changed by the const reference to that data. It may, however, be changed by another reference to that same data. Const finds applications in passing data through interfaces that promise not to modify them.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!-- --&gt;

&lt;blockquote&gt;
&lt;p&gt;Both immutable and const are transitive, which means that any data reachable through an immutable reference is also immutable, and likewise for const.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;struct-initialization:a33c6a773242a076961a1afafbd9aef7&#34;&gt;Struct initialization&lt;/h3&gt;

&lt;p&gt;D as well as Rust can field initialize structs.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-D&#34;&gt;struct Foo{
     int i;
}

void main()
{
    Foo f = {i: 42};
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;struct Foo{
    i: i32
}
fn main() {
    let f = Foo{i: 42};
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;D also has constructors&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct Foo{
     int i;
     this(int _i){
         i = _i;
     }
}

void main()
{
    auto f = Foo(42);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;while Rust uses functions to do object construction.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct Foo{
    i: i32
}
impl Foo{
    fn new(i: i32) -&amp;gt; Foo{
        Foo{i: i}
    }
}
fn main() {
    let f = Foo::new(42);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;methods-and-ufcs:a33c6a773242a076961a1afafbd9aef7&#34;&gt;Methods and UFCS&lt;/h3&gt;

&lt;p&gt;Methods in D are implement inside the type.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct Foo{
     int i;
     this(int _i){
         i = _i;
     }

     void print(){
         import std.stdio: writeln;
         writeln(&amp;quot;Foo &amp;quot;, i);
     }
}

void main()
{
    auto f = Foo(42);
    f.print();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Rust implements methods outside of the type and inside a &lt;code&gt;impl&lt;/code&gt; block.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct Foo{
    i: i32
}
impl Foo{
    fn new(i: i32) -&amp;gt; Foo{
        Foo{i: i}
    }
    fn print(&amp;amp;self){
        println!(&amp;quot;Foo {}&amp;quot;, self.i);
    }
}
fn main() {
    let f = Foo::new(42);
    f.print();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Also Rust doesn&amp;rsquo;t implicitly capture &lt;code&gt;this / self&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Universal function call syntax allows to call print In Rust like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fn main() {
    let f = Foo::new(42);
    Foo::print(&amp;amp;f);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In D functions can be called like methods&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct Foo{
     int i;
     this(int _i){
         i = _i;
     }
}

void print(ref Foo f){
    import std.stdio: writeln;
    writeln(&amp;quot;Foo &amp;quot;, f.i);
}

void main()
{
    auto f = Foo(42);
    // both works
    f.print();
    print(f);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The advantage of &lt;code&gt;impl&lt;/code&gt; blocks is that they reduce verbosity for constrains.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;impl&amp;lt;T&amp;gt; Bar&amp;lt;T&amp;gt;
    where: T: Copy
{
    fn something(&amp;amp;self, val: T) -&amp;gt; T{...}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It is also possible to have multiple &lt;code&gt;impl&lt;/code&gt; for different constrains. As far as I know this is not possible in D, every function needs its own constrains.&lt;/p&gt;

&lt;p&gt;A small advantage of D is that it is possible to call those functions directly, like normal functions.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;auto zippedRange = zip(r1, r2);
auto zippedRange = r1.zip(r2);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;While in Rust this will be a bit more explicit.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let iter = Iterator::zip(iter1, iter2);
//or
let iter = iter1.zip(iter2);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;compile-times:a33c6a773242a076961a1afafbd9aef7&#34;&gt;Compile times&lt;/h3&gt;

&lt;p&gt;Subjectively Rust compiles slower than D, but it is really hard to get some objective data. I will post the results of compiling racer, rustfmt, DCD and dfmt. I am aware that those numbers are not really representable but it is the best that I can do.&lt;/p&gt;

&lt;p&gt;Also note that those a full release builds and not incremental debug builds.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;➜  bin time cargo install rustfmt
    Updating registry `https://github.com/rust-lang/crates.io-index`
   Compiling winapi v0.2.7
   Compiling rustc-serialize v0.3.19
   Compiling bitflags v0.5.0
   Compiling utf8-ranges v0.1.3
   Compiling log v0.3.6
   Compiling getopts v0.2.14
   Compiling unicode-segmentation v0.1.2
   Compiling strings v0.0.1
   Compiling regex-syntax v0.3.3
   Compiling winapi-build v0.1.1
   Compiling unicode-xid v0.0.3
   Compiling kernel32-sys v0.2.2
   Compiling diff v0.1.9
   Compiling term v0.4.4
   Compiling term v0.2.14
   Compiling libc v0.2.12
   Compiling memchr v0.1.11
   Compiling aho-corasick v0.5.2
   Compiling thread-id v2.0.0
   Compiling thread_local v0.2.6
   Compiling regex v0.1.71
   Compiling syntex_syntax v0.32.0
   Compiling toml v0.1.30
   Compiling env_logger v0.3.3
   Compiling rustfmt v0.5.0
  Installing /home/maik/.cargo/bin/rustfmt
  Installing /home/maik/.cargo/bin/cargo-fmt
cargo install rustfmt  382.58s user 1.49s system 130% cpu 4:54.72 total
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;➜  bin time cargo install racer
    Updating registry `https://github.com/rust-lang/crates.io-index`
   Compiling unicode-xid v0.0.3
   Compiling ansi_term v0.7.4
   Compiling libc v0.2.12
   Compiling unicode-width v0.1.3
   Compiling rustc-serialize v0.3.19
   Compiling regex-syntax v0.3.3
   Compiling winapi-build v0.1.1
   Compiling winapi v0.2.7
   Compiling kernel32-sys v0.2.2
   Compiling strsim v0.4.1
   Compiling term v0.2.14
   Compiling thread-id v2.0.0
   Compiling typed-arena v1.1.0
   Compiling utf8-ranges v0.1.3
   Compiling bitflags v0.5.0
   Compiling vec_map v0.6.0
   Compiling clap v2.2.6
   Compiling log v0.3.6
   Compiling memchr v0.1.11
   Compiling aho-corasick v0.5.2
   Compiling thread_local v0.2.6
   Compiling regex v0.1.71
   Compiling toml v0.1.30
   Compiling syntex_syntax v0.32.0
   Compiling env_logger v0.3.3
   Compiling racer v1.2.10
  Installing /home/maik/.cargo/bin/racer
cargo install racer  495.08s user 2.05s system 143% cpu 5:47.45 total
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;➜  DCD git:(master) time make -j4
find: ‘containers/experimental_allocator/src/std/experimental/allocator/’: No such file or directory
git log -1 --format=&amp;quot;%H&amp;quot; &amp;gt; githash.txt
mkdir -p bin
mkdir -p bin
dmd src/common/constants.d src/common/socket.d src/common/dcd_version.d src/common/messages.d src/server/autocomplete.d src/server/server.d dsymbol/src/dsymbol/import_.d dsymbol/src/dsymbol/symbol.d dsymbol/src/dsymbol/cache_entry.d dsymbol/src/dsymbol/string_interning.d dsymbol/src/dsymbol/semantic.d dsymbol/src/dsymbol/builtin/symbols.d dsymbol/src/dsymbol/builtin/names.d dsymbol/src/dsymbol/deferred.d dsymbol/src/dsymbol/modulecache.d dsymbol/src/dsymbol/scope_.d dsymbol/src/dsymbol/type_lookup.d dsymbol/src/dsymbol/conversion/first.d dsymbol/src/dsymbol/conversion/package.d dsymbol/src/dsymbol/conversion/second.d libdparse/src/dparse/ast.d libdparse/src/dparse/entities.d libdparse/src/dparse/lexer.d libdparse/src/dparse/parser.d libdparse/src/dparse/formatter.d libdparse/src/dparse/rollback_allocator.d libdparse/src/dparse/stack_buffer.d libdparse/src/std/experimental/lexer.d  containers/src/containers/dynamicarray.d containers/src/containers/ttree.d containers/src/containers/unrolledlist.d containers/src/containers/openhashset.d containers/src/containers/hashset.d containers/src/containers/internal/hash.d containers/src/containers/internal/node.d containers/src/containers/internal/storage_type.d containers/src/containers/internal/element_type.d containers/src/containers/internal/backwards.d containers/src/containers/slist.d msgpack-d/src/msgpack/exception.d msgpack-d/src/msgpack/attribute.d msgpack-d/src/msgpack/package.d msgpack-d/src/msgpack/register.d msgpack-d/src/msgpack/streaming_unpacker.d msgpack-d/src/msgpack/buffer.d msgpack-d/src/msgpack/common.d msgpack-d/src/msgpack/value.d msgpack-d/src/msgpack/unpacker.d msgpack-d/src/msgpack/packer.d -Icontainers/src -Imsgpack-d/src -Ilibdparse/src -Idsymbol/src -Icontainers/experimental_allocator/src -J. -wi -O -release -inline -ofbin/dcd-server
dmd src/common/constants.d src/common/socket.d src/common/dcd_version.d src/common/messages.d src/client/client.d msgpack-d/src/msgpack/exception.d msgpack-d/src/msgpack/attribute.d msgpack-d/src/msgpack/package.d msgpack-d/src/msgpack/register.d msgpack-d/src/msgpack/streaming_unpacker.d msgpack-d/src/msgpack/buffer.d msgpack-d/src/msgpack/common.d msgpack-d/src/msgpack/value.d msgpack-d/src/msgpack/unpacker.d msgpack-d/src/msgpack/packer.d -Imsgpack-d/src -Imsgpack-d/src -Icontainers/experimental_allocator/src -J. -inline -O -wi -ofbin/dcd-client
make -j4  42.62s user 2.44s system 104% cpu 43.173 total
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;➜  dfmt git:(master) ✗ time dub build -f -b release
Performing &amp;quot;release&amp;quot; build using dmd for x86_64.
experimental_allocator 2.70.0-b1: building configuration &amp;quot;library&amp;quot;...
libdparse 0.7.0-alpha9: building configuration &amp;quot;library&amp;quot;...
dfmt 0.5.0-beta3+commit.25.ge3bf269: building configuration &amp;quot;application&amp;quot;...
Linking...
dub build -f -b release  40.78s user 0.56s system 99% cpu 41.360 total
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;dynamic-static-dispatch-constrains-and-extending-functionality:a33c6a773242a076961a1afafbd9aef7&#34;&gt;Dynamic / static dispatch, constrains and extending functionality&lt;/h3&gt;

&lt;p&gt;In Rust it is possible to extend a type using traits.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct Foo {
    i: i32,
}

impl Foo {
    fn new(i: i32) -&amp;gt; Foo {
        Foo { i: i }
    }
}

trait Print {
    fn print(&amp;amp;self);
}

impl Print for Foo {
    fn print(&amp;amp;self) {
        println!(&amp;quot;Foo {}&amp;quot;, self.i);
    }
}

impl Print for i32 {
    fn print(&amp;amp;self) {
        println!(&amp;quot;i32 {}&amp;quot;, self);
    }
}

fn main() {
    let f = Foo::new(42);
    f.print();
    Print::print(&amp;amp;f);

    42.print();
    Print::print(&amp;amp;42);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The same thing is possible in D with overloaded functions.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct Foo{
     int i;
     this(int _i){
         i = _i;
     }
}

void print(ref Foo f){
    import std.stdio: writeln;
    writeln(&amp;quot;Foo &amp;quot;, f.i);
}

void print(int i){
    import std.stdio: writeln;
    writeln(&amp;quot;int &amp;quot;, i);
}

void main()
{
    auto f = Foo(42);
    f.print();
    print(f);

    42.print();
    print(42);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The advantage of traits is that you can use them to constrain types at compile and they allow dynamic dispatch&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fn call_print_static&amp;lt;T: Print&amp;gt;(t: &amp;amp;T){
    t.print();
}

fn call_print_dynamic(p: &amp;amp;Print){
    p.print();
}

fn main() {
    let f = Foo::new(42);
    call_print_static(&amp;amp;f);
    call_print_static(&amp;amp;42);

    call_print_dynamic(&amp;amp;f as &amp;amp;Print);
    call_print_dynamic(&amp;amp;42 as &amp;amp;Print);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This can roughly be expressed in D like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;interface Print{
    void print();
}

class Foo: Print{
     int i;
     this(int _i){
         i = _i;
     }
     void print(){
         import std.stdio: writeln;
         writeln(&amp;quot;Foo &amp;quot;, i);
     }
}

void call_print_dynamic(Print p){
    p.print();
}

void call_print_static(T)(T t){
    t.print();
}

void main()
{
    //f is a pointer
    auto f = new Foo(42);
    call_print_dynamic(f);
    call_print_static(f);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Dynamic dispatch with interfaces can only really be used with classes. Classes are by default references types which means if there is a type &lt;code&gt;Foo&lt;/code&gt; it implicitly is type &lt;code&gt;Foo*&lt;/code&gt;. While it is possible allocate classes on the heap / stack or some memory region, they inherently have an indirection.&lt;/p&gt;

&lt;p&gt;Also &lt;code&gt;call_print_static&lt;/code&gt; is duck typed, which means that the function expects every &lt;code&gt;T&lt;/code&gt; to be callable with &lt;code&gt;.print&lt;/code&gt;. This can easily result in ugly error messages.&lt;/p&gt;

&lt;p&gt;D doesn&amp;rsquo;t really have a way to automatically constrain types like Rust.&lt;/p&gt;

&lt;p&gt;Duck typing still has a few advantages. It is easy get something working, because you don&amp;rsquo;t have to specify every constrain in advance. It is also possible to generate some very specific error messages.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void call_print_static(T)(T t){
    static assert(!is(T == class), T.stringof ~ &amp;quot; is a class and can not be used.&amp;quot;);
    t.print();
}

void main()
{
    //f is a pointer
    auto f = new Foo(42);
    call_print_dynamic(f);
    call_print_static(f); // error
}
/*
source/app.d(21,5): Error: static assert  &amp;quot;Foo is a class and can not be used.&amp;quot;
source/app.d(30,22):        instantiated from here: call_print_static!(Foo)
*/
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;type-inference:a33c6a773242a076961a1afafbd9aef7&#34;&gt;Type inference&lt;/h3&gt;

&lt;p&gt;In Rust it is possible to write:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;fn test() -&amp;gt; Result&amp;lt;i32, String&amp;gt; {
    Ok(42)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This works because Rust knows that the return type is &lt;code&gt;Result&amp;lt;i32, String&amp;gt;&lt;/code&gt; and that &lt;code&gt;Ok&amp;lt;i32&amp;gt;&lt;/code&gt; is part of it. You can not write this in D as far as I know.&lt;/p&gt;

&lt;p&gt;The D approach could look like this&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-D&#34;&gt;alias SomeResult = Result!(int, string);
SomeResult test(){
    return SomeResult.ok(42);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;explicit-implicit-conversion-coercions:a33c6a773242a076961a1afafbd9aef7&#34;&gt;Explicit implicit conversion/coercions&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;use std::ops::Deref;

struct Wrapper&amp;lt;T&amp;gt; {
    value: T,
}

impl&amp;lt;T&amp;gt; Wrapper&amp;lt;T&amp;gt;{
    fn new(val: T) -&amp;gt; Wrapper&amp;lt;T&amp;gt; {
        Wrapper{value: val}
    }
}

impl&amp;lt;T&amp;gt; Deref for Wrapper&amp;lt;T&amp;gt; {
    type Target = T;
    fn deref(&amp;amp;self) -&amp;gt; &amp;amp;T{
        &amp;amp;self.value
    }
}

struct Foo {
    i: i32,
}

impl Foo {
    fn new(i: i32) -&amp;gt; Foo {
        Foo { i: i }
    }
}

trait Print {
    fn print(&amp;amp;self);
}

impl Print for Foo {
    fn print(&amp;amp;self) {
        println!(&amp;quot;Foo {}&amp;quot;, self.i);
    }
}

fn main() {
    let f = Wrapper::new(Foo::new(42));
    f.print();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Here’s the rule: If you have a type U, and it implements Deref&lt;Target=T&gt;, values of &amp;amp;U will automatically coerce to a &amp;amp;T &lt;a href=&#34;https://doc.rust-lang.org/book/deref-coercions.html&#34;&gt;quote&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This is also the reason that you can pass a &lt;code&gt;String&lt;/code&gt; into a function that expects a &lt;code&gt;&amp;amp;str&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-D&#34;&gt;struct Wrapper(T){
    T value;
    this(T _value){
        value = _value;
    }
    alias value this;
}

interface Print{
    void print();
}

class Foo: Print{
     int i;
     this(int _i){
         i = _i;
     }
     void print(){
         import std.stdio: writeln;
         writeln(&amp;quot;Foo &amp;quot;, i);
     }
}

void main()
{
    //f is a pointer
    auto f = Wrapper!Foo(new Foo(42));
    f.print();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In D calling &lt;code&gt;f.print()&lt;/code&gt; is then the same thing as &lt;code&gt;f.value.print()&lt;/code&gt;. This means &lt;code&gt;Wrapper&amp;lt;T&amp;gt;&lt;/code&gt; can be passed to anything that expects a &lt;code&gt;T&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://dlang.org/phobos/std_typecons.html#.Proxy&#34;&gt;Proxy&lt;/a&gt; can be used to forbid the conversions and only forward the methods to the new type.&lt;/p&gt;

&lt;h3 id=&#34;unused-generics:a33c6a773242a076961a1afafbd9aef7&#34;&gt;Unused generics&lt;/h3&gt;

&lt;p&gt;In D it is perfectly legal to create types with unused generics:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-D&#34;&gt;struct Foo(A, B){}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Rust doesn&amp;rsquo;t allow this by default and requires phantom data.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;use std::marker::PhantomData;
struct Foo&amp;lt;A, B&amp;gt;{
    _m_a: PhantomData&amp;lt;A&amp;gt;,
    _m_b: PhantomData&amp;lt;B&amp;gt;,
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;variadics:a33c6a773242a076961a1afafbd9aef7&#34;&gt;Variadics&lt;/h3&gt;

&lt;p&gt;Rust doesn&amp;rsquo;t have type level variadics and has to resort to macros. A commonly used variadic macro is &lt;code&gt;vec![...]&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-D&#34;&gt;// duck typing
void variadicPrint(Args...)(Args args){
    // compile time loop
    foreach(ref arg; args){
        arg.print();
    }
}

void main()
{
    auto wrapperF = Wrapper!Foo(new Foo(42));
    auto f = new Foo(42);
    variadicPrint(f);
    //or
    variadicPrint(f, f, wrapperF, f);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Because &lt;code&gt;variadicPrint&lt;/code&gt; is duck typed, anything that has a &lt;code&gt;print&lt;/code&gt; method, can be passed into it. Variadics also allow &lt;code&gt;Tuple&lt;/code&gt; to be implemented as a library in D.&lt;/p&gt;

&lt;h3 id=&#34;pattern-matching:a33c6a773242a076961a1afafbd9aef7&#34;&gt;Pattern matching&lt;/h3&gt;

&lt;p&gt;Rust natively supports algebraic data types which can be matched on.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;fn main() {
    let o = Some(5);
    match o {
        Some(i) =&amp;gt; println!(&amp;quot;{}&amp;quot;, i),
        None =&amp;gt; println!(&amp;quot;None&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;While D has algebaric data types (adt) as a library inside phobos, they have a significant overhead and can not be used at compile time. Luckily adt&amp;rsquo;s can be implemented in around 30 lines of code.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-D&#34;&gt;alias Test = Algebraic!(uint, float);
uint i = 5;
float f = 5.0f;
auto b = Test(f);
b.match!(
    (uint i) =&amp;gt; writeln(&amp;quot;uint, &amp;quot;, i),
    (float f) =&amp;gt; writeln(&amp;quot;float &amp;quot;, f),
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Rust allows type deconstruction&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;fn main() {
    let t = (1, &amp;quot;Test&amp;quot;);
    let (a, b) = t;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;While something similar can be implemented in D, it will not be as usable.&lt;/p&gt;

&lt;h3 id=&#34;type-level-values:a33c6a773242a076961a1afafbd9aef7&#34;&gt;Type level values&lt;/h3&gt;

&lt;p&gt;Rust doesn&amp;rsquo;t really have &lt;code&gt;type level values&lt;/code&gt;, the closest thing would probably be &lt;code&gt;typenum&lt;/code&gt;. See my &lt;a href=&#34;https://maikklein.github.io/post/impression-rust/&#34;&gt;blog post&lt;/a&gt; about using &lt;code&gt;typenum&lt;/code&gt; for a vector / matrix library.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Type level values&lt;/code&gt; are most commonly used as &lt;code&gt;type level integers&lt;/code&gt;. They allow the user to express a vector math library like this&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-D&#34;&gt;alias Vec3f = Vector&amp;lt;float, 3&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;D isn&amp;rsquo;t limited to integrals, you can basically pass any type into a template at compile time.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-D&#34;&gt;struct Worker{
    string name;
    uint id;
}

string level(Worker worker)(){
    static if(worker.id &amp;lt; 10){
        return &amp;quot;Grunt&amp;quot;;
    }
    else{
        return &amp;quot;Boss&amp;quot;;
    }
}
void main()
{
    // done at compile time
    enum string grunt = level!(Worker(&amp;quot;Tom&amp;quot;, 5));
    enum string boss = level!(Worker(&amp;quot;Jeff&amp;quot;, 20));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;metaprogramming:a33c6a773242a076961a1afafbd9aef7&#34;&gt;Metaprogramming&lt;/h3&gt;

&lt;p&gt;Rust has 3 features that allows metaprogramming, macros, traits and compiler plugins.&lt;/p&gt;

&lt;p&gt;The main purpose of macros is to reduce duplicated code, but they also allow custom syntax like this&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;for e in recurrence!(f[i]: f64 = 1.0 ... f[i-1] * i as f64).take(10) {
    println!(&amp;quot;{}&amp;quot;, e)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://danielkeep.github.io/tlborm/book/pim-README.html&#34;&gt;link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Traits allow implementations to be implemented for a specific range of types, allow types to be constrained and allow for dynamic dispatch.&lt;/p&gt;

&lt;p&gt;Compiler plugins are unstable can operate on the AST and can potentially execute arbitrary code at compile time. An example would be
&lt;a href=&#34;https://github.com/nrc/libhoare&#34;&gt;libhoare&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;#[precond=&amp;quot;x &amp;gt; 0&amp;quot;]
#[postcond=&amp;quot;result &amp;gt; 1&amp;quot;]
fn foo(x: int) -&amp;gt; int {
    let y = 45 / x;
    y + 1
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;While D natively has design by contract, I don&amp;rsquo;t believe this could be implemented as nicely in D. The closest thing I could imagine would be by using &lt;code&gt;UDA&lt;/code&gt; and or mixins. But as far as I know it is not possible to directly manipulate the AST in D.&lt;/p&gt;

&lt;p&gt;D has a full arsenal of metaprogramming tools. Type level values, variadics, type level computations, static if, mixins, templates, CTFE, static reflection. The blog post would become too long to showcase every feature but I already made a few blog posts that use some of those features. &lt;a href=&#34;https://maikklein.github.io/post/soa-d/&#34;&gt;SoA&lt;/a&gt;, &lt;a href=&#34;http://maikklein.github.io/2016/03/01/metaprogramming-typeobject/&#34;&gt;TypeObject ala Boost hana&lt;/a&gt;, &lt;a href=&#34;https://maikklein.github.io/post/2015-11-14-Converting-strings-to-types/&#34;&gt;Strings to types&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;CTFE in D is more limited than compiler plugins. It does not allow to execute arbitrary code like connecting to a database at compile time, as it would be a security risk.&lt;/p&gt;

&lt;h3 id=&#34;standard-library-manual-memory-management-and-ownership-semantics:a33c6a773242a076961a1afafbd9aef7&#34;&gt;Standard library, manual memory management and ownership semantics&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;Before we start let me tell you that it is technically possible to completely avoid the garbage collection in D, but there are currently a few problems.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://doc.rust-lang.org/std/&#34;&gt;Rust std&lt;/a&gt; and &lt;a href=&#34;https://dlang.org/phobos/index.html&#34;&gt;D phobos&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;In my opinion a good standard library is very import for a language. The biggest reason for that is every library will use the standard library to some degree.&lt;/p&gt;

&lt;p&gt;In Rust most libraries are already using &lt;code&gt;Box&lt;/code&gt;, &lt;code&gt;Rc&lt;/code&gt;, &lt;code&gt;Arc&lt;/code&gt;, &lt;code&gt;Result&lt;/code&gt;, &lt;code&gt;Option&lt;/code&gt;. In D there currently is &lt;code&gt;Unique&lt;/code&gt; and &lt;code&gt;RefCounted&lt;/code&gt; which still use the GC. &lt;code&gt;Nullable&lt;/code&gt; is similar to &lt;code&gt;Optional&lt;/code&gt; but it implements auto deref with &lt;code&gt;alias this&lt;/code&gt; and could therefore cause subtle problems.&lt;/p&gt;

&lt;p&gt;Ownership can be modelled in D by disabling the copy constructor. A type without a copy constructor must be moved which is similar to Rust. Currently types without a copy constructor can not reasonably be used with the standard library in D as you would have to explicitly call &lt;code&gt;move&lt;/code&gt; on them.&lt;/p&gt;

&lt;p&gt;This means that you would have to recreate everything in the std that copies in their implementation, which is a lot. Then there are other smaller problems, like how do you move variadic arguments?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-D&#34;&gt;void foo(Args)(Args args){
    bar(args); // how do you pass variadics?
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The way I currently implement this is by looking at the type, if it has no copy constructor I call move, otherwise I copy. I generate a compile time string that looks like this &lt;code&gt;&amp;quot;arg[0], arg[1].move, arg[2].move, arg[3]&amp;quot;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Basically what I am trying to say is that ownership semantics are not as refined as in Rust at the moment and avoiding the GC with smart pointers will be a lot of work.&lt;/p&gt;

&lt;p&gt;To avoid the Gc in D one can use the &lt;a href=&#34;https://dlang.org/phobos/std_experimental_allocator.html&#34;&gt;allocator&lt;/a&gt; library that ships with D. It handles all the low level stuff and exposes generic and composable allocators.&lt;/p&gt;

&lt;p&gt;Rust currently does not have any allocators but it seems to come into &lt;code&gt;nighly&lt;/code&gt; soon.&lt;/p&gt;

&lt;h3 id=&#34;conclusion:a33c6a773242a076961a1afafbd9aef7&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;I am fairly certain that I forgot to cover a few topics but this should give you a rough overview.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>First impression of Rust after two years - Part 2</title>
      <link>https://maikklein.github.io/post/impression-rust-part2/</link>
      <pubDate>Wed, 22 Jun 2016 00:00:00 +0000</pubDate>
      
      <guid>https://maikklein.github.io/post/impression-rust-part2/</guid>
      <description>

&lt;h1 id=&#34;first-impression-of-rust-after-two-years-part-2:92979aa9f46afb7901e866a3ae600237&#34;&gt;First impression of Rust after two years - Part 2&lt;/h1&gt;

&lt;p&gt;As promised this is part 2 of &lt;a href=&#34;https://maikklein.github.io/post/impression-rust/&#34;&gt;part 1&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I created a small task based library in Rust based on naughty dogs gdc talk. The main purpose was to get a feeling of Rust and not the create a full blown library.&lt;/p&gt;

&lt;p&gt;Here is how you would use it.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;fn main() {
    let res = TaskPool::submit(|| {
        println!(&amp;quot;Before long running task&amp;quot;);
        let r = TaskPool::submit(|| {
            std::thread::sleep(Duration::from_secs(10));
            return 42;
        });
        // Waits for the long running task to complete, does not block other tasks!
        println!(&amp;quot;After long running task {}&amp;quot;, r.await());
        42
    });
    for i in 0..20 {
        TaskPool::submit(move || println!(&amp;quot;Another Task {}&amp;quot;, i));
    }
    println!(&amp;quot;{}&amp;quot;, res.await());
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The output can look like this&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;TASK 0
TASK 1
Before long task
TASK 2
TASK 3
TASK 4
TASK 9
TASK 5
TASK 10
TASK 19
TASK 6
TASK 11
TASK 17
TASK 18
TASK 7
TASK 8
TASK 12
TASK 13
TASK 14
TASK 15
TASK 16
After long task 42
42
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The main feature is that tasks will never block other tasks. In a task system it would be very bad for a task to wait for other tasks to complete because you basically lose the benefit of a whole core/thread. Instead I am using a fiber / coroutine to yield the context.&lt;/p&gt;

&lt;p&gt;I am currently using a fork of &lt;a href=&#34;https://github.com/rustcc/coroutine-rs&#34;&gt;coroutine-rs&lt;/a&gt;. Also as you can see, the API is currently relying on a global but immutable TaskPool. The reason for this what that I had to explicitly wrap &lt;code&gt;TaskPool&lt;/code&gt; inside an &lt;code&gt;Arc&lt;/code&gt; and clone it every time I wanted to create a task in another task.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;fn main() {
    let taskpool = Arc::new(TaskPool::new(3));
    let taskpool1 = taskpool.clone();
    let res = taskpool.submit(|| {
        taskpool1.submit(|| println!(&amp;quot;...&amp;quot;));
        42
    });
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I am just not the biggest fan of global variables. Currently a TaskPool is immutable and I just randomly distribute tasks to &lt;code&gt;ThreadLocalQueue&lt;/code&gt;. This is not really a good scheduler but it works. A better approach would probably to do all scheduling on the main thread.&lt;/p&gt;

&lt;p&gt;Also if a tasks gets assigned to a &lt;code&gt;ThreadLocalQueue&lt;/code&gt; it will stay in this queue until it is done. Once a task is assigned to a &lt;code&gt;ThreadLocalQueue&lt;/code&gt; it will create a coroutine. The reason for this is performance because I don&amp;rsquo;t want to worry about sharing fibers across threads and synchronizing them.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Corountine-rs&lt;/code&gt; currently does not support of getting the currently active coroutine. I have implemented it using a thread local variable.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;thread_local!(static FIBER: Cell&amp;lt;*mut coroutine::asymmetric::Handle&amp;gt; = Cell::new(std::ptr::null_mut()));
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;for t in self.work.iter_mut() {
    FIBER.with(|f| {
        f.set(t);
    });
    t.next();
    FIBER.with(|f| {
        f.set(std::ptr::null_mut());
    });
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The gist of it is that before I execute a coroutine, I put a pointer to it on the &lt;code&gt;tls&lt;/code&gt;, execute it and null the ptr again. I have no idea if doing that is even legal.&lt;/p&gt;

&lt;p&gt;I am doing it this way because I then always know if I am currently inside a task or not, without needing to explicitly pass the coroutine.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;struct Future&amp;lt;T&amp;gt; {
    receiver: Receiver&amp;lt;T&amp;gt;,
}
impl&amp;lt;T&amp;gt; Future&amp;lt;T&amp;gt; {
    fn new(receiver: Receiver&amp;lt;T&amp;gt;) -&amp;gt; Self {
        Future { receiver: receiver }
    }

    fn await(&amp;amp;self) -&amp;gt; T {
        let mut fiber = FIBER.with(|f| {
            return f.get();
        });
        let is_fiber = fiber != std::ptr::null_mut();
        if is_fiber {
            loop {
                let r = self.receiver.try_recv();
                if r.is_ok() {
                    return r.unwrap();
                }
                unsafe {
                    (*fiber).resume(0);
                }
            }
        } else {
            return self.receiver.recv().unwrap();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Obviously the whole library is implemented in a super hacky way but this allows me to block on the main thread and reschedule inside a task. Rescheduling works by testing if &lt;code&gt;try_recv&lt;/code&gt; actually returns something, if it doesn&amp;rsquo;t, I yield the context.&lt;/p&gt;

&lt;p&gt;Now I want to talk about the standard library. I am coming from D where I had to recreate almost anything myself that Rust ships by default because I wanted to avoid the GC. That meant recreating Box, Rc, Arc, Vec, Optional, Result etc and basically every container, because none of the container in the phobos (std) is move aware.&lt;/p&gt;

&lt;p&gt;My main goal is to create a game engine from scratch, while I enjoy working really low level, recreating a big part of the standard library was not as much fun as I thought.&lt;/p&gt;

&lt;p&gt;Coming from D it felt really good to have a standard library that works without a GC. The biggest problem of creating a lot of stuff from scratch is that I am the only user. If I encounter some problem, I can&amp;rsquo;t really post my code anywhere if it contains my custom smart-ptr or Optional/Result. Also using other libraries is probably a no go because they will most likely use the standard library which doesn&amp;rsquo;t work with my move aware types.&lt;/p&gt;

&lt;p&gt;So while it is completely possible to implement all those constructs in D, it felt a bit awkward to create everything manually. This makes me appreciate Rust&amp;rsquo;s standard library much more.&lt;/p&gt;

&lt;p&gt;Implementing the task library was relatively painless, the only thing that was missing were coroutines / fibers in the std, which were available as a 3rd party library.&lt;/p&gt;

&lt;h2 id=&#34;conclusions:92979aa9f46afb7901e866a3ae600237&#34;&gt;Conclusions:&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;Note: I base my conclusions on Rust 1.9 stable and I do not include features that may or may not come in the future. I know this may offend some people but it is too hard to judge Rust from the perspective of an outsider. I just don&amp;rsquo;t have enough information when which features might become available in stable Rust as there doesn&amp;rsquo;t seem to be publicly available roadmap.&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&#34;what-i-like:92979aa9f46afb7901e866a3ae600237&#34;&gt;What I like:&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Traits with dynamic / static dispatch&lt;/li&gt;
&lt;li&gt;Useful and well documented standard library&lt;/li&gt;
&lt;li&gt;Good standard documentation engine&lt;/li&gt;
&lt;li&gt;A sort of standardized style guide. I really like that all libraries have an almost identical syntactical style.&lt;/li&gt;
&lt;li&gt;Move semantics are really well done&lt;/li&gt;
&lt;li&gt;Default immutability and the concept of interior mutability&lt;/li&gt;
&lt;li&gt;No constructors&lt;/li&gt;
&lt;li&gt;Memory safety and no race conditions in safe Rust&lt;/li&gt;
&lt;li&gt;One standard open source compiler based on LLVM&lt;/li&gt;
&lt;li&gt;Useful error messages most of the time&lt;/li&gt;
&lt;li&gt;Solid base for a good ecosystem with cargo&lt;/li&gt;
&lt;li&gt;Implementation lives outside a type&lt;/li&gt;
&lt;li&gt;Good type inference&lt;/li&gt;
&lt;li&gt;Explicit error handling like in Haskell&lt;/li&gt;
&lt;li&gt;Pattern matching, deconstructing patterns like &lt;code&gt;let (a, b) = ...;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;what-i-dislike:92979aa9f46afb7901e866a3ae600237&#34;&gt;What I dislike:&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;No variadics&lt;/li&gt;
&lt;li&gt;No type level integers&lt;/li&gt;
&lt;li&gt;Metaprogramming in general is lacking, also unsure where Rust is heading in regards to metaprogramming.&lt;/li&gt;
&lt;li&gt;Compiler sometimes can not reason about lifetimes / mutability, which requires workarounds.&lt;/li&gt;
&lt;li&gt;Compile times seem relatively long compared to D&lt;/li&gt;
&lt;li&gt;No custom allocators&lt;/li&gt;
&lt;li&gt;No constexpr or compile time evaluation&lt;/li&gt;
&lt;li&gt;No public roadmap&lt;/li&gt;
&lt;li&gt;Immature tools like &lt;code&gt;racer&lt;/code&gt; (I don&amp;rsquo;t mean to offend anyone here, I appreciate the effort that is put into those tools)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;My overall impression is that I think Rust has a very good core language but it still misses some advanced features.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>First impression of Rust after two years - Part 1</title>
      <link>https://maikklein.github.io/post/impression-rust/</link>
      <pubDate>Tue, 21 Jun 2016 00:00:00 +0000</pubDate>
      
      <guid>https://maikklein.github.io/post/impression-rust/</guid>
      <description>

&lt;h1 id=&#34;first-impression-of-rust-after-two-years-part-1:a774b914f3de6089319ac433a724d086&#34;&gt;First impression of Rust after two years - Part 1&lt;/h1&gt;

&lt;p&gt;The last time I was using Rust was in version 0.6 - 0.7, which was roughly 2 years ago. I decided to come back to take another look.&lt;/p&gt;

&lt;p&gt;I decided to write two small libraries over the weekend. An n-dimensional, generic and typesafe linear algebra library and a task pool implementation with fibers based on naughty dogs &lt;a href=&#34;http://www.gdcvault.com/play/1022186/Parallelizing-the-Naughty-Dog-Engine&#34;&gt;GDC talk&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;But I came from D where I could easily create a nice vector library with templates.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-D&#34;&gt;alias Vec3f = Vector&amp;lt;float, 3&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I kinda wanted to do the same thing, but the problem is that Rust doesn&amp;rsquo;t have type level integers. This is probably why cgmath and nalgebra create their types manually and implement functionality with macros. Luckily I found &lt;a href=&#34;https://github.com/paholg/typenum&#34;&gt;typenum&lt;/a&gt;, which is sort of hack to emulate type level integers.&lt;/p&gt;

&lt;p&gt;Before I go on, I want to demonstrate some ergonomics of my experimental vector library. The vector types are defined like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;pub type Vec4&amp;lt;T&amp;gt; = Vector&amp;lt;T, U4&amp;gt;;
pub type Vec3&amp;lt;T&amp;gt; = Vector&amp;lt;T, U3&amp;gt;;
pub type Vec2&amp;lt;T&amp;gt; = Vector&amp;lt;T, U2&amp;gt;;

pub type Vec4f = Vec4&amp;lt;f32&amp;gt;;
pub type Vec3f = Vec3&amp;lt;f32&amp;gt;;
pub type Vec2f = Vec2&amp;lt;f32&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Vectors can be created like this&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;let v1 = Vec2f::new(&amp;amp;[0.0, 2.0]);
let v2 = Vec2f::new(&amp;amp;[0.0, 10.0]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can also create a vector with a lower dimensional vector + additional value like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;let v = Vec3f::from_one_less(Vec2f::new(&amp;amp;[1.0, 2.0]), 3.0);
assert!(v == Vec3f::new(&amp;amp;[1.0, 2.0, 3.0]));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It is not as ergonomic as my vector library in D where you can arbitrarily initialize a new vector but it is a start. You may wonder how I implemented it. The type signature looks like this&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;// I left out the type constrains for readability
pub fn from_one_less&amp;lt;&amp;gt;(first: Vector&amp;lt;T, Sub1&amp;lt;N&amp;gt;&amp;gt;, val: T) -&amp;gt; Vector&amp;lt;T, N&amp;gt;{...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It breaks down for a &lt;code&gt;Vec2&lt;/code&gt; because then it would want a &lt;code&gt;Vec1&lt;/code&gt; + a value, which would be a verbose way of writing just two values.&lt;/p&gt;

&lt;p&gt;I don&amp;rsquo;t think that I can restrict implementations for specific &lt;code&gt;typenum&lt;/code&gt; traits. Also it would have also been nice to have one generic function that can accept arbitrary vectors, but that would require at least type level integers + variadic function, which Rust doesn&amp;rsquo;t have.&lt;/p&gt;

&lt;p&gt;Because I used &lt;code&gt;typenum&lt;/code&gt; to express n-dimensional vectors, it made it very easy to implement functions like dot&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;pub fn dot(self, other: Self) -&amp;gt; T {
    self.data
        .into_iter()
        .zip(other.data.into_iter())
        .fold(T::zero(), |acc, (x, y)| acc + x * y)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I really like that Rust has pattern matching on tuples, I think this really adds to readability.&lt;/p&gt;

&lt;p&gt;Now is probably a good time to show the initial definition of a &lt;code&gt;Vector&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;#[derive(PartialEq, Eq, Copy, Debug)]
pub struct Vector&amp;lt;T: Float, N: ArrayLength&amp;lt;T&amp;gt;&amp;gt;
    where N::ArrayType: Copy
{
    pub data: GenericArray&amp;lt;T, N&amp;gt;,
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I implemented copy on this type because this library is intended for game devs which means that the dimensions will probably not bigger than 4. I also don&amp;rsquo;t think I can specialize structs at the moment to allow bigger vectors to be heap allocated. I also auto implemented PartialEq and Eq because I am lazy. Comparison should probably be implemented with &lt;code&gt;abs(a - b) &amp;lt; eps&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Implementing operators was a bit more verbose in Rust compared to D. I used macros to make it less verbose.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;macro_rules! as_expr { ($e:expr) =&amp;gt; {$e} }
macro_rules! impl_op_vec{
    ($trait_name: ident, $fn_name: ident, $op: tt) =&amp;gt; {
        impl&amp;lt;T, N&amp;gt; $trait_name for Vector&amp;lt;T, N&amp;gt;
            where N::ArrayType: Copy,
                  N: ArrayLength&amp;lt;T&amp;gt;,
                  T: Float
        {
            type Output = Vector&amp;lt;T, N&amp;gt;;
            fn $fn_name(self, other: Self) -&amp;gt; Self::Output {
                unsafe {
                    let mut new_data: GenericArray&amp;lt;T, N&amp;gt; = mem::uninitialized();
                    let iter = self.data
                        .iter()
                        .zip(other.data.iter())
                        .map(|(a, b)| as_expr!( *a $op *b));
                    for (index, val) in iter.enumerate() {
                        new_data[index] = val;
                    }
                    Vector::&amp;lt;T, N&amp;gt; { data: new_data }
                }
            }
        }
    }
}

impl_op_vec!(Sub, sub, -);
impl_op_vec!(Add, add, +);
impl_op_vec!(Mul, mul, *);
impl_op_vec!(Div, div, /);

macro_rules! impl_op_vec_un{
    ($trait_name: ident, $fn_name: ident, $op: tt) =&amp;gt; {
        impl&amp;lt;T, N&amp;gt; $trait_name&amp;lt;T&amp;gt; for Vector&amp;lt;T, N&amp;gt;
            where N::ArrayType: Copy,
                  N: ArrayLength&amp;lt;T&amp;gt;,
                  T: Float
        {
            type Output = Vector&amp;lt;T, N&amp;gt;;
            fn $fn_name(self, other: T) -&amp;gt; Self::Output {
                unsafe {
                    let mut new_data: GenericArray&amp;lt;T, N&amp;gt; = mem::uninitialized();
                    let iter = self.data
                        .iter()
                        .map(|a| as_expr!( *a $op other));
                    for (index, val) in iter.enumerate() {
                        new_data[index] = val;
                    }
                    Vector::&amp;lt;T, N&amp;gt; { data: new_data }
                }
            }
        }
    }
}

impl_op_vec_un!(Mul, mul, *);
impl_op_vec_un!(Add, add, +);
impl_op_vec_un!(Sub, sub, -);
impl_op_vec_un!(Div, div, /);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I am not a Rust programmer so this macro is probably not as nice as it should be, but basically all I am doing is a simple text substitution. The only hiccup that I encountered was the substitution for the &lt;code&gt;operator&lt;/code&gt;. For some reason I had to create a helper macro &lt;code&gt;as_expr&lt;/code&gt;. Not sure why this was necessary, but I assume that this might be a bug?&lt;/p&gt;

&lt;p&gt;In general I am not sure I like macros in Rust, because macros can accept almost arbitrary syntax. I think this makes macros very powerful but also painful for other people to use. As a client you probably always have to either read the documentation or look at the macro implementation yourself, so that you know how to invoke the macro correctly.&lt;/p&gt;

&lt;p&gt;Also you might notice that I am using unsafe here. I basically do this almost anywhere because of &lt;code&gt;mem::unitialzed()&lt;/code&gt;. The reason I am doing this is that I don&amp;rsquo;t think that it is possible to collect into a fixed length array / GenericArray from an iterator.&lt;/p&gt;

&lt;p&gt;The documentation engine is pretty nice in Rust, for example you can write&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;/// Builds a `Vector&amp;lt;T, N &amp;gt;` from a `Vector&amp;lt;T, N-1&amp;gt;` with an additional value.
/// # Example
/// ```
/// use rla::vector::*;
/// let v = Vec3f::from_one_less(Vec2f::new(&amp;amp;[1.0, 2.0]), 3.0);
/// assert!(v == Vec3f::new(&amp;amp;[1.0, 2.0, 3.0]));
/// ```
pub fn from_one_less(first: Vector&amp;lt;T, Sub1&amp;lt;N&amp;gt;&amp;gt;, val: T) -&amp;gt; Vector&amp;lt;T, N&amp;gt;{..}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and it will parse the comments as markdown. It also recognizes codeblocks, compiles and executes them.&lt;/p&gt;

&lt;p&gt;I currently haven&amp;rsquo;t implemented vector swizzling nor  individual member access like&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;v.x = 25;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The problem is that I don&amp;rsquo;t know how I would implement this in an ergonomic and clean way. For example in D you can have this&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;
auto x = v.x;
v.x = 24;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;where &lt;code&gt;x&lt;/code&gt; is a overloaded function &lt;code&gt;ref T x(){..}&lt;/code&gt; and &lt;code&gt;void x(T val){}&lt;/code&gt;, although I have implemented it a bit differently in D. I am posting the D implementation because I don&amp;rsquo;t think a lot of Rust programmers really know how metaprogramming looks like.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/BreezeEngine/breeze/blob/master/source/breeze/math/vector.d#L67+L86&#34;&gt;Implementation&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Feel free to skip this part if you are not interested in D.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-D&#34;&gt;struct Vector(T, size_t _dimension){
    private enum vectorCords = &amp;quot;xyzw&amp;quot;;
    ...
    ref auto opDispatch(string op)() inout
    if(op.length is 1){
        import std.string: indexOf;
        import std.algorithm.iteration: map;
        enum index = vectorCords.indexOf(op);
        return data[index];
    }
    auto opDispatch(string op)() const
    if(op.length &amp;gt; 1 &amp;amp;&amp;amp; op.length &amp;lt;= dimension){
        import std.string: indexOf;
        import std.algorithm.iteration: map;
        import std.range: array;
        import std.algorithm.mutation: copy;
        import std.algorithm.searching: count;
        static immutable indices = op.map!(c =&amp;gt; vectorCords.indexOf(c)).array;
        static assert(indices[].count(-1) == 0, &amp;quot;Combination of &amp;quot; ~op~&amp;quot; does not exist.&amp;quot;);
        T[op.length] _data;
        indices.map!(i =&amp;gt; data[i]).copy(_data[]);
        return Vector!(T,op.length)(_data);
    }
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For example &lt;code&gt;v.x&lt;/code&gt; here returns a value but &lt;code&gt;v.xy&lt;/code&gt; returns a Vec2. It is also possible to do &lt;code&gt;v.xyzzyzyy&lt;/code&gt; which would return a Vec8 but it is probably not really practical.&lt;/p&gt;

&lt;p&gt;The code works like this:
&lt;code&gt;private enum vectorCords = &amp;quot;xyzw&amp;quot;;&lt;/code&gt; is a compile time string. opDispatch receives the string behind the dot for an object at compile time. For example calling &lt;code&gt;v.xyz&lt;/code&gt;, opDispatch would receive the string &lt;code&gt;xyz&lt;/code&gt; at compile time. You then map this string at compile time to the index from &lt;code&gt;vectorCords&lt;/code&gt;. For this example it would map &lt;code&gt;&amp;quot;xyz&amp;quot;&lt;/code&gt; to &lt;code&gt;[0, 1, 2]&lt;/code&gt; at compile time. Then you simply look up the values and return the vector. The Vector will have the dimension of the length of the received
string which in this case is &lt;code&gt;xyz&lt;/code&gt;, so it will return a Vector3.&lt;/p&gt;

&lt;p&gt;Let us get back to Rust. Implementing this will be probably a bit harder. I will probably create 4 traits with a macro. &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;xy&lt;/code&gt;, &lt;code&gt;xyz&lt;/code&gt; and &lt;code&gt;xyzw&lt;/code&gt;. &lt;code&gt;xy&lt;/code&gt; will inherit from &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;xyz&lt;/code&gt; from &lt;code&gt;xy&lt;/code&gt; an so on. I will then create default implementations with a macro for all possible combinations. And then I will implement the traits manually for Vector2 - Vector4. I really wish that Rust would get a bit more metaprogramming support in the future.&lt;/p&gt;

&lt;p&gt;Matrices are implemented in a similar fashion.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;type Mat4x4&amp;lt;T&amp;gt; = Matrix&amp;lt;T, U4, U4&amp;gt;;
type Mat3x3&amp;lt;T&amp;gt; = Matrix&amp;lt;T, U3, U3&amp;gt;;
type Mat3x2&amp;lt;T&amp;gt; = Matrix&amp;lt;T, U3, U2&amp;gt;;
type Mat2x3&amp;lt;T&amp;gt; = Matrix&amp;lt;T, U2, U3&amp;gt;;
type Mat2x2&amp;lt;T&amp;gt; = Matrix&amp;lt;T, U2, U2&amp;gt;;

type Mat3x2f = Mat3x2&amp;lt;f32&amp;gt;;
type Mat2x3f = Mat2x3&amp;lt;f32&amp;gt;;
type Mat2x2f = Mat2x2&amp;lt;f32&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But implementing matrices was much harder than a simple vector. For example let us implement matrix multiplication. In case you are not familiar it looks like this
&lt;a href=&#34;https://en.wikipedia.org/wiki/Matrix_multiplication&#34;&gt;Matrix multiplication&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;N, M, N1, M1 &amp;gt; 0
N == N1
Matrix&amp;lt;N, M&amp;gt; * Matrix&amp;lt;N1, M1&amp;gt; = Matrix&amp;lt;M, N1&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;impl&amp;lt;T, N, M&amp;gt; Matrix&amp;lt;T, N, M&amp;gt;
    where ...
{
    fn mul&amp;lt;N1&amp;gt;(&amp;amp;self, other: &amp;amp;Matrix&amp;lt;T, N1, N&amp;gt;) -&amp;gt; Matrix&amp;lt;T, M, N1&amp;gt;{...}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Without type constrains this looks rather elegant. We implement &lt;code&gt;mul&lt;/code&gt; only on matrices that can be multiplied together, and then we return the correct matrix.&lt;/p&gt;

&lt;p&gt;My only gripe with this approach is that I don&amp;rsquo;t think it is possible to return a user defined error.&lt;/p&gt;

&lt;p&gt;For example a client might try to multiply &lt;code&gt;Matrix&amp;lt;f32, 3, 2&amp;gt; * Matrix&amp;lt;f32, 3, 2&amp;gt;&lt;/code&gt; which is not possible. It would be nice to output a custom error message to the user, something like this&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;Error: Tried to multiply Matrix&amp;lt;f32, 3, 2&amp;gt;,  Matrix&amp;lt;f32, 3, 2&amp;gt;, but the dimesions of
Matrix&amp;lt;f32, 3, 2&amp;gt;,  Matrix&amp;lt;f32, 3, 2&amp;gt;  don&#39;t match.
            ^~~~~~~~~~~~~~~~~~~~~~~^
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is possible in D but I don&amp;rsquo;t think something like this can currently be implemented in Rust. Another occurrence would be &lt;code&gt;identity&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;An &lt;a href=&#34;https://en.wikipedia.org/wiki/Identity_matrix&#34;&gt;identity matrix&lt;/a&gt; can only implemented on a matrix of type &lt;code&gt;Matrix&amp;lt;T, N, N&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;impl&amp;lt;T, N&amp;gt; Matrix&amp;lt;T, N, N&amp;gt;
    where ...
{
    fn identity() -&amp;gt; Matrix&amp;lt;T, N, N&amp;gt; {
        ...
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It then would be nice to also output a custom error message if the user wants to call &lt;code&gt;identity&lt;/code&gt; on a non-square matrix.&lt;/p&gt;

&lt;p&gt;If we look at this code again, we see that I have left out the type constrains. I did this on purpose because they look quite hilariously verbose.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;impl&amp;lt;T, N, M&amp;gt; Matrix&amp;lt;T, N, M&amp;gt;
{
    fn mul&amp;lt;N1&amp;gt;(&amp;amp;self, other: &amp;amp;Matrix&amp;lt;T, N1, N&amp;gt;) -&amp;gt; Matrix&amp;lt;T, M, N1&amp;gt;{...}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But it was a good exercise to see how good Rust&amp;rsquo;s error messages really are.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;// funny stuff is happening here
impl&amp;lt;T, N, M&amp;gt; Matrix&amp;lt;T, N, M&amp;gt;
    where T: Float,
          N: ArrayLength&amp;lt;T&amp;gt; + ArrayLength&amp;lt;Vector&amp;lt;T, M&amp;gt;&amp;gt;,
          M: ArrayLength&amp;lt;T&amp;gt; + ArrayLength&amp;lt;Vector&amp;lt;T, N&amp;gt;&amp;gt;,
          &amp;lt;N as ArrayLength&amp;lt;Vector&amp;lt;T, M&amp;gt;&amp;gt;&amp;gt;::ArrayType: Copy,
          &amp;lt;M as ArrayLength&amp;lt;Vector&amp;lt;T, N&amp;gt;&amp;gt;&amp;gt;::ArrayType: Copy,
          &amp;lt;N as ArrayLength&amp;lt;T&amp;gt;&amp;gt;::ArrayType: Copy,
          &amp;lt;M as ArrayLength&amp;lt;T&amp;gt;&amp;gt;::ArrayType: Copy
{
    fn mul&amp;lt;N1&amp;gt;(&amp;amp;self, other: &amp;amp;Matrix&amp;lt;T, N1, N&amp;gt;) -&amp;gt; Matrix&amp;lt;T, M, N1&amp;gt;
        where N1: ArrayLength&amp;lt;T&amp;gt; + ArrayLength&amp;lt;Vector&amp;lt;T, M&amp;gt;&amp;gt; + ArrayLength&amp;lt;Vector&amp;lt;T, N&amp;gt;&amp;gt;,
              &amp;lt;N1 as ArrayLength&amp;lt;T&amp;gt;&amp;gt;::ArrayType: Copy,
              &amp;lt;N1 as ArrayLength&amp;lt;Vector&amp;lt;T, M&amp;gt;&amp;gt;&amp;gt;::ArrayType: Copy,
              &amp;lt;N1 as ArrayLength&amp;lt;Vector&amp;lt;T, N&amp;gt;&amp;gt;&amp;gt;::ArrayType: Copy,
              N: ArrayLength&amp;lt;Vector&amp;lt;T, N1&amp;gt;&amp;gt;,
              &amp;lt;N as ArrayLength&amp;lt;Vector&amp;lt;T, N1&amp;gt;&amp;gt;&amp;gt;::ArrayType: Copy,
              Vector&amp;lt;T, N&amp;gt;: Copy
    {
        unsafe {
            let mut new_matrix: Matrix&amp;lt;T, M, N1&amp;gt; = mem::uninitialized();
            let other_transposed: Matrix&amp;lt;T, N, N1&amp;gt; = other.transpose();
            for j in 0..N1::to_usize() {
                for i in 0..M::to_usize() {
                    new_matrix.data[j].data[i] = self.data[j].dot(other_transposed.data[i]);
                }
            }
            new_matrix
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Obviously this looks horrendous and I am not even sure I had to write it like that. It was really annoying to repeatedly specify the copy constrain.&lt;/p&gt;

&lt;p&gt;The only good part was that it was super trivial to write. I did 0 thinking about any constrains, I just looked at the error messages and copy pasted the constrain. I did this until Rust stopped complaining. I was really surprised that how easy this was and it would probably not be too unreasonable to think that the constrains could possibly be generated with some external tool.&lt;/p&gt;

&lt;p&gt;My experience with cargo and crates.io was flawless so far. I didn&amp;rsquo;t run into any issue at all. I really like how intuitive it was to get up and running. Publishing a crate was also pretty simple, you can find it &lt;a href=&#34;https://crates.io/crates/rla&#34;&gt;here&lt;/a&gt;. Please note that the library is completely experimental and will probably never be finished.&lt;/p&gt;

&lt;p&gt;It was also possible to add a .git repository inside a cargo.toml, which I had to do with my task pool library. More on that in part 2.&lt;/p&gt;

&lt;p&gt;Also cargo allows you to directly install binaries into .cargo. For example you can install cargo watch like this &lt;code&gt;cargo install cargo-watch&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;This concludes Part 1, in Part 2 I will continue with my task pool library.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Why and when you should use SoA</title>
      <link>https://maikklein.github.io/post/soa-d/</link>
      <pubDate>Fri, 25 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://maikklein.github.io/post/soa-d/</guid>
      <description>

&lt;h1 id=&#34;what-is-soa:45fcc6ad2f422f60b5d46d1e0ac7de22&#34;&gt;What is SoA?&lt;/h1&gt;

&lt;p&gt;SoA just means &lt;code&gt;Structure of arrays&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-d&#34;&gt;//AoS: Array of structures
struct Vec2{
    float x;
    float y;
}
Array!Vec2 vectors;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-d&#34;&gt;//SoA: Structure of arrays
struct Vec2{
    float[] x;
    float[] y;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;why-is-soa-useful:45fcc6ad2f422f60b5d46d1e0ac7de22&#34;&gt;Why is SoA useful?&lt;/h1&gt;

&lt;p&gt;Imagine you want to write a small &lt;code&gt;udp game server&lt;/code&gt; with a &lt;code&gt;client server architecture&lt;/code&gt;. You will have a server where clients can connect to. The &lt;code&gt;server&lt;/code&gt; needs to remember which clients are currently connected. The server polls messages with &lt;code&gt;recvfrom&lt;/code&gt; and in case you are not familiar with udp &lt;code&gt;recvfrom&lt;/code&gt; returns the packet that was sent to the port where to socket was bound to and the address.&lt;/p&gt;

&lt;p&gt;When a packet comes in the first thing you probably want to know is if the packet came from a connected client. You would be inclined to write it like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct Server{
    struct RemoteClient{
        Address address;
        SysTime lastReceivedPacket;
        //more data
    }
    Array!RemoteClient remoteClients;

    void poll(){
        //Address address
        //recvfrom(buffer, address);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we want to know which client has sent the package we can just use the &lt;code&gt;remoteClients&lt;/code&gt; array to find the correct &lt;code&gt;remoteClient&lt;/code&gt;. The problem is that we need to iterate over &lt;code&gt;RemoteClient&lt;/code&gt; but we are only really interested in the address field. That means we needlessly load all the other data like &lt;code&gt;lastReceivedPacket&lt;/code&gt; even if we don&amp;rsquo;t need it.&lt;/p&gt;

&lt;p&gt;And if you are curious how much data could be inside a &lt;code&gt;RemoteClient&lt;/code&gt; in a real world application, here is the struct of &lt;a href=&#34;https://github.com/lsalzman/enet/blob/master/include/enet/enet.h#L258&#34;&gt;Enet Peer&lt;/a&gt;. It might not be the fairest comparison because it is a &lt;code&gt;Peer&lt;/code&gt; and not a &lt;code&gt;RemoteClient&lt;/code&gt; but it should illustrate the point that your data might grow fairly large.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;typedef struct _ENetPeer
{ 
   ENetListNode  dispatchList;
   struct _ENetHost * host;
   enet_uint16   outgoingPeerID;
   enet_uint16   incomingPeerID;
   enet_uint32   connectID;
   enet_uint8    outgoingSessionID;
   enet_uint8    incomingSessionID;
   ENetAddress   address;            /**&amp;lt; Internet address of the peer */
   void *        data;               /**&amp;lt; Application private data, may be freely modified */
   ENetPeerState state;
   ENetChannel * channels;
   size_t        channelCount;       /**&amp;lt; Number of channels allocated for communication with peer */
   enet_uint32   incomingBandwidth;  /**&amp;lt; Downstream bandwidth of the client in bytes/second */
   enet_uint32   outgoingBandwidth;  /**&amp;lt; Upstream bandwidth of the client in bytes/second */
   enet_uint32   incomingBandwidthThrottleEpoch;
   enet_uint32   outgoingBandwidthThrottleEpoch;
   enet_uint32   incomingDataTotal;
   enet_uint32   outgoingDataTotal;
   enet_uint32   lastSendTime;
   enet_uint32   lastReceiveTime;
   enet_uint32   nextTimeout;
   enet_uint32   earliestTimeout;
   enet_uint32   packetLossEpoch;
   enet_uint32   packetsSent;
   enet_uint32   packetsLost;
   enet_uint32   packetLoss;          /**&amp;lt; mean packet loss of reliable packets as a ratio with respect to the constant ENET_PEER_PACKET_LOSS_SCALE */
   enet_uint32   packetLossVariance;
   enet_uint32   packetThrottle;
   enet_uint32   packetThrottleLimit;
   enet_uint32   packetThrottleCounter;
   enet_uint32   packetThrottleEpoch;
   enet_uint32   packetThrottleAcceleration;
   enet_uint32   packetThrottleDeceleration;
   enet_uint32   packetThrottleInterval;
   enet_uint32   pingInterval;
   enet_uint32   timeoutLimit;
   enet_uint32   timeoutMinimum;
   enet_uint32   timeoutMaximum;
   enet_uint32   lastRoundTripTime;
   enet_uint32   lowestRoundTripTime;
   enet_uint32   lastRoundTripTimeVariance;
   enet_uint32   highestRoundTripTimeVariance;
   enet_uint32   roundTripTime;
   enet_uint32   roundTripTimeVariance;
   enet_uint32   mtu;
   enet_uint32   windowSize;
   enet_uint32   reliableDataInTransit;
   enet_uint16   outgoingReliableSequenceNumber;
   ENetList      acknowledgements;
   ENetList      sentReliableCommands;
   ENetList      sentUnreliableCommands;
   ENetList      outgoingReliableCommands;
   ENetList      outgoingUnreliableCommands;
   ENetList      dispatchedCommands;
   int           needsDispatch;
   enet_uint16   incomingUnsequencedGroup;
   enet_uint16   outgoingUnsequencedGroup;
   enet_uint32   unsequencedWindow [ENET_PEER_UNSEQUENCED_WINDOW_SIZE / 32]; 
   enet_uint32   eventData;
   size_t        totalWaitingData;
} ENetPeer;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now let us see how it would look with &lt;code&gt;SoA&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct Server{
    struct RemoteClients{
        size_t length;
        Address[] address;
        SysTime[] lastReceivedPacket;
        //more data
    }
    RemoteClients remoteClients;

    void poll(){
        //Address address
        //recvfrom(buffer, address);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can access all addresses with &lt;code&gt;remoteClients.address&lt;/code&gt; and we don&amp;rsquo;t need to load unnecessary data into the cache.&lt;/p&gt;

&lt;h1 id=&#34;isn-t-soa-awkward-to-use:45fcc6ad2f422f60b5d46d1e0ac7de22&#34;&gt;Isn&amp;rsquo;t SoA awkward to use?&lt;/h1&gt;

&lt;p&gt;In most languages it is.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct RemoteClients{
    size_t length;
    Address[] address;
    SysTime[] lastReceivedPacket;
    //more data
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The definition is simplified because we need to allocate the arrays, grow them if we want to have dynamic arrays. We also need to worry about inserting and removing elements, it shouldn&amp;rsquo;t happen that we only add an address to &lt;code&gt;RemoteClients&lt;/code&gt; without adding &lt;code&gt;lastReceivedPacket&lt;/code&gt;. That is because the data is loosely coupled. Previously with &lt;code&gt;AoS&lt;/code&gt; we could access the &lt;code&gt;RemoteClient&lt;/code&gt; with &lt;code&gt;remoteClients[index]&lt;/code&gt; but now we are accessing a &lt;code&gt;RemoteClient&lt;/code&gt; by its components
&lt;code&gt;remoteClients.addresses[index]&lt;/code&gt; and &lt;code&gt;remoteClients.lastReceivedPacket[index]&lt;/code&gt;.&lt;/p&gt;

&lt;h1 id=&#34;implementing-soa-in-d:45fcc6ad2f422f60b5d46d1e0ac7de22&#34;&gt;Implementing SoA in D&lt;/h1&gt;

&lt;p&gt;First let us start with a demonstration.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-d&#34;&gt;struct Vec2{
    float x;
    float y;
}
auto s = SOA!(Vec2)();

s.insertBack(1.0f, 2.0f);
s.insertBack(Vec2(1.0, 2.0f));
writeln(s.x); // [1, 1]
writeln(s.y); // [2, 2]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can still create a struct with our data, &lt;code&gt;SOA&lt;/code&gt; will then look at the struct and create the correct arrays internally. &lt;code&gt;insertBack&lt;/code&gt; is now a bit different from a normal array because internally we have as many arrays as we have fields. That means &lt;code&gt;insertBack&lt;/code&gt; needs to be variadic. Alternatively &lt;code&gt;insertBack&lt;/code&gt; could also accept the struct itself.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;The following code is not intended to be production ready code, it is merely a proof of concept.&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-d&#34;&gt;struct SOA(T){
    import std.experimental.allocator;
    import std.experimental.allocator.mallocator;

    import std.meta: staticMap;
    import std.typecons: Tuple;
    import std.traits: FieldNameTuple;

    alias toArray(T) = T[];
    alias toType(string s) = typeof(__traits(getMember, T, s));

    alias MemberNames = FieldNameTuple!T;
    alias Types = staticMap!(toType, MemberNames);
    alias ArrayTypes = staticMap!(toArray, Types);

    this(size_t _size, IAllocator _alloc = allocatorObject(Mallocator.instance)){
        alloc = _alloc;
        size = _size;
        allocate(size);
    }

    ref auto opDispatch(string name)(){
        import std.meta: staticIndexOf;
        alias index = staticIndexOf!(name, MemberNames);
        static assert(index &amp;gt;= 0);
        return containers[index];
    }

    void insertBack(Types types){
        if(length == size) grow;
        foreach(index, ref container; containers){
            container[length] = types[index];
        }
        length = length + 1;
    }

    void insertBack(T t){
        if(length == size) grow;
        foreach(index, _; Types){
            containers[index][length] = __traits(getMember, t, MemberNames[index]);
        }
        length = length + 1;
    }

    size_t length() const @property{
        return _length;
    }

    ~this(){
        if(alloc is null) return;
        foreach(ref container; containers){
            alloc.dispose(container);
        }
    }

private:
    void length(size_t len)@property{
        _length = len;
    }

    Tuple!ArrayTypes containers;
    IAllocator alloc;

    size_t _length = 0;
    size_t size = 0;
    short growFactor = 2;

    void allocate(size_t size){
        if(alloc is null){
            alloc = allocatorObject(Mallocator.instance);
        }
        foreach(index, ref container; containers){
            container = alloc.makeArray!(Types[index])(size);
        }
    }

    void grow(){
        import std.algorithm: max;
        size_t newSize = max(1,size * growFactor);
        size_t expandSize = newSize - size;

        if(size is 0){
            allocate(newSize);
        }
        else{
            foreach(ref container; containers){
                alloc.expandArray(container, expandSize);
            }
        }
        size = newSize;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-d&#34;&gt;alias toArray(T) = T[];
alias toType(string s) = typeof(__traits(getMember, T, s));

alias MemberNames = FieldNameTuple!T;
alias Types = staticMap!(toType, MemberNames);
alias ArrayTypes = staticMap!(toArray, Types);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;MemberNames&lt;/code&gt; are just the names of the fields. For example &lt;code&gt;struct Vec2{float x; float y}&lt;/code&gt; will have the type &lt;code&gt;AliasSeq!(&amp;quot;x&amp;quot;, &amp;quot;y&amp;quot;)&lt;/code&gt;. &lt;code&gt;toType&lt;/code&gt; takes the member name and turns it into an actual type. In the example above &lt;code&gt;toType!(&amp;quot;x&amp;quot;)&lt;/code&gt; would return the type &lt;code&gt;float&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Now we can convert the member names into actual types with the help of &lt;code&gt;staticMap&lt;/code&gt;. In the example above &lt;code&gt;AliasSeq!(&amp;quot;x&amp;quot;, &amp;quot;y&amp;quot;)&lt;/code&gt; would be transformed into &lt;code&gt;AliasSeq!(float, float)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We are almost there we just now need to convert the types to arrays. &lt;code&gt;AliasSeq!(float, float)&lt;/code&gt; to &lt;code&gt;AliasSeq!(float[], float[])&lt;/code&gt;. We do this with &lt;code&gt;toArray&lt;/code&gt; and &lt;code&gt;staticMap&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;After that we can create a tuple of arrays&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-d&#34;&gt;Tuple!ArrayTypes containers;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Inserting elements is fairly easy now.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-d&#34;&gt;void insertBack()(Types types){
    if(length == size) grow;
    foreach(index, ref container; containers){
        container[length] = types[index];
    }
    length = length + 1;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We already now what types &lt;code&gt;insertBack&lt;/code&gt; should accept. It should accept the types of the fields of the struct. We then iterate over &lt;code&gt;containers&lt;/code&gt; at compile time, which is our tuple of arrays.&lt;/p&gt;

&lt;p&gt;Then we just access the correct &lt;code&gt;argument&lt;/code&gt; with &lt;code&gt;types[index]&lt;/code&gt; and insert it into the array.&lt;/p&gt;

&lt;p&gt;We can also insert the struct itself.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-d&#34;&gt;void insertBack(T t){
    if(length == size) grow;
    foreach(index, _; Types){
        containers[index][length] = __traits(getMember, t, MemberNames[index]);
    }
    length = length + 1;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We iterate over the Types to get the &lt;code&gt;index&lt;/code&gt;. We use &lt;code&gt;index&lt;/code&gt; to get the correct container and to find the correct field name of the struct. This works because the order is always the same.&lt;/p&gt;

&lt;p&gt;The code above for &lt;code&gt;Vec2&lt;/code&gt; would roughly look like this&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-d&#34;&gt;void insertBack(Vec2 t){
    if(length == size) grow;
    containers[0][length] = t.x;
    containers[1][length] = t.y;
    length = length + 1;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can access the arrays with the field names. In D this is very easy to do with &lt;code&gt;opDispatch&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-d&#34;&gt;ref auto opDispatch(string name)(){
    import std.meta: staticIndexOf;
    alias index = staticIndexOf!(name, MemberNames);
    static assert(index &amp;gt;= 0);
    return containers[index];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the example above for &lt;code&gt;Vec2&lt;/code&gt; we can get to the array of all x&amp;rsquo;s with &lt;code&gt;s.x&lt;/code&gt; or all y&amp;rsquo;s with &amp;rsquo;s.y&amp;rsquo;. &lt;code&gt;opDispatch&lt;/code&gt; would roughly look like this at compile time if we call &lt;code&gt;s.x&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-d&#34;&gt;ref auto opDispatch(){
    import std.meta: staticIndexOf;
    alias index = staticIndexOf!(&amp;quot;x&amp;quot;, MemberNames);
    static assert(index &amp;gt;= 0);
    return containers[index];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We just get the index of &lt;code&gt;opDispatch&lt;/code&gt; &lt;code&gt;name&lt;/code&gt; in &lt;code&gt;MemberNames&lt;/code&gt;, if it is not inside &lt;code&gt;MemberNames&lt;/code&gt; &lt;code&gt;opDispatch&lt;/code&gt; will fail. If it is inside &lt;code&gt;MemberNames&lt;/code&gt; we just access the correct container with the index.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct Server{
    struct RemoteClients{
        Address address;
        SysTime lastReceivedPacket;
        //more data
    }
    SOA!RemoteClient remoteClients;

    void poll(){
        //Address address
        //recvfrom(buffer, address);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;when-to-use-soa:45fcc6ad2f422f60b5d46d1e0ac7de22&#34;&gt;When to use SoA&lt;/h1&gt;

&lt;p&gt;Firs ot all &lt;code&gt;SoA&lt;/code&gt; is not a silver bullet and it doesn&amp;rsquo;t mean you should replace &lt;code&gt;AoS&lt;/code&gt; with &lt;code&gt;SoA&lt;/code&gt; everywhere in your code base.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;SoA&lt;/code&gt; makes sense if:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;You know that you want to store your data in an array.&lt;/li&gt;
&lt;li&gt;You want partial access to the data.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;But sometimes you still want to access all components of your data. An example would be a vector.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-d&#34;&gt;struct Vec3{
    float x;
    float y;
    float z;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Most operations will use all components anyways like add, subtract, dot, length and many more. And even if you sometimes end up with&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-d&#34;&gt;struct Vec3{
    float x;
    float y;
    float z;
}

Array!Vec3 positions;

positions[].filter!(v =&amp;gt; v.x &amp;lt; 10.0f);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and you want to filter all vectors where the &lt;code&gt;x component&lt;/code&gt; is less than &lt;code&gt;10.0f&lt;/code&gt;, you  will still only load two additional floats. Also a &lt;code&gt;Vec3&lt;/code&gt; struct won&amp;rsquo;t get bigger in time, other data structures might grow and become a bottleneck in the future.&lt;/p&gt;

&lt;h1 id=&#34;isn-t-soa-premature-optimization:45fcc6ad2f422f60b5d46d1e0ac7de22&#34;&gt;Isn&amp;rsquo;t SoA premature optimization?&lt;/h1&gt;

&lt;p&gt;In my opinion it is not. The problem with &lt;code&gt;AoS&lt;/code&gt; is that if it becomes a performance bottleneck in the future, you will have to refactor a lot of code. For example you might want to pack your data into a struct hot and cold like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-d&#34;&gt;struct Bar{
    struct Hot{
        Data1 d1;
        Data2 d2;
        ...
    }
    struct Cold{
        Data3 d3;
        Data4 d4;
        ...
    }

    Hot* hot;
    Cold* cold;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;but depending on the language you will still have to refactor a lot of code. It might save you some trouble to think about your data access early on.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=ZHqFrNyLlpA&#34;&gt;Jonathan Blow&lt;/a&gt; has a language demonstration that covers SoA and anonymous variables.
&lt;em&gt;Quick note: &lt;code&gt;Jonathan Blow&lt;/code&gt;&amp;rsquo;s &lt;code&gt;using&lt;/code&gt; is very similar to &lt;code&gt;alias this&lt;/code&gt; in D.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;SoA&lt;/code&gt; isn&amp;rsquo;t much worse compared to &lt;code&gt;AoS&lt;/code&gt; depending on the language you use.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-d&#34;&gt;//AoS
remoteClients[index].address;

//vs 

//SoA
remoteClients.address[index];

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But &lt;code&gt;SoA&lt;/code&gt; scales much better because you can partially access your data without needlessly loading unrelevant data into your cache.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>A comparison between C&#43;&#43; and D</title>
      <link>https://maikklein.github.io/post/CppAndD/</link>
      <pubDate>Tue, 01 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://maikklein.github.io/post/CppAndD/</guid>
      <description>

&lt;h1 id=&#34;general:0cb2d9f6a8190c19d85664260328e5f6&#34;&gt;General&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;D has &lt;code&gt;modules&lt;/code&gt; which results in faster build times compared to C++. C++ might get modules after C++17. Clang and MSVC also have experimental support for &lt;code&gt;modules&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;D supports local imports which makes it easy to move functions into different files.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void foo(){
    import std.stdio: writeln;
    writeln(&amp;quot;foo&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;D has integrated &lt;code&gt;unittests&lt;/code&gt; and can be written directly in the source file that you want to test. This means you can write &lt;code&gt;unittests&lt;/code&gt; directly under the function that you are testing.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;class&lt;/code&gt; and &lt;code&gt;struct&lt;/code&gt; have a different meaning in C++ and D. In C++ they almost identical, just with different visibility defaults. In D structs can not use inheritance or interfaces. While classes can have inheritance and interfaces but lack support for deterministic destructors. A full list of differences can be found &lt;a href=&#34;https://dlang.org/spec/struct.html&#34;&gt;here&lt;/a&gt;. Classes in D are usually dynamically allocated, but they can also be allocated on the stack. Classes are by default reference types. If &lt;code&gt;T&lt;/code&gt; is a class then it implicitly is &lt;code&gt;T*&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;D comes with a default GC while C++ is GC free. D can also be used without a GC but there are a few inconveniences. First the standard library(phobos) in D is not move aware. This means you can not have a &lt;code&gt;std::vector&amp;lt;std::unique_ptr&amp;gt;&lt;/code&gt; in phobos. It is possible to write your own containers that are move aware which means it is possible to have an array or vector with unique pointers.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Moving in C++ is just an rvalue cast while in D it really moves. In C++ you would write a function &lt;code&gt;template&amp;lt;class T&amp;gt; void foo(T&amp;amp;&amp;amp; t){}&lt;/code&gt;, it captures &lt;code&gt;t&lt;/code&gt; as &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; if &lt;code&gt;t&lt;/code&gt; is an rvalue or it captures &lt;code&gt;t&lt;/code&gt; as &lt;code&gt;T&amp;amp;&lt;/code&gt; if &lt;code&gt;t&lt;/code&gt; is an lvalue. You then use &lt;code&gt;std::move&lt;/code&gt; with a &lt;code&gt;move constructor&lt;/code&gt; to move your objects and &lt;code&gt;std::forward&lt;/code&gt; to perfectly forward your objects. In D you would create two functions &lt;code&gt;void foo(T)(ref T t){}&lt;/code&gt; which always captures lvalues by references and &lt;code&gt;void foo(T)(T t){}&lt;/code&gt; which only captures rvalues. As far as I know moving in D is also not exception safe. D moves objects with a bitwise copy, this means you are not allowed to have internal pointers.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;structs&lt;/code&gt; in D don&amp;rsquo;t have a default constructor because every struct needs exception free default construction and this must be known at compile time. But it is possible to initalize structs with custom values.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct Foo{
  int i = 42;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Variables in D are always initialized unless explicity told not to &lt;code&gt;Foo f = void;&lt;/code&gt;. Initialization rules are bit more complicated in C++ and depend on the context.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;D as well as C++ can disable default construction, copy construction and copy assignment. Note that in D it is still possible to call &lt;code&gt;T.init&lt;/code&gt; even if the default constructor is disabled.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;In C++ local references can escape the scope while in D they can&amp;rsquo;t.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The allocator in C++ is a template argument (at least in the STL) while in D it can be changed at runtime. This means that you can have different allocators inside an array. You can find more information &lt;a href=&#34;https://dlang.org/phobos/std_experimental_allocator.html&#34;&gt;here&lt;/a&gt;. The allocator in D is still experimental.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;C++ needs explicit function specifiers such as &lt;code&gt;noexcept&lt;/code&gt; &lt;code&gt;const&lt;/code&gt; &lt;code&gt;constexpr&lt;/code&gt; while in D they are inferred if the function/method is a template. This means that &lt;code&gt;void foo(T)(...)nothrow, const, pure, @nogc{}&lt;/code&gt; can just be &lt;code&gt;void foo(T)(...)&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Functions and methods in D can be called without parenthesis if they have no arguments. &lt;code&gt;void foo(){}; foo;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;C++ as well as D have anonymous functions. C++: &lt;code&gt;[](auto a, auto b){ return a + b;}&lt;/code&gt; , D: &lt;code&gt;(a, b) =&amp;gt; a + b&lt;/code&gt; or &lt;code&gt;(a, b){return a + b;}&lt;/code&gt;. As far as I know capturing other variables requires the GC in D. In C++ you can explicitly capture variables by copy, ref or move. Lambda functions in D can not return references. C++17 will also make lambda functions available with &lt;code&gt;constexpr&lt;/code&gt;. Lambda functions can also be used at compile time in D.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Unlike in C++ the order of declarations doesn&amp;rsquo;t matter in D.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;D has built in documentation comments. In C++ you have to use an external tool such as doxygen.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;D has &lt;code&gt;alias this&lt;/code&gt; which makes composition of types without inheritance really easy.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct Foo{
  Bar bar;
  alias bar this;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The code above forwards all methods and members from &lt;code&gt;Bar&lt;/code&gt; to &lt;code&gt;Foo&lt;/code&gt; and makes &lt;code&gt;Foo&lt;/code&gt; implicitly convertible to &lt;code&gt;Bar&lt;/code&gt;. The implicit conversion can be removed by using &lt;code&gt;Proxy&lt;/code&gt; instead of alias this.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Operator of overloading in C++ &lt;code&gt;Foo Foo::operator+(Foo const&amp;amp; foo){}&lt;/code&gt;. Operator overloading in D &lt;code&gt;Foo opBinary(string op)(in Foo f)&lt;/code&gt;. This allows the &lt;a href=&#34;http://wiki.dlang.org/Mixin_Macros_Pattern&#34;&gt;mixin macros pattern&lt;/a&gt; which can remove a lot of boilerplate code for you.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;D has universal function call syntax (ufcs). This just means that functions can also be called like methods &lt;code&gt;foo(bar)&lt;/code&gt; or &lt;code&gt;bar.foo()&lt;/code&gt;. This is similar to extension methods in C#. C++17 might also get some form of ufcs.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;C++ has &lt;code&gt;user defined literals&lt;/code&gt; like &lt;code&gt;1_seconds&lt;/code&gt;. D doesn&amp;rsquo;t have this feature but it can be emualted with ufcs &lt;code&gt;1.seconds&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Conditonal compilation uses the pre-processor in C++ &lt;code&gt;#if, #elif, #else, and #endif Directives&lt;/code&gt;. In D it is &lt;code&gt;version(YourKeyword){...}&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Exceptions in D can be allocated by the GC with &lt;code&gt;new&lt;/code&gt; but you can also allocate the storage for an exception yourself.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;C++ has &lt;code&gt;namespaces&lt;/code&gt; and are used like this &lt;code&gt;namespace Foo{ namespace Bar{ namespace Baz{..}}}&lt;/code&gt;. D uses modules with a file structure. To get &lt;code&gt;foo.bar.baz&lt;/code&gt; you can create &lt;code&gt;baz.d&lt;/code&gt; inside the &lt;code&gt;bar&lt;/code&gt; folder and &lt;code&gt;bar&lt;/code&gt; inside the &lt;code&gt;foo&lt;/code&gt; folder.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Globals in D are only thread local by default unless they are immutable. To get thread safe global access you would mark the global variable as &lt;code&gt;shared&lt;/code&gt;. To get the same global variables as in C++ you would use &lt;code&gt;__gshared&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;const&lt;/code&gt; in D is &lt;a href=&#34;https://dlang.org/const-faq.html#transitive-const&#34;&gt;transitive&lt;/a&gt;. In D and C++ it is &lt;code&gt;undefined behaviour&lt;/code&gt; to cast away the &lt;code&gt;const&lt;/code&gt; and modify the object.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;meta-programming:0cb2d9f6a8190c19d85664260328e5f6&#34;&gt;Meta programming&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;It is possible to pass almost any value to a template in D. C++ is limited to integrals, chars and addresses of functions and symbols.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Template instantiations are done in C++ with &lt;code&gt;&amp;lt;Foo,Bar&amp;gt;&lt;/code&gt; and in D with &lt;code&gt;!(Foo,bar)&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;D has no fold expressions like C++ &lt;code&gt;foo(f(args)...);&lt;/code&gt;, although they can be implemented as a library.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;D can evaluate almost any function at compile time with very few restrictions. One restriction would be casting see &lt;a href=&#34;http://stackoverflow.com/a/35701007/944430&#34;&gt;answer&lt;/a&gt; for more information where in C++ those functions need to be marked as &lt;code&gt;constexpr&lt;/code&gt; and have many restrictions such as no allocations.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;C++ can have multiple variadic templates &lt;code&gt;template&amp;lt;class... As, class... Bs&amp;gt;&lt;/code&gt; but they need to be inferred. This is not possible in D but you can have templates of templates &lt;code&gt;contains!SomeTypes.all!SomeOtherTypes&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;D can generate strings at compile time and compile them at compile time with &lt;code&gt;mixin&lt;/code&gt;, this is not possible in C++.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;C++ has macros while D does not. &lt;code&gt;mixins&lt;/code&gt; are capable of replacing macros.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;D has static reflection/introspection, this feature might come to C++ after C++17. This can currently be emulated to some extent with &lt;code&gt;libclang&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;D also has &lt;code&gt;user defined attributes&lt;/code&gt; &lt;code&gt;@Encrypted string name;&lt;/code&gt; which can be used by D&amp;rsquo;s static introspection. C++17 gets &lt;code&gt;user defined attributes&lt;/code&gt; in the form of &lt;code&gt;[[YourKeyWord]]&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;D can print any type at runtime with &lt;code&gt;writeln(SomeType.stringof)&lt;/code&gt; or &lt;code&gt;writeln(typeof(somevar).stringof)&lt;/code&gt;. Anything that is available at compile time can be printed at compile time with &lt;code&gt;pragma(msg, SomeType)&lt;/code&gt;. This is very useful for debugging meta programs. C++ can only do this with some compiler hacks as far as I know.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;It is possible to pass &lt;code&gt;symbols&lt;/code&gt; to templates in D. &lt;code&gt;template Foo(alias someSymbol)&lt;/code&gt; This just means that it is possible to pass anything that is available at compile time into &lt;code&gt;Foo&lt;/code&gt;. Examples would be other templates, functions, lambdas, constants etc. This is similar to Lisp.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;D has &lt;code&gt;static if&lt;/code&gt;. It is possible to use template specialization in C++ to achieve something similar.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;em&gt;Unsure, need more benchmarks&lt;/em&gt; Compile times for meta programming seems to be roughly equivalent between C++ and D.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;In D it is possible to iterate over variadic types with a foreach loop. In C++ this can be achieved as a library, for example with &lt;a href=&#34;https://github.com/boostorg/hana&#34;&gt;Boost hana&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-d&#34;&gt;foreach(index, type; VaradicTypes){
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Variadics in D are automatically expanded while in C++ you expand them explicitly with fold expressions.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Variadics in D can be sliced &lt;code&gt;VariadicTypes[1 .. $]&lt;/code&gt; this creates a variadic type list without the first type.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Metaprogramming with type objects in D</title>
      <link>https://maikklein.github.io/2016/03/01/metaprogramming-typeobject</link>
      <pubDate>Tue, 01 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://maikklein.github.io/2016/03/01/metaprogramming-typeobject</guid>
      <description>&lt;p&gt;I am going to introduce you to &lt;code&gt;Type Objects&lt;/code&gt; and why they might be useful in combination with metaprogramming.
This blog post is heavily inspired by &lt;a href=&#34;https://github.com/boostorg/hana&#34;&gt;Boost Hana&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Let us start with an example. If we would want to implement an &lt;code&gt;Algebraic Data Type&lt;/code&gt; we would need to find out the maximal size of the types it should contain. In D that is pretty easy&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-d&#34;&gt;import std.meta: AliasSeq;
import std.traits: Largest;
alias Types = AliasSeq!(int, float, char, double);
enum maxSize = Largest!(Types).sizeof;
writeln(maxSize);//8 bytes
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Largest is implemented like this&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-d&#34;&gt;template Largest(T...) if(T.length &amp;gt;= 1)
{
    static if (T.length == 1)
    {
        alias Largest = T[0];
    }
    else static if (T.length == 2)
    {
        static if(T[0].sizeof &amp;gt;= T[1].sizeof)
        {
            alias Largest = T[0];
        }
        else
        {
            alias Largest = T[1];
        }
    }
    else
    {
        alias Largest = Largest!(Largest!(T[0 .. $/2]), Largest!(T[$/2 .. $]));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But if &lt;code&gt;Largest&lt;/code&gt; wouldn&amp;rsquo;t be available, it would be quite annoying to always create a new template. Alternatively we could implement &lt;code&gt;Largest&lt;/code&gt; like this&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-d&#34;&gt;import std.meta: AliasSeq, staticMap;
import std.traits: Largest;
import std.algorithm.comparison: max;
alias Types = AliasSeq!(int, float, char, double);
enum size(T) = T.sizeof;
enum maxSize = max(staticMap!(size, Types));
writeln(maxSize);//8 byte
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Not much worse because we can reuse the standard library but we also had to create a new template to convert types into sizes. This is a general pattern in metaprogramming. If you want to do type level metaprogramming you have to use templates but wouldn&amp;rsquo;t it be nice if we could use ordinary functions?&lt;/p&gt;

&lt;p&gt;Instead of doing type computations with templates we will create &lt;code&gt;Type Objects&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-d&#34;&gt;import std.traits: isInstanceOf;
enum isType(T) = isInstanceOf!(Type, T);
struct Type(T){
    alias type = T;
    string toString()
    {
        return &amp;quot;Type!(&amp;quot;~T.stringof~&amp;quot;)&amp;quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-d&#34;&gt;enum t  = Type!(int)();
enum t1 = Type!(string)();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You may wonder why we do this. The answer is simple, we now can use &lt;code&gt;Types&lt;/code&gt; like ordinary objects. Let us create a simple &lt;code&gt;equals&lt;/code&gt; function that checks if two &lt;code&gt;Types&lt;/code&gt; are actually the same.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-d&#34;&gt;enum equals(A,B)(Type!A, Type!B){
    return is(A == B);
}
enum t  = Type!(int)();
enum t1 = Type!(string)();

writeln(t.equals(t1)); // false
writeln(equals(t, t1)); // false
writeln(equals(Type!int(), Type!int())); // true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Types itself are not that interesting, let us create a &lt;code&gt;TypeTuple&lt;/code&gt; that can hold any number of &lt;code&gt;Types&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-d&#34;&gt;enum isTypeTuple(T) = isInstanceOf!(TypeTuple, T);

struct TypeTuple(Types...){
    import std.meta: allSatisfy;
    static assert(allSatisfy!(isType, Types), &amp;quot;Variadic parameters need to be of type &#39;Type!&#39;&amp;quot;);
    Types expand;
    alias expand this;
    string toString()
    {
        import std.range;
        string[] s;
        foreach(t; expand){
            s~= t.toString();
        }
        return &amp;quot;TypeTuple!(&amp;quot; ~ s.join(&amp;quot;, &amp;quot;) ~&amp;quot;)&amp;quot;;
    }
}
enum typeTuple(Types...)(Types){
    return TypeTuple!Types();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;By the way you may wonder why we created a &lt;code&gt;toString&lt;/code&gt; method here. This is because &lt;code&gt;D&lt;/code&gt; sometimes doesn&amp;rsquo;t like to print types that were generated and it might not print the actual type and inserts some pseudo symbols like &lt;code&gt;F!int&lt;/code&gt; instead of &lt;code&gt;Type!int&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We can use &lt;code&gt;TypeTuple&lt;/code&gt; like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-d&#34;&gt;enum types = TypeTuple!(Type!int, Type!char, Type!float, Type!double)();
//or
enum types = typeTuple(Type!int, Type!char, Type!float, Type!double);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It is just a bit of boilerplate which we can easily avoid with a helper function&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-d&#34;&gt;enum tupleFromTypes(Ts...)(){
    import std.meta: staticMap;
    return TypeTuple!(staticMap!(Type, Ts))();
}
enum types = tupleFromTypes!(int,double, int,float);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we can start to implement some nice metafunctions. We start by implementing &lt;code&gt;filter&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-d&#34;&gt;enum filter(alias f, Tup)(Tup){
    static assert(isTypeTuple!(Tup), tup.stringof~&amp;quot; is not a TypeTuple.&amp;quot;);
    enum tup = Tup();
    static if(tup.length == 0){
        return typeTuple();
    }
    else static if(f(tup[0])){
        return typeTuple(tup[0], filter!(f)(typeTuple(tup[1..$])).expand);
    }
    else{
        return filter!(f)(typeTuple(tup[1..$]));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can now use it like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-d&#34;&gt;enum types = tupleFromTypes!(int, double, string, float);
enum biggerThan4 = filter!(t =&amp;gt; t.type.sizeof &amp;gt; 4)(types);
writeln(biggerThan4);// TypeTuple!(Type!(double), Type!(string))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The code above filters our &lt;code&gt;TypeTuple&lt;/code&gt; with an ordinary lambda function. The resulting &lt;code&gt;Types&lt;/code&gt; must be bigger than 4 bytes. We can also implement &lt;code&gt;map&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-d&#34;&gt;enum map(alias f, Tup)(Tup){
    static assert(isTypeTuple!(Tup), tup.stringof~&amp;quot; is not a TypeTuple.&amp;quot;);
    enum tup = Tup();
    static if(tup.length == 0){
        return typeTuple!();
    }
    else{
        return typeTuple(f(tup[0]), map!(f)(typeTuple(tup[1..$])).expand);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-d&#34;&gt;enum types = tupleFromTypes!(int, double, string, float);
enum onlyInts = map!(t =&amp;gt; Type!int())(types);
writeln(onlyInts);// TypeTuple!(Type!(int), Type!(int), Type!(int), Type!(int))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We replace every &lt;code&gt;Type&lt;/code&gt; with &lt;code&gt;Type!int&lt;/code&gt; which is probably not that useful. We could also replace only types that are actually bigger than 4 bytes with &lt;code&gt;Type!int&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-d&#34;&gt;enum types = tupleFromTypes!(int, double, string, float);
enum smallerThan5 = map!((t){
    static if(t.type.sizeof &amp;gt; 4){
        return Type!int();
    }
    else{
        return t;
    }
})(types);// TypeTuple!(Type!(int), Type!(int), Type!(int), Type!(float))
writeln(smallerThan5);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The possibilities are almost endless and you can use it like any other function. Just remember that it needs to be executed at compile time which means you have to use &lt;code&gt;static if&lt;/code&gt; instead of an ordinary &lt;code&gt;if&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-d&#34;&gt;enum indexOf(T,Tup)(T, Tup){
    static assert(isTypeTuple!(Tup), tup.stringof~&amp;quot; is not a TypeTuple.&amp;quot;);
    static assert(isType!(T), T.stringof~&amp;quot; is not a Type.&amp;quot;);
    enum t = T();
    enum tup = Tup();
    foreach(index, type; tup.expand){
        if(type.equals(t)){
            return index;
        }
    }
    return -1;
}
enum types = tupleFromTypes!(int, double, string, float);
enum index = indexOf(Type!string(), types);
writeln(index);// 2

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And last but not least, we can implement quicksort for types.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-d&#34;&gt;enum partition(alias f, Tup)(Tup){
    enum tup = Tup();
    return partitionImpl!(f)(tup, typeTuple(), typeTuple());
}

enum partitionImpl(alias f, Tup, TupLeft, TupRight)(Tup, TupLeft, TupRight){
    import std.typecons: tuple;
    enum tup = Tup();
    enum l = TupLeft();
    enum r = TupRight();

    static if(tup.length == 0){
        return tuple(l, r);
    }
    else{
        static if(f(tup[0])){
            return partitionImpl!(f)(typeTuple(tup[1..$]), typeTuple(tup[0], l.expand), typeTuple(r.expand));
        }
        else{
            return partitionImpl!(f)(typeTuple(tup[1..$]), typeTuple(l.expand), typeTuple(tup[0], r.expand));
        }

    }
}

enum sort(alias f,Tup)(Tup){
    enum tup = Tup();
    static if(tup.length == 0){
        return typeTuple();
    }
    else static if(tup.length == 1){
        return typeTuple(tup[0]);
    }
    else{
        enum middle= tup[0];
        enum t = partition!(t =&amp;gt; f(t, middle))(typeTuple(tup[1..$]));
        enum left = t[0];
        enum right = t[1];
        return typeTuple(left.expand, middle, right.expand);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I needed to create another helper function &lt;code&gt;partition&lt;/code&gt; which just splits a &lt;code&gt;TypeTuple&lt;/code&gt; into two &lt;code&gt;TypeTuples&lt;/code&gt; based on a predicate.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-d&#34;&gt;enum types = tupleFromTypes!(int, double, string, float);
enum sortedTypes = sort!((t1, t2) =&amp;gt; t1.type.sizeof &amp;gt; t2.type.sizeof)(types);
writeln(sortedTypes);// TypeTuple!(Type!(string), Type!(double), Type!(int), Type!(float))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now it is also trivial to get the maximum size&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-d&#34;&gt;enum types = tupleFromTypes!(int, double, string, float);
enum sortedTypes = sort!((t1, t2) =&amp;gt; t1.type.sizeof &amp;gt; t2.type.sizeof)(types);
enum maxSize = sortedTypes[0].sizeof;
writeln(maxSize);// 8 bytes
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Type Objects&lt;/code&gt; allow metaprogramming to look like normal functional programming just with types.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>The general design of my flawed compile time entity component system in C&#43;&#43;14</title>
      <link>https://maikklein.github.io/post/2016-01-14-Entity-Component-System/</link>
      <pubDate>Thu, 14 Jan 2016 11:27:27 -0400</pubDate>
      
      <guid>https://maikklein.github.io/post/2016-01-14-Entity-Component-System/</guid>
      <description>

&lt;p&gt;A lot of people are talking about entity component systems and how they could potentially improve your code base. Most of the articles are theoretical and it is hard to find examples that actually convey some advantages.&lt;/p&gt;

&lt;p&gt;There are actually a lot of entity component systems available for many different programming languages, but most seem to sacrifice performance for expressiveness.&lt;/p&gt;

&lt;p&gt;But I am curious and I really like the general idea of an entity component system but I don&amp;rsquo;t want to just accept the opinion of other game developers. It&amp;rsquo;s time to get some actual experience and I have implemented a very small entity component system in C++14 with template metaprogramming.&lt;/p&gt;

&lt;p&gt;This post will be about the general design of my entity component system.&lt;/p&gt;

&lt;h2 id=&#34;features:571954f8d33aced3458d08b62ec3636d&#34;&gt;Features&lt;/h2&gt;

&lt;p&gt;The core features of my entity component system are:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;Contiguous memory layout
Components are grouped at compile time
Compile time filtering of components
Components are always added in the correct group automatically
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;overview:571954f8d33aced3458d08b62ec3636d&#34;&gt;Overview&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct world{
  //component_group &#39;moveable_object&#39;
  std::vector&amp;lt;position&amp;gt; moveable_object_position;
  std::vector&amp;lt;velocity&amp;gt; moveable_object_velocity;

  //component_group &#39;entity&#39;
  std::vector&amp;lt;position&amp;gt; entity_position;
  std::vector&amp;lt;velocity&amp;gt; entity_velocity;
  std::vector&amp;lt;name&amp;gt; entity_name;
  ...
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is the core of the entity component system, we group components together at compile time. The layout is called &lt;code&gt;SoA&lt;/code&gt; (structures of arrays) and a specific object is referred to by id.&lt;/p&gt;

&lt;p&gt;For example instead of having&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct moveable_object{
  velocity vel;
  position pos;
};
std::vector&amp;lt;moveable_object&amp;gt; mv_objects;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;we have&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;std::vector&amp;lt;position&amp;gt; moveable_object_position;
std::vector&amp;lt;velocity&amp;gt; moveable_object_velocity;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And I refer to &lt;code&gt;moveable_object_position[index], moveable_object_velocity[index]&lt;/code&gt; as an object in this post.&lt;/p&gt;

&lt;p&gt;Each &lt;code&gt;component_group&lt;/code&gt; has a list of constrains, for example an &lt;code&gt;entity&lt;/code&gt; needs to have a &lt;code&gt;position&lt;/code&gt;, &lt;code&gt;velocity&lt;/code&gt; and &lt;code&gt;name&lt;/code&gt; component. The advantage of this approach is that filtering is essentially free, because we can just iterate over &lt;code&gt;entity_position&lt;/code&gt;,&lt;code&gt;entity_velocity&lt;/code&gt; and&lt;code&gt;entity_name&lt;/code&gt; at the same time. Another advantage is that we don&amp;rsquo;t have to worry about the memory layout as much, because we group everything at compile time.&lt;/p&gt;

&lt;p&gt;It is also possible to filter &lt;code&gt;component_groups&lt;/code&gt; based on the components they own. For example if we want to iterate over every &lt;code&gt;object&lt;/code&gt; that has a &lt;code&gt;position&lt;/code&gt; and &lt;code&gt;velocity&lt;/code&gt; component, we would have to iterate over &lt;code&gt;entity_position&lt;/code&gt;, &lt;code&gt;entity_velocity&lt;/code&gt; and &lt;code&gt;moveable_object_position&lt;/code&gt;, &lt;code&gt;moveable_object_velocity&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Obviously maintaining something like this by hand is extremely tedious. This is where metaprogramming will help us to convey our meaning. The following code snippet is a small example from my experimental entity component system.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct position {
  float x, y;
};
struct velocity {
  float x, y;
};
struct name {
  std::string name;
};

struct print_name {
  template &amp;lt;class World&amp;gt; void update(World&amp;amp; w) {
    w.template update&amp;lt;name&amp;gt;([](auto&amp;amp; name) { print(name.name); });
  }
};
struct print_pos_vel {
  template &amp;lt;class World&amp;gt; void update(World&amp;amp; w) {
    w.template update&amp;lt;position, velocity&amp;gt;([](auto&amp;amp; pos, auto&amp;amp; vel) {
      print(pos.x, pos.y);
      print(vel.x, vel.y);
    });
  }
};
auto make_monster(float x, float y, std::string n) {
  return hana::make_tuple(position{ x, y }, velocity{ 0, 0 }, name{ n });
}

template &amp;lt;class... Ts&amp;gt;
using component_group_handle = ecs::core::component_group&amp;lt;
    breeze::util::container::handle_container, Ts...&amp;gt;;

int main() {
  using moveable_object = component_group_handle&amp;lt;position, velocity&amp;gt;;
  using entity = component_group_handle&amp;lt;position, velocity, name&amp;gt;;
  using cg = ecs::core::component_groups&amp;lt;moveable_object, entity&amp;gt;;
  auto w = ecs::core::world&amp;lt;cg&amp;gt;{};
  auto sg = ecs::core::make_systems_group(w, print_name{}, print_pos_vel{});
  w.add(make_monster(10, 5, &amp;quot;Monster3&amp;quot;));
  w.add(make_monster(11, 5, &amp;quot;Monster2&amp;quot;));
  w.add(position{ 42, 24 }, velocity{ 5, 5 }, name{ &amp;quot;Monster1&amp;quot; });

  // moveable_object
  w.add(position{ 0, 0 }, velocity{ 10, 5 });
  sg.update();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Don&amp;rsquo;t worry if you don&amp;rsquo;t understand what is going on, I&amp;rsquo;ll try to explain everything you need to know in the following section.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct print_pos_vel {
  template &amp;lt;class World&amp;gt; void update(World&amp;amp; w) {
    w.template update&amp;lt;position, velocity&amp;gt;([](auto&amp;amp; pos, auto&amp;amp; vel) {
      print(pos.x, pos.y);
      print(vel.x, vel.y);
    });
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is a simple system, which filters out every &lt;code&gt;component_group&lt;/code&gt;that does not have a &lt;code&gt;position&lt;/code&gt; and &lt;code&gt;velocity&lt;/code&gt; component, it then extracts the correct components for every &lt;code&gt;component_group&lt;/code&gt; that we are interested in. We then zip the iterators for &lt;code&gt;position&lt;/code&gt; and &lt;code&gt;velocity&lt;/code&gt; together and we repeat this for every &lt;code&gt;component_group&lt;/code&gt; that satisfies the &lt;code&gt;position&lt;/code&gt; and &lt;code&gt;velocity&lt;/code&gt; constrain. We are then left with a tuple of zipped iterators which we
concatenate into one big iterator. After that we can iterate over every &lt;code&gt;position&lt;/code&gt; and &lt;code&gt;velocity&lt;/code&gt; component and print it to the console.&lt;/p&gt;

&lt;p&gt;The only thing that is done at runtime is accessing the iterator for every component and concatenate them.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;using moveable_object = component_group_handle&amp;lt;position, velocity&amp;gt;;
using entity = component_group_handle&amp;lt;position, velocity, name&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These are our &lt;code&gt;component_groups&lt;/code&gt; which we have to declare once. Technically those could be inferred but I decided that it would serve as a good way to document all the different &lt;code&gt;component_groups&lt;/code&gt; that are used by the entity component system.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;using cg = ecs::core::component_groups&amp;lt;moveable_object, entity&amp;gt;;
auto w = ecs::core::world&amp;lt;cg&amp;gt;{};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After declaring all the &lt;code&gt;component_group&lt;/code&gt;&amp;rsquo;s that we want to use, we can finally create our &lt;code&gt;world&lt;/code&gt; object.&lt;/p&gt;

&lt;p&gt;The world object itself doesn&amp;rsquo;t do much and its purpose is to store our data.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;auto sg = ecs::core::make_systems_group(w, print_name{}, print_pos_vel{});
...
sg.update();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A &lt;code&gt;system_group&lt;/code&gt; just groups different systems together and allows to call &lt;code&gt;update&lt;/code&gt; on every system that has been registered at compile-time.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// entity
w.add(position{ 42, 24 }, velocity{ 5, 5 }, name{ &amp;quot;Monster1&amp;quot; });

// moveable_object
w.add(position{ 0, 0 }, velocity{ 10, 5 });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Every &lt;code&gt;object&lt;/code&gt; is added into the correct &lt;code&gt;component_group&lt;/code&gt;. If you call add with &lt;code&gt;&amp;lt;position, velocity&amp;gt;&lt;/code&gt; it will look at all the &lt;code&gt;component_group&lt;/code&gt;&amp;rsquo;s and that were declared before and insert it into the correct one.
Because we have declared &lt;code&gt;using moveable_object = component_group_handle&amp;lt;position, velocity&amp;gt;;&lt;/code&gt;  the components &lt;code&gt;w.add(position{ 0, 0 }, velocity{ 10, 5 });&lt;/code&gt; will be inserted into the &lt;code&gt;component_group&lt;/code&gt; &lt;code&gt;moveable_object&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Deleting &lt;code&gt;objects&lt;/code&gt; is also very simple. Because we have grouped everything at compile-time, we just have to look at the &lt;code&gt;component_group&lt;/code&gt; that the object belongs to and delete it. To preserve contiguous elements we swap the last element with the element that we want to delete and then we simply remove the last element.&lt;/p&gt;

&lt;p&gt;Most entity component system allow to add and remove components from &lt;code&gt;objects&lt;/code&gt; at runtime. If we want to take a &lt;code&gt;moveable_object&lt;/code&gt; and add a &lt;code&gt;name&lt;/code&gt; component, it would become an &lt;code&gt;entity&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We would need to move the components from the &lt;code&gt;component_group&lt;/code&gt; &lt;code&gt;moveable_object&lt;/code&gt; to the &lt;code&gt;component_group&lt;/code&gt; &lt;code&gt;entity&lt;/code&gt; and add then simply add the &lt;code&gt;name&lt;/code&gt; component.&lt;/p&gt;

&lt;h2 id=&#34;dealbreaker:571954f8d33aced3458d08b62ec3636d&#34;&gt;Dealbreaker&lt;/h2&gt;

&lt;p&gt;The biggest problem is the compilation time. Every query of update &lt;code&gt;w.template update&amp;lt;T0,T1,...TN&amp;gt;&lt;/code&gt; costs around 2 seconds on my machine, that is just unacceptable.&lt;/p&gt;

&lt;p&gt;You can find the code &lt;a href=&#34;https://github.com/BreezeEngine/breeze/blob/master/src/ecs/core/core.hpp&#34;&gt;here&lt;/a&gt; and &lt;a href=&#34;https://github.com/BreezeEngine/breeze/blob/master/examples/ecs/main.cpp&#34;&gt;here&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Please note that the code is in a highly experimental state and will most likely not even compile on your machine.&lt;/p&gt;

&lt;h2 id=&#34;what-have-i-learned:571954f8d33aced3458d08b62ec3636d&#34;&gt;What have I learned?&lt;/h2&gt;

&lt;p&gt;I really love metaprogramming in C++ with &lt;a href=&#34;https://github.com/boostorg/hana&#34;&gt;hana&lt;/a&gt;. It is expressive, concise and doesn&amp;rsquo;t look odd if you are familiar with functional conecpts.&lt;/p&gt;

&lt;p&gt;Compile errors are horrifying and tools for compile-time debugging/profiling are pretty much non existent.&lt;/p&gt;

&lt;p&gt;Compile times can quickly blow up and it&amp;rsquo;s hard to track down where and why they are blowing up.&lt;/p&gt;

&lt;p&gt;I don&amp;rsquo;t think the entity component system that I envision is practical to create in C++ and I will most likely abandon it. I am not quite ready the abandon the idea and I will try to create a similar entity component system in &lt;code&gt;D&lt;/code&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Type safe OpenGL - Converting strings into types in D</title>
      <link>https://maikklein.github.io/post/2015-11-14-Converting-strings-to-types/</link>
      <pubDate>Sat, 14 Nov 2015 00:00:00 +0000</pubDate>
      
      <guid>https://maikklein.github.io/post/2015-11-14-Converting-strings-to-types/</guid>
      <description>&lt;p&gt;Writing glsl code is usually not that hard but it is easy to make mistakes, especially if you are changing some glsl files and forgetting to update the OpenGL calls.&lt;/p&gt;

&lt;p&gt;We will parse a glsl shader and extract the types as a string at compile time, then we use those strings to create actual types. After we have obtained the types we will generate a wrapper for that glsl shader at compile time.&lt;/p&gt;

&lt;p&gt;The benefit is that we will get a nice interface that won&amp;rsquo;t allow you to make any mistakes. Another benefit will be that if the glsl shader changes the wrapper will change too, which helps you to keep the code in sync by generating helpful compiler errors.&lt;/p&gt;

&lt;p&gt;In this blog post we will learn how we can turn strings into actual types at compile time.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-d&#34;&gt;...
in vec2 fragTexCoord;
in vec3 fragNormal;
in vec3 fragVert;
...
[&amp;quot;vec2&amp;quot;,&amp;quot;vec3&amp;quot;,&amp;quot;vec3&amp;quot;] to AliasSeq!(Vector2,Vector2,Vector3)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Converting strings to types is very easy in D&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-d&#34;&gt;template glslStringtoTypeV1(string stringType){
  static if(stringType == &amp;quot;int&amp;quot;){
    alias glslStringtoTypeV1 = int;
  }
  else static if(stringType == &amp;quot;float&amp;quot;){
    alias glslStringtoTypeV1 = float;
  }
}
void main()
{
  glslStringtoTypeV1!&amp;quot;float&amp;quot; f; //f is of type float
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But &lt;a href=&#34;https://www.opengl.org/registry/doc/GLSLangSpec.4.40.pdf&#34;&gt;glsl has actually quite a few types&lt;/a&gt; and it would be annoying to  write that many &lt;code&gt;static if&lt;/code&gt; blocks.&lt;/p&gt;

&lt;p&gt;D also has template specializations like C++, maybe this would make the code easier to write?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-d&#34;&gt;template glslStringtoTypeV2(string s){
  static assert(false, s ~ &amp;quot; is not a GLSL type&amp;quot;);
}
template glslStringtoTypeV2(string s: &amp;quot;int&amp;quot;){
  alias glslStringtoTypeV2 = int;
}
template glslStringtoTypeV2(string s: &amp;quot;float&amp;quot;){
  alias glslStringtoTypeV2 = float;
}
void main()
{
  glslStringtoTypeV2!&amp;quot;float&amp;quot; f; //f is of type float
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The nice thing about D is that we can pass almost any value into a template, in this case we use &lt;code&gt;string&lt;/code&gt;. I think the code already looks much easier to write and read but it still has a lot of noise. Maybe we can reduce the noise with &lt;code&gt;template mixins&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Template mixins&lt;/code&gt; allow you to expand a template with the &lt;code&gt;mixin&lt;/code&gt; keyword.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-d&#34;&gt;mixin template AddShader(T,string stringType){
  template glslStringtoTypeV2(string s: stringType){
    alias glslStringtoTypeV2 = T;
  }
}
template glslStringtoTypeV2(string s){
  static assert(false, s ~ &amp;quot; is not a GLSL type&amp;quot;);
}
mixin AddShader!(int,&amp;quot;int&amp;quot;);
mixin AddShader!(int,&amp;quot;float&amp;quot;);
void main()
{
  glslStringtoTypeV2!&amp;quot;float&amp;quot; f; //err
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This looks much better unfortunately this doesn&amp;rsquo;t compile because &lt;code&gt;template mixins&lt;/code&gt; expand into a different scope. D also allows us to insert strings at compile time with &lt;code&gt;mixins&lt;/code&gt;. You can think of them like macros from C but they are more powerful because they are ordinary strings which can be manipulated.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-d&#34;&gt;template AddShader(T,string stringType){
  enum AddShader = 
    &amp;quot;template glslStringtoTypeV2(string s: &amp;quot;~stringType.stringof~&amp;quot;){
         alias glslStringtoTypeV2 = &amp;quot; ~ T.stringof ~ &amp;quot;;&amp;quot; ~
    &amp;quot;}&amp;quot;;
}
template glslStringtoTypeV2(string s){
  static assert(false, s ~ &amp;quot; is not a GLSL type&amp;quot;);
}
mixin(AddShader!(int,&amp;quot;int&amp;quot;));
mixin(AddShader!(float,&amp;quot;float&amp;quot;));

void main()
{
  glslStringtoTypeV2!&amp;quot;float&amp;quot; f; //f is of type float
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is almost as nice as &lt;code&gt;template mixins&lt;/code&gt; but I am not the biggest fan of writing source code as a string. Maybe there is still some room for improvement.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-d&#34;&gt;struct ShaderType(T,string s){
  alias Type = T;
  enum string stringType = s;
}
enum isShaderType(T) = std.traits.isInstanceOf!(ShaderType,T);

template StringTypeGen(string stringType, ShaderTypes...)
  if(allSatisfy!(isShaderType, ShaderTypes)
     &amp;amp;&amp;amp; ShaderTypes.length &amp;gt; 0)
{
  static if(ShaderTypes[0].stringType == stringType ){
    alias StringTypeGen = ShaderTypes[0].Type;
  }
  else static if(ShaderTypes.length == 1){
    static assert(false,stringType ~ &amp;quot; is not a recognized type.&amp;quot;);
  }
  else{
    alias StringTypeGen = StringTypeGen!(stringType, ShaderTypes[1..$]);
  }
}
struct Matrix3{}
struct Vector3{}
alias glslStringToType(string s) = StringTypeGen!(s
    ,ShaderType!(int, &amp;quot;int&amp;quot;)
    ,ShaderType!(float, &amp;quot;float&amp;quot;)
    ,ShaderType!(double, &amp;quot;double&amp;quot;)
    ,ShaderType!(uint, &amp;quot;uint&amp;quot;)
    ,ShaderType!(bool, &amp;quot;bool&amp;quot;)
    ,ShaderType!(Matrix3, &amp;quot;mat3&amp;quot;)
    ,ShaderType!(Vector3, &amp;quot;vec3&amp;quot;)
    //....
);
void main()
{
  glslStringToType!&amp;quot;float&amp;quot; f; //f is of type float
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is the final version which was a bit more work to create but it&amp;rsquo;s easy to add glsl types, has nice error messages and is reusable. The last missing part is how we can turn a list of strings into a list of types.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-d&#34;&gt;void main()
{
  alias VertexInput = AliasSeq!(&amp;quot;mat3&amp;quot;,&amp;quot;int&amp;quot;,&amp;quot;vec3&amp;quot;,&amp;quot;double&amp;quot;);
  alias VertexInputTypes = staticMap!(glslStringToType,VertexInput);
  //VertexInputTypes is of type AliasSeq!(Matrix3,int,Vector3,double)
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>