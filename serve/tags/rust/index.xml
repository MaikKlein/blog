<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Rust on Blog</title>
    <link>https://maikklein.github.io/tags/rust/</link>
    <description>Recent content in Rust on Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sat, 05 Nov 2016 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://maikklein.github.io/tags/rust/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>My first steps with Future-rs</title>
      <link>https://maikklein.github.io/post/futures-rs/</link>
      <pubDate>Sat, 05 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>https://maikklein.github.io/post/futures-rs/</guid>
      <description>&lt;p&gt;A few months ago I have written a small task system, it looks like this.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;let res = TaskPool::submit(|| {
    println!(&amp;quot;Before long running task&amp;quot;);
    let r = TaskPool::submit(|| {
        std::thread::sleep(Duration::from_secs(10));
        return 42;
    });
    // Waits for the long running task to complete, does not block other tasks!
    println!(&amp;quot;After long running task {}&amp;quot;, r.await());
    42
});
println!(&amp;quot;{}&amp;quot;, res.await());
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;It is possible to spawn tasks inside tasks&lt;/li&gt;
&lt;li&gt;Calling &lt;code&gt;.await()&lt;/code&gt; on the main thread will block&lt;/li&gt;
&lt;li&gt;Calling &lt;code&gt;.await()&lt;/code&gt; inside the task pool will reschedule the task&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The task system was inspired by &lt;a href=&#34;http://www.gdcvault.com/play/1022186/Parallelizing-the-Naughty-Dog-Engine&#34;&gt;Naughty Dog&amp;rsquo;s Task system&lt;/a&gt; but since then &lt;code&gt;future-rs&lt;/code&gt; was released. Today I finally had time to test it out.&lt;/p&gt;

&lt;p&gt;Instead of spawning tasks inside tasks you create &lt;code&gt;futures&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;let some_future = futures::finished::&amp;lt;i32, ()&amp;gt;(42).map(|i| i + 42);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can think of them as a finite state machine.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;let pool = CpuPool::new(3);
let some_future = futures::finished::&amp;lt;i32, ()&amp;gt;(42).map(|i| i + 42);
let cpu_future = pool.spawn(some_future);
println!(&amp;quot;{}&amp;quot;, cpu_future.wait().unwrap());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The biggest difference here is that submitting and creating work is completely separated.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Futures&lt;/code&gt; can be composed together&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;fn future_test(id: i32) -&amp;gt; impl futures::Future&amp;lt;Item=i32, Error=()&amp;gt; {
    futures::finished::&amp;lt;i32, ()&amp;gt;(42)
        .map(move |i| {
            println!(&amp;quot;1st map id {}  {:?}&amp;quot;, id, thread_id::get());
            i + 1
        })
        .map(move |i| {
            println!(&amp;quot;2nd map id {}  {:?}&amp;quot;, id, thread_id::get());
            i + 2
        })
        .map(move |i| {
            println!(&amp;quot;3rd map id {}  {:?}&amp;quot;, id, thread_id::get());
            i + 3
        })
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Though you probably want to make use of &lt;code&gt;impl trait&lt;/code&gt; if you compose multiple futures together. Above I used the &lt;code&gt;thread-id&lt;/code&gt; crate to see on which thread the future will execute.&lt;/p&gt;

&lt;p&gt;I am currently writing a rendering engine in Vulkan and I need to record &lt;code&gt;CommandBuffers&lt;/code&gt; on different threads. This means I have to figure out how I actually submit futures onto different threads.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;let c: Vec&amp;lt;_&amp;gt; = (0 .. 10).map(|i| future_test(i)).collect();
let r = pool.spawn(futures::collect(c));
println!(&amp;quot;{:?}&amp;quot;, r.wait());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will print:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;1st map id 0  140444805625600
2nd map id 0  140444805625600
3rd map id 0  140444805625600
1st map id 1  140444805625600
2nd map id 1  140444805625600
3rd map id 1  140444805625600
1st map id 2  140444805625600
2nd map id 2  140444805625600
3rd map id 2  140444805625600
1st map id 3  140444805625600
2nd map id 3  140444805625600
3rd map id 3  140444805625600
1st map id 4  140444805625600
2nd map id 4  140444805625600
3rd map id 4  140444805625600
1st map id 5  140444805625600
2nd map id 5  140444805625600
3rd map id 5  140444805625600
1st map id 6  140444805625600
2nd map id 6  140444805625600
3rd map id 6  140444805625600
1st map id 7  140444805625600
2nd map id 7  140444805625600
3rd map id 7  140444805625600
1st map id 8  140444805625600
2nd map id 8  140444805625600
3rd map id 8  140444805625600
1st map id 9  140444805625600
2nd map id 9  140444805625600
3rd map id 9  140444805625600
Ok([48, 48, 48, 48, 48, 48, 48, 48, 48, 48])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You may notice that the thread id is always the same. This is because a &lt;code&gt;future&lt;/code&gt; will currently execute only on 1 thread. This is not what I wanted to achieve.&lt;/p&gt;

&lt;p&gt;If you want parallelism you should probably not submit one giant future but more smaller ones.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;let c: Vec&amp;lt;i32&amp;gt; =
    (0..10).map(|i| pool.spawn(future_test(i))).collect::&amp;lt;Vec&amp;lt;_&amp;gt;&amp;gt;().into_iter()
           .map(|f| f.wait().unwrap()).collect();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This code will print:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;1st map id 0  139959187011328
2nd map id 0  139959187011328
3rd map id 0  139959187011328
1st map id 1  139959184910080
2nd map id 1  139959184910080
3rd map id 1  139959184910080
1st map id 2  139959182808832
2nd map id 2  139959182808832
3rd map id 2  139959182808832
1st map id 3  139959187011328
2nd map id 3  139959187011328
3rd map id 3  139959187011328
1st map id 4  139959184910080
2nd map id 4  139959184910080
3rd map id 4  139959184910080
1st map id 5  139959182808832
2nd map id 5  139959182808832
3rd map id 5  139959182808832
1st map id 6  139959187011328
2nd map id 6  139959187011328
3rd map id 6  139959187011328
1st map id 7  139959184910080
2nd map id 7  139959184910080
3rd map id 7  139959184910080
1st map id 8  139959182808832
2nd map id 8  139959182808832
3rd map id 8  139959182808832
1st map id 9  139959187011328
2nd map id 9  139959187011328
3rd map id 9  139959187011328
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The code creates 10 &lt;code&gt;Futures&lt;/code&gt; from &lt;code&gt;future_test&lt;/code&gt; and immediately spawns them with &lt;code&gt;pool.spawn(future_test(i))&lt;/code&gt; which returns a &lt;code&gt;CpuFuture&lt;/code&gt;. It then waits sequentially on the result and writes its result into a vector.&lt;/p&gt;

&lt;p&gt;You might also notice that every &lt;code&gt;Future&lt;/code&gt; from &lt;code&gt;future_test&lt;/code&gt; will execute on the same thread.&lt;/p&gt;

&lt;p&gt;I haven&amp;rsquo;t spent too much time with &lt;code&gt;Future-rs&lt;/code&gt; but it looks very promising. The next thing I will look into is how I can safely share stack references inside &lt;code&gt;Futures&lt;/code&gt;. This was one part where I struggled with my &lt;code&gt;TaskPool&lt;/code&gt; implementation and I will probably run into the same issues with &lt;code&gt;Future-rs&lt;/code&gt; and &lt;code&gt;TaskPool&lt;/code&gt; because &lt;code&gt;spawn&lt;/code&gt; has &lt;code&gt;&#39;static&lt;/code&gt; lifetime requirements.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;fn spawn&amp;lt;F&amp;gt;(&amp;amp;self, f: F) -&amp;gt; CpuFuture&amp;lt;F::Item, F::Error&amp;gt;
where F: Future + Send + &#39;static, F::Item: Send + &#39;static, F::Error: Send + &#39;static
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/nikomatsakis/rayon&#34;&gt;Rayon&lt;/a&gt; does seem to offer this&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;/// Increment all values in slice.
fn increment_all(slice: &amp;amp;mut [i32]) {
    if slice.len() &amp;lt; 1000 {
        for p in slice { *p += 1; }
    } else {
        let mid_point = slice.len() / 2;
        let (left, right) = slice.split_at_mut(mid_point);
        rayon::join(|| increment_all(left), || increment_all(right));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Luckily &lt;code&gt;futures-cpupool&lt;/code&gt; is only a few 100 lines and therefore easy to make changes. I might have to remove the &lt;code&gt;Send&lt;/code&gt; requirement from &lt;code&gt;.spawn&lt;/code&gt; in order to have stack borrows. Mostly because it would be very bad if you create a future that has a borrow on the stack and you send it to a different thread. But it should be safe if it only gets send to the taskpool because you will get back another future which also doesn&amp;rsquo;t implement &lt;code&gt;Send&lt;/code&gt;. Then you could call &lt;code&gt;.wait()&lt;/code&gt; in the destructor but I see I
am already getting ahead of myself.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>My first steps with Future-rs</title>
      <link>https://maikklein.github.io/post/nom/</link>
      <pubDate>Sat, 05 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>https://maikklein.github.io/post/nom/</guid>
      <description>&lt;p&gt;A few months ago I have written a small task system, it looks like this.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;let res = TaskPool::submit(|| {
    println!(&amp;quot;Before long running task&amp;quot;);
    let r = TaskPool::submit(|| {
        std::thread::sleep(Duration::from_secs(10));
        return 42;
    });
    // Waits for the long running task to complete, does not block other tasks!
    println!(&amp;quot;After long running task {}&amp;quot;, r.await());
    42
});
println!(&amp;quot;{}&amp;quot;, res.await());
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;It is possible to spawn tasks inside tasks&lt;/li&gt;
&lt;li&gt;Calling &lt;code&gt;.await()&lt;/code&gt; on the main thread will block&lt;/li&gt;
&lt;li&gt;Calling &lt;code&gt;.await()&lt;/code&gt; inside the task pool will reschedule the task&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The task system was inspired by &lt;a href=&#34;http://www.gdcvault.com/play/1022186/Parallelizing-the-Naughty-Dog-Engine&#34;&gt;Naughty Dog&amp;rsquo;s Task system&lt;/a&gt; but since then &lt;code&gt;future-rs&lt;/code&gt; was released. Today I finally had time to test it out.&lt;/p&gt;

&lt;p&gt;Instead of spawning tasks inside tasks you create &lt;code&gt;futures&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;let some_future = futures::finished::&amp;lt;i32, ()&amp;gt;(42).map(|i| i + 42);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can think of them as a finite state machine.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;let pool = CpuPool::new(3);
let some_future = futures::finished::&amp;lt;i32, ()&amp;gt;(42).map(|i| i + 42);
let cpu_future = pool.spawn(some_future);
println!(&amp;quot;{}&amp;quot;, cpu_future.wait().unwrap());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The biggest difference here is that submitting and creating work is completely separated.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Futures&lt;/code&gt; can be composed together&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;fn future_test(id: i32) -&amp;gt; impl futures::Future&amp;lt;Item=i32, Error=()&amp;gt; {
    futures::finished::&amp;lt;i32, ()&amp;gt;(42)
        .map(move |i| {
            println!(&amp;quot;1st map id {}  {:?}&amp;quot;, id, thread_id::get());
            i + 1
        })
        .map(move |i| {
            println!(&amp;quot;2nd map id {}  {:?}&amp;quot;, id, thread_id::get());
            i + 2
        })
        .map(move |i| {
            println!(&amp;quot;3rd map id {}  {:?}&amp;quot;, id, thread_id::get());
            i + 3
        })
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Though you probably want to make use of &lt;code&gt;impl trait&lt;/code&gt; if you compose multiple futures together. Above I used the &lt;code&gt;thread-id&lt;/code&gt; crate to see on which thread the future will execute.&lt;/p&gt;

&lt;p&gt;I am currently writing a rendering engine in Vulkan and I need to record &lt;code&gt;CommandBuffers&lt;/code&gt; on different threads. This means I have to figure out how I actually submit futures onto different threads.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;let c: Vec&amp;lt;_&amp;gt; = (0 .. 10).map(|i| future_test(i)).collect();
let r = pool.spawn(futures::collect(c));
println!(&amp;quot;{:?}&amp;quot;, r.wait());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will print:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;1st map id 0  140444805625600
2nd map id 0  140444805625600
3rd map id 0  140444805625600
1st map id 1  140444805625600
2nd map id 1  140444805625600
3rd map id 1  140444805625600
1st map id 2  140444805625600
2nd map id 2  140444805625600
3rd map id 2  140444805625600
1st map id 3  140444805625600
2nd map id 3  140444805625600
3rd map id 3  140444805625600
1st map id 4  140444805625600
2nd map id 4  140444805625600
3rd map id 4  140444805625600
1st map id 5  140444805625600
2nd map id 5  140444805625600
3rd map id 5  140444805625600
1st map id 6  140444805625600
2nd map id 6  140444805625600
3rd map id 6  140444805625600
1st map id 7  140444805625600
2nd map id 7  140444805625600
3rd map id 7  140444805625600
1st map id 8  140444805625600
2nd map id 8  140444805625600
3rd map id 8  140444805625600
1st map id 9  140444805625600
2nd map id 9  140444805625600
3rd map id 9  140444805625600
Ok([48, 48, 48, 48, 48, 48, 48, 48, 48, 48])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You may notice that the thread id is always the same. This is because a &lt;code&gt;future&lt;/code&gt; will currently execute only on 1 thread. This is not what I wanted to achieve.&lt;/p&gt;

&lt;p&gt;If you want parallelism you should probably not submit one giant future but more smaller ones.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;let c: Vec&amp;lt;i32&amp;gt; =
    (0..10).map(|i| pool.spawn(future_test(i))).collect::&amp;lt;Vec&amp;lt;_&amp;gt;&amp;gt;().into_iter()
           .map(|f| f.wait().unwrap()).collect();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This code will print:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;1st map id 0  139959187011328
2nd map id 0  139959187011328
3rd map id 0  139959187011328
1st map id 1  139959184910080
2nd map id 1  139959184910080
3rd map id 1  139959184910080
1st map id 2  139959182808832
2nd map id 2  139959182808832
3rd map id 2  139959182808832
1st map id 3  139959187011328
2nd map id 3  139959187011328
3rd map id 3  139959187011328
1st map id 4  139959184910080
2nd map id 4  139959184910080
3rd map id 4  139959184910080
1st map id 5  139959182808832
2nd map id 5  139959182808832
3rd map id 5  139959182808832
1st map id 6  139959187011328
2nd map id 6  139959187011328
3rd map id 6  139959187011328
1st map id 7  139959184910080
2nd map id 7  139959184910080
3rd map id 7  139959184910080
1st map id 8  139959182808832
2nd map id 8  139959182808832
3rd map id 8  139959182808832
1st map id 9  139959187011328
2nd map id 9  139959187011328
3rd map id 9  139959187011328
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The code creates 10 &lt;code&gt;Futures&lt;/code&gt; from &lt;code&gt;future_test&lt;/code&gt; and immediately spawns them with &lt;code&gt;pool.spawn(future_test(i))&lt;/code&gt; which returns a &lt;code&gt;CpuFuture&lt;/code&gt;. It then waits sequentially on the result and writes its result into a vector.&lt;/p&gt;

&lt;p&gt;You might also notice that every &lt;code&gt;Future&lt;/code&gt; from &lt;code&gt;future_test&lt;/code&gt; will execute on the same thread.&lt;/p&gt;

&lt;p&gt;I haven&amp;rsquo;t spent too much time with &lt;code&gt;Future-rs&lt;/code&gt; but it looks very promising. The next thing I will look into is how I can safely share stack references inside &lt;code&gt;Futures&lt;/code&gt;. This was one part where I struggled with my &lt;code&gt;TaskPool&lt;/code&gt; implementation and I will probably run into the same issues with &lt;code&gt;Future-rs&lt;/code&gt; and &lt;code&gt;TaskPool&lt;/code&gt; because &lt;code&gt;spawn&lt;/code&gt; has &lt;code&gt;&#39;static&lt;/code&gt; lifetime requirements.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;fn spawn&amp;lt;F&amp;gt;(&amp;amp;self, f: F) -&amp;gt; CpuFuture&amp;lt;F::Item, F::Error&amp;gt;
where F: Future + Send + &#39;static, F::Item: Send + &#39;static, F::Error: Send + &#39;static
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/nikomatsakis/rayon&#34;&gt;Rayon&lt;/a&gt; does seem to offer this&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;/// Increment all values in slice.
fn increment_all(slice: &amp;amp;mut [i32]) {
    if slice.len() &amp;lt; 1000 {
        for p in slice { *p += 1; }
    } else {
        let mid_point = slice.len() / 2;
        let (left, right) = slice.split_at_mut(mid_point);
        rayon::join(|| increment_all(left), || increment_all(right));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Luckily &lt;code&gt;futures-cpupool&lt;/code&gt; is only a few 100 lines and therefore easy to make changes. I might have to remove the &lt;code&gt;Send&lt;/code&gt; requirement from &lt;code&gt;.spawn&lt;/code&gt; in order to have stack borrows. Mostly because it would be very bad if you create a future that has a borrow on the stack and you send it to a different thread. But it should be safe if it only gets send to the taskpool because you will get back another future which also doesn&amp;rsquo;t implement &lt;code&gt;Send&lt;/code&gt;. Then you could call &lt;code&gt;.wait()&lt;/code&gt; in the destructor but I see I
am already getting ahead of myself.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Comparison between Rust and D</title>
      <link>https://maikklein.github.io/post/cmp-rust-d/</link>
      <pubDate>Thu, 23 Jun 2016 00:00:00 +0000</pubDate>
      
      <guid>https://maikklein.github.io/post/cmp-rust-d/</guid>
      <description>

&lt;h1 id=&#34;comparison-between-rust-and-d:a33c6a773242a076961a1afafbd9aef7&#34;&gt;Comparison between Rust and D&lt;/h1&gt;

&lt;p&gt;I will try to compare &lt;code&gt;Rust&lt;/code&gt; and &lt;code&gt;D&lt;/code&gt; as objectively as possible. I will mostly focus the language parts that can actually be compared.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Rust currently is at version 1.9 and D is at version 2.071.0.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;move-and-copy-semantics:a33c6a773242a076961a1afafbd9aef7&#34;&gt;Move and copy semantics&lt;/h3&gt;

&lt;p&gt;Rust moves by default or copies if the &lt;code&gt;Copy&lt;/code&gt; trait is implemented.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;fn test(v: Vec&amp;lt;i32&amp;gt;){
}
fn main() {
    let v = vec![1, 2, 3];
    test(v); // v has moved into test
    // v can not be used
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Explicit &lt;code&gt;copies&lt;/code&gt; are done in Rust with the &lt;code&gt;Clone&lt;/code&gt; trait.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;fn test(v: Vec&amp;lt;i32&amp;gt;){
}
fn main() {
    let v = vec![1, 2, 3];
    test(v.clone()); // the cloned vec has moved into test
    // v can still be used here
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;D does a shallow copy by default&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-D&#34;&gt;import std.container: Array;

void test(Array!int arr){
    arr.insert(4);
}
void main()
{
    auto arr = Array!int(1, 2, 3);
    test(arr); // only does a shallow copy
    // Array contains now elements 1, 2, 3, 4
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Explicit copying has to be implemented manually. &lt;code&gt;Array&lt;/code&gt; exposes a &lt;code&gt;dup&lt;/code&gt; method that can be used to duplicate an array.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-D&#34;&gt;import std.container: Array;

void test(Array!int arr){
    arr.insert(4);
}
void main()
{
    auto arr = Array!int(1, 2, 3);
    test(arr.dup);
    //arr still has 3 elements
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Moves have to be done explicitly with &lt;code&gt;move&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-D&#34;&gt;import std.container: Array;
import std.algorithm.mutation: move;

void test(Array!int arr){
    arr.insert(4);
}
void main()
{
    auto arr = Array!int(1, 2, 3);
    test(arr.move);
    // arr can still be used but is empty
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Moved values in D can still be used because they are reset to their default state.&lt;/p&gt;

&lt;p&gt;It is also possible to reject lvalues for specific functions.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-D&#34;&gt;import std.container: Array;
import std.algorithm.mutation: move;

@disable void test(ref Array!int arr);
void test(Array!int arr){
    arr.insert(4);
}
void main()
{
    auto arr = Array!int(1, 2, 3);
    // test(arr); does not accept an lvalue
    test(arr.move); // still works
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;mutability:a33c6a773242a076961a1afafbd9aef7&#34;&gt;Mutability&lt;/h3&gt;

&lt;p&gt;Types in Rust are immutable by default.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;fn main() {
    let v = vec![1, 2, 3];
    //v.push(1); // does not work
    let mut v1 = vec![1, 2, 3];
    v1.push(1);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;D requires the &lt;code&gt;immutable&lt;/code&gt; keyword.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-D&#34;&gt;void main()
{
    immutable i = 42;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;D does not allow interior mutability as far as I know, which means it is not possible to create an immutable &lt;code&gt;Array&lt;/code&gt;. Interior mutability in Rust can be implemented with &lt;a href=&#34;https://doc.rust-lang.org/std/cell/&#34;&gt;Cell&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;D has another keyword &lt;code&gt;const&lt;/code&gt; to restrict exterior mutability.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void main()
{
   const arr = Array!int(1, 2, 3);
   //arr.insert(1); does not compile
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;From the &lt;a href=&#34;https://dlang.org/spec/const3.html#const_and_immutable&#34;&gt;D spec&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;immutable applies to data that cannot change. Immutable data values, once constructed, remain the same for the duration of the program&amp;rsquo;s execution. Immutable data can be placed in ROM (Read Only Memory) or in memory pages marked by the hardware as read only. Since immutable data does not change, it enables many opportunities for program optimization, and has applications in functional style programming.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!-- --&gt;

&lt;blockquote&gt;
&lt;p&gt;const applies to data that cannot be changed by the const reference to that data. It may, however, be changed by another reference to that same data. Const finds applications in passing data through interfaces that promise not to modify them.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!-- --&gt;

&lt;blockquote&gt;
&lt;p&gt;Both immutable and const are transitive, which means that any data reachable through an immutable reference is also immutable, and likewise for const.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;struct-initialization:a33c6a773242a076961a1afafbd9aef7&#34;&gt;Struct initialization&lt;/h3&gt;

&lt;p&gt;D as well as Rust can field initialize structs.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-D&#34;&gt;struct Foo{
     int i;
}

void main()
{
    Foo f = {i: 42};
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;struct Foo{
    i: i32
}
fn main() {
    let f = Foo{i: 42};
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;D also has constructors&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct Foo{
     int i;
     this(int _i){
         i = _i;
     }
}

void main()
{
    auto f = Foo(42);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;while Rust uses functions to do object construction.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct Foo{
    i: i32
}
impl Foo{
    fn new(i: i32) -&amp;gt; Foo{
        Foo{i: i}
    }
}
fn main() {
    let f = Foo::new(42);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;methods-and-ufcs:a33c6a773242a076961a1afafbd9aef7&#34;&gt;Methods and UFCS&lt;/h3&gt;

&lt;p&gt;Methods in D are implement inside the type.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct Foo{
     int i;
     this(int _i){
         i = _i;
     }

     void print(){
         import std.stdio: writeln;
         writeln(&amp;quot;Foo &amp;quot;, i);
     }
}

void main()
{
    auto f = Foo(42);
    f.print();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Rust implements methods outside of the type and inside a &lt;code&gt;impl&lt;/code&gt; block.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct Foo{
    i: i32
}
impl Foo{
    fn new(i: i32) -&amp;gt; Foo{
        Foo{i: i}
    }
    fn print(&amp;amp;self){
        println!(&amp;quot;Foo {}&amp;quot;, self.i);
    }
}
fn main() {
    let f = Foo::new(42);
    f.print();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Also Rust doesn&amp;rsquo;t implicitly capture &lt;code&gt;this / self&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Universal function call syntax allows to call print In Rust like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fn main() {
    let f = Foo::new(42);
    Foo::print(&amp;amp;f);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In D functions can be called like methods&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct Foo{
     int i;
     this(int _i){
         i = _i;
     }
}

void print(ref Foo f){
    import std.stdio: writeln;
    writeln(&amp;quot;Foo &amp;quot;, f.i);
}

void main()
{
    auto f = Foo(42);
    // both works
    f.print();
    print(f);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The advantage of &lt;code&gt;impl&lt;/code&gt; blocks is that they reduce verbosity for constrains.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;impl&amp;lt;T&amp;gt; Bar&amp;lt;T&amp;gt;
    where: T: Copy
{
    fn something(&amp;amp;self, val: T) -&amp;gt; T{...}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It is also possible to have multiple &lt;code&gt;impl&lt;/code&gt; for different constrains. As far as I know this is not possible in D, every function needs its own constrains.&lt;/p&gt;

&lt;p&gt;A small advantage of D is that it is possible to call those functions directly, like normal functions.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;auto zippedRange = zip(r1, r2);
auto zippedRange = r1.zip(r2);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;While in Rust this will be a bit more explicit.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let iter = Iterator::zip(iter1, iter2);
//or
let iter = iter1.zip(iter2);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;compile-times:a33c6a773242a076961a1afafbd9aef7&#34;&gt;Compile times&lt;/h3&gt;

&lt;p&gt;Subjectively Rust compiles slower than D, but it is really hard to get some objective data. I will post the results of compiling racer, rustfmt, DCD and dfmt. I am aware that those numbers are not really representable but it is the best that I can do.&lt;/p&gt;

&lt;p&gt;Also note that those a full release builds and not incremental debug builds.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;➜  bin time cargo install rustfmt
    Updating registry `https://github.com/rust-lang/crates.io-index`
   Compiling winapi v0.2.7
   Compiling rustc-serialize v0.3.19
   Compiling bitflags v0.5.0
   Compiling utf8-ranges v0.1.3
   Compiling log v0.3.6
   Compiling getopts v0.2.14
   Compiling unicode-segmentation v0.1.2
   Compiling strings v0.0.1
   Compiling regex-syntax v0.3.3
   Compiling winapi-build v0.1.1
   Compiling unicode-xid v0.0.3
   Compiling kernel32-sys v0.2.2
   Compiling diff v0.1.9
   Compiling term v0.4.4
   Compiling term v0.2.14
   Compiling libc v0.2.12
   Compiling memchr v0.1.11
   Compiling aho-corasick v0.5.2
   Compiling thread-id v2.0.0
   Compiling thread_local v0.2.6
   Compiling regex v0.1.71
   Compiling syntex_syntax v0.32.0
   Compiling toml v0.1.30
   Compiling env_logger v0.3.3
   Compiling rustfmt v0.5.0
  Installing /home/maik/.cargo/bin/rustfmt
  Installing /home/maik/.cargo/bin/cargo-fmt
cargo install rustfmt  382.58s user 1.49s system 130% cpu 4:54.72 total
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;➜  bin time cargo install racer
    Updating registry `https://github.com/rust-lang/crates.io-index`
   Compiling unicode-xid v0.0.3
   Compiling ansi_term v0.7.4
   Compiling libc v0.2.12
   Compiling unicode-width v0.1.3
   Compiling rustc-serialize v0.3.19
   Compiling regex-syntax v0.3.3
   Compiling winapi-build v0.1.1
   Compiling winapi v0.2.7
   Compiling kernel32-sys v0.2.2
   Compiling strsim v0.4.1
   Compiling term v0.2.14
   Compiling thread-id v2.0.0
   Compiling typed-arena v1.1.0
   Compiling utf8-ranges v0.1.3
   Compiling bitflags v0.5.0
   Compiling vec_map v0.6.0
   Compiling clap v2.2.6
   Compiling log v0.3.6
   Compiling memchr v0.1.11
   Compiling aho-corasick v0.5.2
   Compiling thread_local v0.2.6
   Compiling regex v0.1.71
   Compiling toml v0.1.30
   Compiling syntex_syntax v0.32.0
   Compiling env_logger v0.3.3
   Compiling racer v1.2.10
  Installing /home/maik/.cargo/bin/racer
cargo install racer  495.08s user 2.05s system 143% cpu 5:47.45 total
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;➜  DCD git:(master) time make -j4
find: ‘containers/experimental_allocator/src/std/experimental/allocator/’: No such file or directory
git log -1 --format=&amp;quot;%H&amp;quot; &amp;gt; githash.txt
mkdir -p bin
mkdir -p bin
dmd src/common/constants.d src/common/socket.d src/common/dcd_version.d src/common/messages.d src/server/autocomplete.d src/server/server.d dsymbol/src/dsymbol/import_.d dsymbol/src/dsymbol/symbol.d dsymbol/src/dsymbol/cache_entry.d dsymbol/src/dsymbol/string_interning.d dsymbol/src/dsymbol/semantic.d dsymbol/src/dsymbol/builtin/symbols.d dsymbol/src/dsymbol/builtin/names.d dsymbol/src/dsymbol/deferred.d dsymbol/src/dsymbol/modulecache.d dsymbol/src/dsymbol/scope_.d dsymbol/src/dsymbol/type_lookup.d dsymbol/src/dsymbol/conversion/first.d dsymbol/src/dsymbol/conversion/package.d dsymbol/src/dsymbol/conversion/second.d libdparse/src/dparse/ast.d libdparse/src/dparse/entities.d libdparse/src/dparse/lexer.d libdparse/src/dparse/parser.d libdparse/src/dparse/formatter.d libdparse/src/dparse/rollback_allocator.d libdparse/src/dparse/stack_buffer.d libdparse/src/std/experimental/lexer.d  containers/src/containers/dynamicarray.d containers/src/containers/ttree.d containers/src/containers/unrolledlist.d containers/src/containers/openhashset.d containers/src/containers/hashset.d containers/src/containers/internal/hash.d containers/src/containers/internal/node.d containers/src/containers/internal/storage_type.d containers/src/containers/internal/element_type.d containers/src/containers/internal/backwards.d containers/src/containers/slist.d msgpack-d/src/msgpack/exception.d msgpack-d/src/msgpack/attribute.d msgpack-d/src/msgpack/package.d msgpack-d/src/msgpack/register.d msgpack-d/src/msgpack/streaming_unpacker.d msgpack-d/src/msgpack/buffer.d msgpack-d/src/msgpack/common.d msgpack-d/src/msgpack/value.d msgpack-d/src/msgpack/unpacker.d msgpack-d/src/msgpack/packer.d -Icontainers/src -Imsgpack-d/src -Ilibdparse/src -Idsymbol/src -Icontainers/experimental_allocator/src -J. -wi -O -release -inline -ofbin/dcd-server
dmd src/common/constants.d src/common/socket.d src/common/dcd_version.d src/common/messages.d src/client/client.d msgpack-d/src/msgpack/exception.d msgpack-d/src/msgpack/attribute.d msgpack-d/src/msgpack/package.d msgpack-d/src/msgpack/register.d msgpack-d/src/msgpack/streaming_unpacker.d msgpack-d/src/msgpack/buffer.d msgpack-d/src/msgpack/common.d msgpack-d/src/msgpack/value.d msgpack-d/src/msgpack/unpacker.d msgpack-d/src/msgpack/packer.d -Imsgpack-d/src -Imsgpack-d/src -Icontainers/experimental_allocator/src -J. -inline -O -wi -ofbin/dcd-client
make -j4  42.62s user 2.44s system 104% cpu 43.173 total
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;➜  dfmt git:(master) ✗ time dub build -f -b release
Performing &amp;quot;release&amp;quot; build using dmd for x86_64.
experimental_allocator 2.70.0-b1: building configuration &amp;quot;library&amp;quot;...
libdparse 0.7.0-alpha9: building configuration &amp;quot;library&amp;quot;...
dfmt 0.5.0-beta3+commit.25.ge3bf269: building configuration &amp;quot;application&amp;quot;...
Linking...
dub build -f -b release  40.78s user 0.56s system 99% cpu 41.360 total
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;dynamic-static-dispatch-constrains-and-extending-functionality:a33c6a773242a076961a1afafbd9aef7&#34;&gt;Dynamic / static dispatch, constrains and extending functionality&lt;/h3&gt;

&lt;p&gt;In Rust it is possible to extend a type using traits.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct Foo {
    i: i32,
}

impl Foo {
    fn new(i: i32) -&amp;gt; Foo {
        Foo { i: i }
    }
}

trait Print {
    fn print(&amp;amp;self);
}

impl Print for Foo {
    fn print(&amp;amp;self) {
        println!(&amp;quot;Foo {}&amp;quot;, self.i);
    }
}

impl Print for i32 {
    fn print(&amp;amp;self) {
        println!(&amp;quot;i32 {}&amp;quot;, self);
    }
}

fn main() {
    let f = Foo::new(42);
    f.print();
    Print::print(&amp;amp;f);

    42.print();
    Print::print(&amp;amp;42);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The same thing is possible in D with overloaded functions.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct Foo{
     int i;
     this(int _i){
         i = _i;
     }
}

void print(ref Foo f){
    import std.stdio: writeln;
    writeln(&amp;quot;Foo &amp;quot;, f.i);
}

void print(int i){
    import std.stdio: writeln;
    writeln(&amp;quot;int &amp;quot;, i);
}

void main()
{
    auto f = Foo(42);
    f.print();
    print(f);

    42.print();
    print(42);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The advantage of traits is that you can use them to constrain types at compile and they allow dynamic dispatch&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fn call_print_static&amp;lt;T: Print&amp;gt;(t: &amp;amp;T){
    t.print();
}

fn call_print_dynamic(p: &amp;amp;Print){
    p.print();
}

fn main() {
    let f = Foo::new(42);
    call_print_static(&amp;amp;f);
    call_print_static(&amp;amp;42);

    call_print_dynamic(&amp;amp;f as &amp;amp;Print);
    call_print_dynamic(&amp;amp;42 as &amp;amp;Print);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This can roughly be expressed in D like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;interface Print{
    void print();
}

class Foo: Print{
     int i;
     this(int _i){
         i = _i;
     }
     void print(){
         import std.stdio: writeln;
         writeln(&amp;quot;Foo &amp;quot;, i);
     }
}

void call_print_dynamic(Print p){
    p.print();
}

void call_print_static(T)(T t){
    t.print();
}

void main()
{
    //f is a pointer
    auto f = new Foo(42);
    call_print_dynamic(f);
    call_print_static(f);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Dynamic dispatch with interfaces can only really be used with classes. Classes are by default references types which means if there is a type &lt;code&gt;Foo&lt;/code&gt; it implicitly is type &lt;code&gt;Foo*&lt;/code&gt;. While it is possible allocate classes on the heap / stack or some memory region, they inherently have an indirection.&lt;/p&gt;

&lt;p&gt;Also &lt;code&gt;call_print_static&lt;/code&gt; is duck typed, which means that the function expects every &lt;code&gt;T&lt;/code&gt; to be callable with &lt;code&gt;.print&lt;/code&gt;. This can easily result in ugly error messages.&lt;/p&gt;

&lt;p&gt;D doesn&amp;rsquo;t really have a way to automatically constrain types like Rust.&lt;/p&gt;

&lt;p&gt;Duck typing still has a few advantages. It is easy get something working, because you don&amp;rsquo;t have to specify every constrain in advance. It is also possible to generate some very specific error messages.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void call_print_static(T)(T t){
    static assert(!is(T == class), T.stringof ~ &amp;quot; is a class and can not be used.&amp;quot;);
    t.print();
}

void main()
{
    //f is a pointer
    auto f = new Foo(42);
    call_print_dynamic(f);
    call_print_static(f); // error
}
/*
source/app.d(21,5): Error: static assert  &amp;quot;Foo is a class and can not be used.&amp;quot;
source/app.d(30,22):        instantiated from here: call_print_static!(Foo)
*/
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;type-inference:a33c6a773242a076961a1afafbd9aef7&#34;&gt;Type inference&lt;/h3&gt;

&lt;p&gt;In Rust it is possible to write:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;fn test() -&amp;gt; Result&amp;lt;i32, String&amp;gt; {
    Ok(42)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This works because Rust knows that the return type is &lt;code&gt;Result&amp;lt;i32, String&amp;gt;&lt;/code&gt; and that &lt;code&gt;Ok&amp;lt;i32&amp;gt;&lt;/code&gt; is part of it. You can not write this in D as far as I know.&lt;/p&gt;

&lt;p&gt;The D approach could look like this&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-D&#34;&gt;alias SomeResult = Result!(int, string);
SomeResult test(){
    return SomeResult.ok(42);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;explicit-implicit-conversion-coercions:a33c6a773242a076961a1afafbd9aef7&#34;&gt;Explicit implicit conversion/coercions&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;use std::ops::Deref;

struct Wrapper&amp;lt;T&amp;gt; {
    value: T,
}

impl&amp;lt;T&amp;gt; Wrapper&amp;lt;T&amp;gt;{
    fn new(val: T) -&amp;gt; Wrapper&amp;lt;T&amp;gt; {
        Wrapper{value: val}
    }
}

impl&amp;lt;T&amp;gt; Deref for Wrapper&amp;lt;T&amp;gt; {
    type Target = T;
    fn deref(&amp;amp;self) -&amp;gt; &amp;amp;T{
        &amp;amp;self.value
    }
}

struct Foo {
    i: i32,
}

impl Foo {
    fn new(i: i32) -&amp;gt; Foo {
        Foo { i: i }
    }
}

trait Print {
    fn print(&amp;amp;self);
}

impl Print for Foo {
    fn print(&amp;amp;self) {
        println!(&amp;quot;Foo {}&amp;quot;, self.i);
    }
}

fn main() {
    let f = Wrapper::new(Foo::new(42));
    f.print();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Here’s the rule: If you have a type U, and it implements Deref&lt;Target=T&gt;, values of &amp;amp;U will automatically coerce to a &amp;amp;T &lt;a href=&#34;https://doc.rust-lang.org/book/deref-coercions.html&#34;&gt;quote&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This is also the reason that you can pass a &lt;code&gt;String&lt;/code&gt; into a function that expects a &lt;code&gt;&amp;amp;str&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-D&#34;&gt;struct Wrapper(T){
    T value;
    this(T _value){
        value = _value;
    }
    alias value this;
}

interface Print{
    void print();
}

class Foo: Print{
     int i;
     this(int _i){
         i = _i;
     }
     void print(){
         import std.stdio: writeln;
         writeln(&amp;quot;Foo &amp;quot;, i);
     }
}

void main()
{
    //f is a pointer
    auto f = Wrapper!Foo(new Foo(42));
    f.print();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In D calling &lt;code&gt;f.print()&lt;/code&gt; is then the same thing as &lt;code&gt;f.value.print()&lt;/code&gt;. This means &lt;code&gt;Wrapper&amp;lt;T&amp;gt;&lt;/code&gt; can be passed to anything that expects a &lt;code&gt;T&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://dlang.org/phobos/std_typecons.html#.Proxy&#34;&gt;Proxy&lt;/a&gt; can be used to forbid the conversions and only forward the methods to the new type.&lt;/p&gt;

&lt;h3 id=&#34;unused-generics:a33c6a773242a076961a1afafbd9aef7&#34;&gt;Unused generics&lt;/h3&gt;

&lt;p&gt;In D it is perfectly legal to create types with unused generics:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-D&#34;&gt;struct Foo(A, B){}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Rust doesn&amp;rsquo;t allow this by default and requires phantom data.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;use std::marker::PhantomData;
struct Foo&amp;lt;A, B&amp;gt;{
    _m_a: PhantomData&amp;lt;A&amp;gt;,
    _m_b: PhantomData&amp;lt;B&amp;gt;,
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;variadics:a33c6a773242a076961a1afafbd9aef7&#34;&gt;Variadics&lt;/h3&gt;

&lt;p&gt;Rust doesn&amp;rsquo;t have type level variadics and has to resort to macros. A commonly used variadic macro is &lt;code&gt;vec![...]&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-D&#34;&gt;// duck typing
void variadicPrint(Args...)(Args args){
    // compile time loop
    foreach(ref arg; args){
        arg.print();
    }
}

void main()
{
    auto wrapperF = Wrapper!Foo(new Foo(42));
    auto f = new Foo(42);
    variadicPrint(f);
    //or
    variadicPrint(f, f, wrapperF, f);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Because &lt;code&gt;variadicPrint&lt;/code&gt; is duck typed, anything that has a &lt;code&gt;print&lt;/code&gt; method, can be passed into it. Variadics also allow &lt;code&gt;Tuple&lt;/code&gt; to be implemented as a library in D.&lt;/p&gt;

&lt;h3 id=&#34;pattern-matching:a33c6a773242a076961a1afafbd9aef7&#34;&gt;Pattern matching&lt;/h3&gt;

&lt;p&gt;Rust natively supports algebraic data types which can be matched on.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;fn main() {
    let o = Some(5);
    match o {
        Some(i) =&amp;gt; println!(&amp;quot;{}&amp;quot;, i),
        None =&amp;gt; println!(&amp;quot;None&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;While D has algebaric data types (adt) as a library inside phobos, they have a significant overhead and can not be used at compile time. Luckily adt&amp;rsquo;s can be implemented in around 30 lines of code.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-D&#34;&gt;alias Test = Algebraic!(uint, float);
uint i = 5;
float f = 5.0f;
auto b = Test(f);
b.match!(
    (uint i) =&amp;gt; writeln(&amp;quot;uint, &amp;quot;, i),
    (float f) =&amp;gt; writeln(&amp;quot;float &amp;quot;, f),
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Rust allows type deconstruction&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;fn main() {
    let t = (1, &amp;quot;Test&amp;quot;);
    let (a, b) = t;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;While something similar can be implemented in D, it will not be as usable.&lt;/p&gt;

&lt;h3 id=&#34;type-level-values:a33c6a773242a076961a1afafbd9aef7&#34;&gt;Type level values&lt;/h3&gt;

&lt;p&gt;Rust doesn&amp;rsquo;t really have &lt;code&gt;type level values&lt;/code&gt;, the closest thing would probably be &lt;code&gt;typenum&lt;/code&gt;. See my &lt;a href=&#34;https://maikklein.github.io/post/impression-rust/&#34;&gt;blog post&lt;/a&gt; about using &lt;code&gt;typenum&lt;/code&gt; for a vector / matrix library.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Type level values&lt;/code&gt; are most commonly used as &lt;code&gt;type level integers&lt;/code&gt;. They allow the user to express a vector math library like this&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-D&#34;&gt;alias Vec3f = Vector&amp;lt;float, 3&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;D isn&amp;rsquo;t limited to integrals, you can basically pass any type into a template at compile time.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-D&#34;&gt;struct Worker{
    string name;
    uint id;
}

string level(Worker worker)(){
    static if(worker.id &amp;lt; 10){
        return &amp;quot;Grunt&amp;quot;;
    }
    else{
        return &amp;quot;Boss&amp;quot;;
    }
}
void main()
{
    // done at compile time
    enum string grunt = level!(Worker(&amp;quot;Tom&amp;quot;, 5));
    enum string boss = level!(Worker(&amp;quot;Jeff&amp;quot;, 20));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;metaprogramming:a33c6a773242a076961a1afafbd9aef7&#34;&gt;Metaprogramming&lt;/h3&gt;

&lt;p&gt;Rust has 3 features that allows metaprogramming, macros, traits and compiler plugins.&lt;/p&gt;

&lt;p&gt;The main purpose of macros is to reduce duplicated code, but they also allow custom syntax like this&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;for e in recurrence!(f[i]: f64 = 1.0 ... f[i-1] * i as f64).take(10) {
    println!(&amp;quot;{}&amp;quot;, e)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://danielkeep.github.io/tlborm/book/pim-README.html&#34;&gt;link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Traits allow implementations to be implemented for a specific range of types, allow types to be constrained and allow for dynamic dispatch.&lt;/p&gt;

&lt;p&gt;Compiler plugins are unstable can operate on the AST and can potentially execute arbitrary code at compile time. An example would be
&lt;a href=&#34;https://github.com/nrc/libhoare&#34;&gt;libhoare&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;#[precond=&amp;quot;x &amp;gt; 0&amp;quot;]
#[postcond=&amp;quot;result &amp;gt; 1&amp;quot;]
fn foo(x: int) -&amp;gt; int {
    let y = 45 / x;
    y + 1
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;While D natively has design by contract, I don&amp;rsquo;t believe this could be implemented as nicely in D. The closest thing I could imagine would be by using &lt;code&gt;UDA&lt;/code&gt; and or mixins. But as far as I know it is not possible to directly manipulate the AST in D.&lt;/p&gt;

&lt;p&gt;D has a full arsenal of metaprogramming tools. Type level values, variadics, type level computations, static if, mixins, templates, CTFE, static reflection. The blog post would become too long to showcase every feature but I already made a few blog posts that use some of those features. &lt;a href=&#34;https://maikklein.github.io/post/soa-d/&#34;&gt;SoA&lt;/a&gt;, &lt;a href=&#34;http://maikklein.github.io/2016/03/01/metaprogramming-typeobject/&#34;&gt;TypeObject ala Boost hana&lt;/a&gt;, &lt;a href=&#34;https://maikklein.github.io/post/2015-11-14-Converting-strings-to-types/&#34;&gt;Strings to types&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;CTFE in D is more limited than compiler plugins. It does not allow to execute arbitrary code like connecting to a database at compile time, as it would be a security risk.&lt;/p&gt;

&lt;h3 id=&#34;standard-library-manual-memory-management-and-ownership-semantics:a33c6a773242a076961a1afafbd9aef7&#34;&gt;Standard library, manual memory management and ownership semantics&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;Before we start let me tell you that it is technically possible to completely avoid the garbage collection in D, but there are currently a few problems.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://doc.rust-lang.org/std/&#34;&gt;Rust std&lt;/a&gt; and &lt;a href=&#34;https://dlang.org/phobos/index.html&#34;&gt;D phobos&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;In my opinion a good standard library is very import for a language. The biggest reason for that is every library will use the standard library to some degree.&lt;/p&gt;

&lt;p&gt;In Rust most libraries are already using &lt;code&gt;Box&lt;/code&gt;, &lt;code&gt;Rc&lt;/code&gt;, &lt;code&gt;Arc&lt;/code&gt;, &lt;code&gt;Result&lt;/code&gt;, &lt;code&gt;Option&lt;/code&gt;. In D there currently is &lt;code&gt;Unique&lt;/code&gt; and &lt;code&gt;RefCounted&lt;/code&gt; which still use the GC. &lt;code&gt;Nullable&lt;/code&gt; is similar to &lt;code&gt;Optional&lt;/code&gt; but it implements auto deref with &lt;code&gt;alias this&lt;/code&gt; and could therefore cause subtle problems.&lt;/p&gt;

&lt;p&gt;Ownership can be modelled in D by disabling the copy constructor. A type without a copy constructor must be moved which is similar to Rust. Currently types without a copy constructor can not reasonably be used with the standard library in D as you would have to explicitly call &lt;code&gt;move&lt;/code&gt; on them.&lt;/p&gt;

&lt;p&gt;This means that you would have to recreate everything in the std that copies in their implementation, which is a lot. Then there are other smaller problems, like how do you move variadic arguments?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-D&#34;&gt;void foo(Args)(Args args){
    bar(args); // how do you pass variadics?
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The way I currently implement this is by looking at the type, if it has no copy constructor I call move, otherwise I copy. I generate a compile time string that looks like this &lt;code&gt;&amp;quot;arg[0], arg[1].move, arg[2].move, arg[3]&amp;quot;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Basically what I am trying to say is that ownership semantics are not as refined as in Rust at the moment and avoiding the GC with smart pointers will be a lot of work.&lt;/p&gt;

&lt;p&gt;To avoid the Gc in D one can use the &lt;a href=&#34;https://dlang.org/phobos/std_experimental_allocator.html&#34;&gt;allocator&lt;/a&gt; library that ships with D. It handles all the low level stuff and exposes generic and composable allocators.&lt;/p&gt;

&lt;p&gt;Rust currently does not have any allocators but it seems to come into &lt;code&gt;nighly&lt;/code&gt; soon.&lt;/p&gt;

&lt;h3 id=&#34;conclusion:a33c6a773242a076961a1afafbd9aef7&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;I am fairly certain that I forgot to cover a few topics but this should give you a rough overview.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>First impression of Rust after two years - Part 2</title>
      <link>https://maikklein.github.io/post/impression-rust-part2/</link>
      <pubDate>Wed, 22 Jun 2016 00:00:00 +0000</pubDate>
      
      <guid>https://maikklein.github.io/post/impression-rust-part2/</guid>
      <description>

&lt;h1 id=&#34;first-impression-of-rust-after-two-years-part-2:92979aa9f46afb7901e866a3ae600237&#34;&gt;First impression of Rust after two years - Part 2&lt;/h1&gt;

&lt;p&gt;As promised this is part 2 of &lt;a href=&#34;https://maikklein.github.io/post/impression-rust/&#34;&gt;part 1&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I created a small task based library in Rust based on naughty dogs gdc talk. The main purpose was to get a feeling of Rust and not the create a full blown library.&lt;/p&gt;

&lt;p&gt;Here is how you would use it.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;fn main() {
    let res = TaskPool::submit(|| {
        println!(&amp;quot;Before long running task&amp;quot;);
        let r = TaskPool::submit(|| {
            std::thread::sleep(Duration::from_secs(10));
            return 42;
        });
        // Waits for the long running task to complete, does not block other tasks!
        println!(&amp;quot;After long running task {}&amp;quot;, r.await());
        42
    });
    for i in 0..20 {
        TaskPool::submit(move || println!(&amp;quot;Another Task {}&amp;quot;, i));
    }
    println!(&amp;quot;{}&amp;quot;, res.await());
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The output can look like this&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;TASK 0
TASK 1
Before long task
TASK 2
TASK 3
TASK 4
TASK 9
TASK 5
TASK 10
TASK 19
TASK 6
TASK 11
TASK 17
TASK 18
TASK 7
TASK 8
TASK 12
TASK 13
TASK 14
TASK 15
TASK 16
After long task 42
42
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The main feature is that tasks will never block other tasks. In a task system it would be very bad for a task to wait for other tasks to complete because you basically lose the benefit of a whole core/thread. Instead I am using a fiber / coroutine to yield the context.&lt;/p&gt;

&lt;p&gt;I am currently using a fork of &lt;a href=&#34;https://github.com/rustcc/coroutine-rs&#34;&gt;coroutine-rs&lt;/a&gt;. Also as you can see, the API is currently relying on a global but immutable TaskPool. The reason for this what that I had to explicitly wrap &lt;code&gt;TaskPool&lt;/code&gt; inside an &lt;code&gt;Arc&lt;/code&gt; and clone it every time I wanted to create a task in another task.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;fn main() {
    let taskpool = Arc::new(TaskPool::new(3));
    let taskpool1 = taskpool.clone();
    let res = taskpool.submit(|| {
        taskpool1.submit(|| println!(&amp;quot;...&amp;quot;));
        42
    });
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I am just not the biggest fan of global variables. Currently a TaskPool is immutable and I just randomly distribute tasks to &lt;code&gt;ThreadLocalQueue&lt;/code&gt;. This is not really a good scheduler but it works. A better approach would probably to do all scheduling on the main thread.&lt;/p&gt;

&lt;p&gt;Also if a tasks gets assigned to a &lt;code&gt;ThreadLocalQueue&lt;/code&gt; it will stay in this queue until it is done. Once a task is assigned to a &lt;code&gt;ThreadLocalQueue&lt;/code&gt; it will create a coroutine. The reason for this is performance because I don&amp;rsquo;t want to worry about sharing fibers across threads and synchronizing them.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Corountine-rs&lt;/code&gt; currently does not support of getting the currently active coroutine. I have implemented it using a thread local variable.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;thread_local!(static FIBER: Cell&amp;lt;*mut coroutine::asymmetric::Handle&amp;gt; = Cell::new(std::ptr::null_mut()));
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;for t in self.work.iter_mut() {
    FIBER.with(|f| {
        f.set(t);
    });
    t.next();
    FIBER.with(|f| {
        f.set(std::ptr::null_mut());
    });
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The gist of it is that before I execute a coroutine, I put a pointer to it on the &lt;code&gt;tls&lt;/code&gt;, execute it and null the ptr again. I have no idea if doing that is even legal.&lt;/p&gt;

&lt;p&gt;I am doing it this way because I then always know if I am currently inside a task or not, without needing to explicitly pass the coroutine.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;struct Future&amp;lt;T&amp;gt; {
    receiver: Receiver&amp;lt;T&amp;gt;,
}
impl&amp;lt;T&amp;gt; Future&amp;lt;T&amp;gt; {
    fn new(receiver: Receiver&amp;lt;T&amp;gt;) -&amp;gt; Self {
        Future { receiver: receiver }
    }

    fn await(&amp;amp;self) -&amp;gt; T {
        let mut fiber = FIBER.with(|f| {
            return f.get();
        });
        let is_fiber = fiber != std::ptr::null_mut();
        if is_fiber {
            loop {
                let r = self.receiver.try_recv();
                if r.is_ok() {
                    return r.unwrap();
                }
                unsafe {
                    (*fiber).resume(0);
                }
            }
        } else {
            return self.receiver.recv().unwrap();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Obviously the whole library is implemented in a super hacky way but this allows me to block on the main thread and reschedule inside a task. Rescheduling works by testing if &lt;code&gt;try_recv&lt;/code&gt; actually returns something, if it doesn&amp;rsquo;t, I yield the context.&lt;/p&gt;

&lt;p&gt;Now I want to talk about the standard library. I am coming from D where I had to recreate almost anything myself that Rust ships by default because I wanted to avoid the GC. That meant recreating Box, Rc, Arc, Vec, Optional, Result etc and basically every container, because none of the container in the phobos (std) is move aware.&lt;/p&gt;

&lt;p&gt;My main goal is to create a game engine from scratch, while I enjoy working really low level, recreating a big part of the standard library was not as much fun as I thought.&lt;/p&gt;

&lt;p&gt;Coming from D it felt really good to have a standard library that works without a GC. The biggest problem of creating a lot of stuff from scratch is that I am the only user. If I encounter some problem, I can&amp;rsquo;t really post my code anywhere if it contains my custom smart-ptr or Optional/Result. Also using other libraries is probably a no go because they will most likely use the standard library which doesn&amp;rsquo;t work with my move aware types.&lt;/p&gt;

&lt;p&gt;So while it is completely possible to implement all those constructs in D, it felt a bit awkward to create everything manually. This makes me appreciate Rust&amp;rsquo;s standard library much more.&lt;/p&gt;

&lt;p&gt;Implementing the task library was relatively painless, the only thing that was missing were coroutines / fibers in the std, which were available as a 3rd party library.&lt;/p&gt;

&lt;h2 id=&#34;conclusions:92979aa9f46afb7901e866a3ae600237&#34;&gt;Conclusions:&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;Note: I base my conclusions on Rust 1.9 stable and I do not include features that may or may not come in the future. I know this may offend some people but it is too hard to judge Rust from the perspective of an outsider. I just don&amp;rsquo;t have enough information when which features might become available in stable Rust as there doesn&amp;rsquo;t seem to be publicly available roadmap.&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&#34;what-i-like:92979aa9f46afb7901e866a3ae600237&#34;&gt;What I like:&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Traits with dynamic / static dispatch&lt;/li&gt;
&lt;li&gt;Useful and well documented standard library&lt;/li&gt;
&lt;li&gt;Good standard documentation engine&lt;/li&gt;
&lt;li&gt;A sort of standardized style guide. I really like that all libraries have an almost identical syntactical style.&lt;/li&gt;
&lt;li&gt;Move semantics are really well done&lt;/li&gt;
&lt;li&gt;Default immutability and the concept of interior mutability&lt;/li&gt;
&lt;li&gt;No constructors&lt;/li&gt;
&lt;li&gt;Memory safety and no race conditions in safe Rust&lt;/li&gt;
&lt;li&gt;One standard open source compiler based on LLVM&lt;/li&gt;
&lt;li&gt;Useful error messages most of the time&lt;/li&gt;
&lt;li&gt;Solid base for a good ecosystem with cargo&lt;/li&gt;
&lt;li&gt;Implementation lives outside a type&lt;/li&gt;
&lt;li&gt;Good type inference&lt;/li&gt;
&lt;li&gt;Explicit error handling like in Haskell&lt;/li&gt;
&lt;li&gt;Pattern matching, deconstructing patterns like &lt;code&gt;let (a, b) = ...;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;what-i-dislike:92979aa9f46afb7901e866a3ae600237&#34;&gt;What I dislike:&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;No variadics&lt;/li&gt;
&lt;li&gt;No type level integers&lt;/li&gt;
&lt;li&gt;Metaprogramming in general is lacking, also unsure where Rust is heading in regards to metaprogramming.&lt;/li&gt;
&lt;li&gt;Compiler sometimes can not reason about lifetimes / mutability, which requires workarounds.&lt;/li&gt;
&lt;li&gt;Compile times seem relatively long compared to D&lt;/li&gt;
&lt;li&gt;No custom allocators&lt;/li&gt;
&lt;li&gt;No constexpr or compile time evaluation&lt;/li&gt;
&lt;li&gt;No public roadmap&lt;/li&gt;
&lt;li&gt;Immature tools like &lt;code&gt;racer&lt;/code&gt; (I don&amp;rsquo;t mean to offend anyone here, I appreciate the effort that is put into those tools)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;My overall impression is that I think Rust has a very good core language but it still misses some advanced features.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>First impression of Rust after two years - Part 1</title>
      <link>https://maikklein.github.io/post/impression-rust/</link>
      <pubDate>Tue, 21 Jun 2016 00:00:00 +0000</pubDate>
      
      <guid>https://maikklein.github.io/post/impression-rust/</guid>
      <description>

&lt;h1 id=&#34;first-impression-of-rust-after-two-years-part-1:a774b914f3de6089319ac433a724d086&#34;&gt;First impression of Rust after two years - Part 1&lt;/h1&gt;

&lt;p&gt;The last time I was using Rust was in version 0.6 - 0.7, which was roughly 2 years ago. I decided to come back to take another look.&lt;/p&gt;

&lt;p&gt;I decided to write two small libraries over the weekend. An n-dimensional, generic and typesafe linear algebra library and a task pool implementation with fibers based on naughty dogs &lt;a href=&#34;http://www.gdcvault.com/play/1022186/Parallelizing-the-Naughty-Dog-Engine&#34;&gt;GDC talk&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;But I came from D where I could easily create a nice vector library with templates.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-D&#34;&gt;alias Vec3f = Vector&amp;lt;float, 3&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I kinda wanted to do the same thing, but the problem is that Rust doesn&amp;rsquo;t have type level integers. This is probably why cgmath and nalgebra create their types manually and implement functionality with macros. Luckily I found &lt;a href=&#34;https://github.com/paholg/typenum&#34;&gt;typenum&lt;/a&gt;, which is sort of hack to emulate type level integers.&lt;/p&gt;

&lt;p&gt;Before I go on, I want to demonstrate some ergonomics of my experimental vector library. The vector types are defined like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;pub type Vec4&amp;lt;T&amp;gt; = Vector&amp;lt;T, U4&amp;gt;;
pub type Vec3&amp;lt;T&amp;gt; = Vector&amp;lt;T, U3&amp;gt;;
pub type Vec2&amp;lt;T&amp;gt; = Vector&amp;lt;T, U2&amp;gt;;

pub type Vec4f = Vec4&amp;lt;f32&amp;gt;;
pub type Vec3f = Vec3&amp;lt;f32&amp;gt;;
pub type Vec2f = Vec2&amp;lt;f32&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Vectors can be created like this&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;let v1 = Vec2f::new(&amp;amp;[0.0, 2.0]);
let v2 = Vec2f::new(&amp;amp;[0.0, 10.0]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can also create a vector with a lower dimensional vector + additional value like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;let v = Vec3f::from_one_less(Vec2f::new(&amp;amp;[1.0, 2.0]), 3.0);
assert!(v == Vec3f::new(&amp;amp;[1.0, 2.0, 3.0]));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It is not as ergonomic as my vector library in D where you can arbitrarily initialize a new vector but it is a start. You may wonder how I implemented it. The type signature looks like this&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;// I left out the type constrains for readability
pub fn from_one_less&amp;lt;&amp;gt;(first: Vector&amp;lt;T, Sub1&amp;lt;N&amp;gt;&amp;gt;, val: T) -&amp;gt; Vector&amp;lt;T, N&amp;gt;{...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It breaks down for a &lt;code&gt;Vec2&lt;/code&gt; because then it would want a &lt;code&gt;Vec1&lt;/code&gt; + a value, which would be a verbose way of writing just two values.&lt;/p&gt;

&lt;p&gt;I don&amp;rsquo;t think that I can restrict implementations for specific &lt;code&gt;typenum&lt;/code&gt; traits. Also it would have also been nice to have one generic function that can accept arbitrary vectors, but that would require at least type level integers + variadic function, which Rust doesn&amp;rsquo;t have.&lt;/p&gt;

&lt;p&gt;Because I used &lt;code&gt;typenum&lt;/code&gt; to express n-dimensional vectors, it made it very easy to implement functions like dot&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;pub fn dot(self, other: Self) -&amp;gt; T {
    self.data
        .into_iter()
        .zip(other.data.into_iter())
        .fold(T::zero(), |acc, (x, y)| acc + x * y)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I really like that Rust has pattern matching on tuples, I think this really adds to readability.&lt;/p&gt;

&lt;p&gt;Now is probably a good time to show the initial definition of a &lt;code&gt;Vector&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;#[derive(PartialEq, Eq, Copy, Debug)]
pub struct Vector&amp;lt;T: Float, N: ArrayLength&amp;lt;T&amp;gt;&amp;gt;
    where N::ArrayType: Copy
{
    pub data: GenericArray&amp;lt;T, N&amp;gt;,
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I implemented copy on this type because this library is intended for game devs which means that the dimensions will probably not bigger than 4. I also don&amp;rsquo;t think I can specialize structs at the moment to allow bigger vectors to be heap allocated. I also auto implemented PartialEq and Eq because I am lazy. Comparison should probably be implemented with &lt;code&gt;abs(a - b) &amp;lt; eps&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Implementing operators was a bit more verbose in Rust compared to D. I used macros to make it less verbose.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;macro_rules! as_expr { ($e:expr) =&amp;gt; {$e} }
macro_rules! impl_op_vec{
    ($trait_name: ident, $fn_name: ident, $op: tt) =&amp;gt; {
        impl&amp;lt;T, N&amp;gt; $trait_name for Vector&amp;lt;T, N&amp;gt;
            where N::ArrayType: Copy,
                  N: ArrayLength&amp;lt;T&amp;gt;,
                  T: Float
        {
            type Output = Vector&amp;lt;T, N&amp;gt;;
            fn $fn_name(self, other: Self) -&amp;gt; Self::Output {
                unsafe {
                    let mut new_data: GenericArray&amp;lt;T, N&amp;gt; = mem::uninitialized();
                    let iter = self.data
                        .iter()
                        .zip(other.data.iter())
                        .map(|(a, b)| as_expr!( *a $op *b));
                    for (index, val) in iter.enumerate() {
                        new_data[index] = val;
                    }
                    Vector::&amp;lt;T, N&amp;gt; { data: new_data }
                }
            }
        }
    }
}

impl_op_vec!(Sub, sub, -);
impl_op_vec!(Add, add, +);
impl_op_vec!(Mul, mul, *);
impl_op_vec!(Div, div, /);

macro_rules! impl_op_vec_un{
    ($trait_name: ident, $fn_name: ident, $op: tt) =&amp;gt; {
        impl&amp;lt;T, N&amp;gt; $trait_name&amp;lt;T&amp;gt; for Vector&amp;lt;T, N&amp;gt;
            where N::ArrayType: Copy,
                  N: ArrayLength&amp;lt;T&amp;gt;,
                  T: Float
        {
            type Output = Vector&amp;lt;T, N&amp;gt;;
            fn $fn_name(self, other: T) -&amp;gt; Self::Output {
                unsafe {
                    let mut new_data: GenericArray&amp;lt;T, N&amp;gt; = mem::uninitialized();
                    let iter = self.data
                        .iter()
                        .map(|a| as_expr!( *a $op other));
                    for (index, val) in iter.enumerate() {
                        new_data[index] = val;
                    }
                    Vector::&amp;lt;T, N&amp;gt; { data: new_data }
                }
            }
        }
    }
}

impl_op_vec_un!(Mul, mul, *);
impl_op_vec_un!(Add, add, +);
impl_op_vec_un!(Sub, sub, -);
impl_op_vec_un!(Div, div, /);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I am not a Rust programmer so this macro is probably not as nice as it should be, but basically all I am doing is a simple text substitution. The only hiccup that I encountered was the substitution for the &lt;code&gt;operator&lt;/code&gt;. For some reason I had to create a helper macro &lt;code&gt;as_expr&lt;/code&gt;. Not sure why this was necessary, but I assume that this might be a bug?&lt;/p&gt;

&lt;p&gt;In general I am not sure I like macros in Rust, because macros can accept almost arbitrary syntax. I think this makes macros very powerful but also painful for other people to use. As a client you probably always have to either read the documentation or look at the macro implementation yourself, so that you know how to invoke the macro correctly.&lt;/p&gt;

&lt;p&gt;Also you might notice that I am using unsafe here. I basically do this almost anywhere because of &lt;code&gt;mem::unitialzed()&lt;/code&gt;. The reason I am doing this is that I don&amp;rsquo;t think that it is possible to collect into a fixed length array / GenericArray from an iterator.&lt;/p&gt;

&lt;p&gt;The documentation engine is pretty nice in Rust, for example you can write&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;/// Builds a `Vector&amp;lt;T, N &amp;gt;` from a `Vector&amp;lt;T, N-1&amp;gt;` with an additional value.
/// # Example
/// ```
/// use rla::vector::*;
/// let v = Vec3f::from_one_less(Vec2f::new(&amp;amp;[1.0, 2.0]), 3.0);
/// assert!(v == Vec3f::new(&amp;amp;[1.0, 2.0, 3.0]));
/// ```
pub fn from_one_less(first: Vector&amp;lt;T, Sub1&amp;lt;N&amp;gt;&amp;gt;, val: T) -&amp;gt; Vector&amp;lt;T, N&amp;gt;{..}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and it will parse the comments as markdown. It also recognizes codeblocks, compiles and executes them.&lt;/p&gt;

&lt;p&gt;I currently haven&amp;rsquo;t implemented vector swizzling nor  individual member access like&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;v.x = 25;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The problem is that I don&amp;rsquo;t know how I would implement this in an ergonomic and clean way. For example in D you can have this&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;
auto x = v.x;
v.x = 24;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;where &lt;code&gt;x&lt;/code&gt; is a overloaded function &lt;code&gt;ref T x(){..}&lt;/code&gt; and &lt;code&gt;void x(T val){}&lt;/code&gt;, although I have implemented it a bit differently in D. I am posting the D implementation because I don&amp;rsquo;t think a lot of Rust programmers really know how metaprogramming looks like.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/BreezeEngine/breeze/blob/master/source/breeze/math/vector.d#L67+L86&#34;&gt;Implementation&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Feel free to skip this part if you are not interested in D.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-D&#34;&gt;struct Vector(T, size_t _dimension){
    private enum vectorCords = &amp;quot;xyzw&amp;quot;;
    ...
    ref auto opDispatch(string op)() inout
    if(op.length is 1){
        import std.string: indexOf;
        import std.algorithm.iteration: map;
        enum index = vectorCords.indexOf(op);
        return data[index];
    }
    auto opDispatch(string op)() const
    if(op.length &amp;gt; 1 &amp;amp;&amp;amp; op.length &amp;lt;= dimension){
        import std.string: indexOf;
        import std.algorithm.iteration: map;
        import std.range: array;
        import std.algorithm.mutation: copy;
        import std.algorithm.searching: count;
        static immutable indices = op.map!(c =&amp;gt; vectorCords.indexOf(c)).array;
        static assert(indices[].count(-1) == 0, &amp;quot;Combination of &amp;quot; ~op~&amp;quot; does not exist.&amp;quot;);
        T[op.length] _data;
        indices.map!(i =&amp;gt; data[i]).copy(_data[]);
        return Vector!(T,op.length)(_data);
    }
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For example &lt;code&gt;v.x&lt;/code&gt; here returns a value but &lt;code&gt;v.xy&lt;/code&gt; returns a Vec2. It is also possible to do &lt;code&gt;v.xyzzyzyy&lt;/code&gt; which would return a Vec8 but it is probably not really practical.&lt;/p&gt;

&lt;p&gt;The code works like this:
&lt;code&gt;private enum vectorCords = &amp;quot;xyzw&amp;quot;;&lt;/code&gt; is a compile time string. opDispatch receives the string behind the dot for an object at compile time. For example calling &lt;code&gt;v.xyz&lt;/code&gt;, opDispatch would receive the string &lt;code&gt;xyz&lt;/code&gt; at compile time. You then map this string at compile time to the index from &lt;code&gt;vectorCords&lt;/code&gt;. For this example it would map &lt;code&gt;&amp;quot;xyz&amp;quot;&lt;/code&gt; to &lt;code&gt;[0, 1, 2]&lt;/code&gt; at compile time. Then you simply look up the values and return the vector. The Vector will have the dimension of the length of the received
string which in this case is &lt;code&gt;xyz&lt;/code&gt;, so it will return a Vector3.&lt;/p&gt;

&lt;p&gt;Let us get back to Rust. Implementing this will be probably a bit harder. I will probably create 4 traits with a macro. &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;xy&lt;/code&gt;, &lt;code&gt;xyz&lt;/code&gt; and &lt;code&gt;xyzw&lt;/code&gt;. &lt;code&gt;xy&lt;/code&gt; will inherit from &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;xyz&lt;/code&gt; from &lt;code&gt;xy&lt;/code&gt; an so on. I will then create default implementations with a macro for all possible combinations. And then I will implement the traits manually for Vector2 - Vector4. I really wish that Rust would get a bit more metaprogramming support in the future.&lt;/p&gt;

&lt;p&gt;Matrices are implemented in a similar fashion.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;type Mat4x4&amp;lt;T&amp;gt; = Matrix&amp;lt;T, U4, U4&amp;gt;;
type Mat3x3&amp;lt;T&amp;gt; = Matrix&amp;lt;T, U3, U3&amp;gt;;
type Mat3x2&amp;lt;T&amp;gt; = Matrix&amp;lt;T, U3, U2&amp;gt;;
type Mat2x3&amp;lt;T&amp;gt; = Matrix&amp;lt;T, U2, U3&amp;gt;;
type Mat2x2&amp;lt;T&amp;gt; = Matrix&amp;lt;T, U2, U2&amp;gt;;

type Mat3x2f = Mat3x2&amp;lt;f32&amp;gt;;
type Mat2x3f = Mat2x3&amp;lt;f32&amp;gt;;
type Mat2x2f = Mat2x2&amp;lt;f32&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But implementing matrices was much harder than a simple vector. For example let us implement matrix multiplication. In case you are not familiar it looks like this
&lt;a href=&#34;https://en.wikipedia.org/wiki/Matrix_multiplication&#34;&gt;Matrix multiplication&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;N, M, N1, M1 &amp;gt; 0
N == N1
Matrix&amp;lt;N, M&amp;gt; * Matrix&amp;lt;N1, M1&amp;gt; = Matrix&amp;lt;M, N1&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;impl&amp;lt;T, N, M&amp;gt; Matrix&amp;lt;T, N, M&amp;gt;
    where ...
{
    fn mul&amp;lt;N1&amp;gt;(&amp;amp;self, other: &amp;amp;Matrix&amp;lt;T, N1, N&amp;gt;) -&amp;gt; Matrix&amp;lt;T, M, N1&amp;gt;{...}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Without type constrains this looks rather elegant. We implement &lt;code&gt;mul&lt;/code&gt; only on matrices that can be multiplied together, and then we return the correct matrix.&lt;/p&gt;

&lt;p&gt;My only gripe with this approach is that I don&amp;rsquo;t think it is possible to return a user defined error.&lt;/p&gt;

&lt;p&gt;For example a client might try to multiply &lt;code&gt;Matrix&amp;lt;f32, 3, 2&amp;gt; * Matrix&amp;lt;f32, 3, 2&amp;gt;&lt;/code&gt; which is not possible. It would be nice to output a custom error message to the user, something like this&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;Error: Tried to multiply Matrix&amp;lt;f32, 3, 2&amp;gt;,  Matrix&amp;lt;f32, 3, 2&amp;gt;, but the dimesions of
Matrix&amp;lt;f32, 3, 2&amp;gt;,  Matrix&amp;lt;f32, 3, 2&amp;gt;  don&#39;t match.
            ^~~~~~~~~~~~~~~~~~~~~~~^
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is possible in D but I don&amp;rsquo;t think something like this can currently be implemented in Rust. Another occurrence would be &lt;code&gt;identity&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;An &lt;a href=&#34;https://en.wikipedia.org/wiki/Identity_matrix&#34;&gt;identity matrix&lt;/a&gt; can only implemented on a matrix of type &lt;code&gt;Matrix&amp;lt;T, N, N&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;impl&amp;lt;T, N&amp;gt; Matrix&amp;lt;T, N, N&amp;gt;
    where ...
{
    fn identity() -&amp;gt; Matrix&amp;lt;T, N, N&amp;gt; {
        ...
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It then would be nice to also output a custom error message if the user wants to call &lt;code&gt;identity&lt;/code&gt; on a non-square matrix.&lt;/p&gt;

&lt;p&gt;If we look at this code again, we see that I have left out the type constrains. I did this on purpose because they look quite hilariously verbose.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;impl&amp;lt;T, N, M&amp;gt; Matrix&amp;lt;T, N, M&amp;gt;
{
    fn mul&amp;lt;N1&amp;gt;(&amp;amp;self, other: &amp;amp;Matrix&amp;lt;T, N1, N&amp;gt;) -&amp;gt; Matrix&amp;lt;T, M, N1&amp;gt;{...}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But it was a good exercise to see how good Rust&amp;rsquo;s error messages really are.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;// funny stuff is happening here
impl&amp;lt;T, N, M&amp;gt; Matrix&amp;lt;T, N, M&amp;gt;
    where T: Float,
          N: ArrayLength&amp;lt;T&amp;gt; + ArrayLength&amp;lt;Vector&amp;lt;T, M&amp;gt;&amp;gt;,
          M: ArrayLength&amp;lt;T&amp;gt; + ArrayLength&amp;lt;Vector&amp;lt;T, N&amp;gt;&amp;gt;,
          &amp;lt;N as ArrayLength&amp;lt;Vector&amp;lt;T, M&amp;gt;&amp;gt;&amp;gt;::ArrayType: Copy,
          &amp;lt;M as ArrayLength&amp;lt;Vector&amp;lt;T, N&amp;gt;&amp;gt;&amp;gt;::ArrayType: Copy,
          &amp;lt;N as ArrayLength&amp;lt;T&amp;gt;&amp;gt;::ArrayType: Copy,
          &amp;lt;M as ArrayLength&amp;lt;T&amp;gt;&amp;gt;::ArrayType: Copy
{
    fn mul&amp;lt;N1&amp;gt;(&amp;amp;self, other: &amp;amp;Matrix&amp;lt;T, N1, N&amp;gt;) -&amp;gt; Matrix&amp;lt;T, M, N1&amp;gt;
        where N1: ArrayLength&amp;lt;T&amp;gt; + ArrayLength&amp;lt;Vector&amp;lt;T, M&amp;gt;&amp;gt; + ArrayLength&amp;lt;Vector&amp;lt;T, N&amp;gt;&amp;gt;,
              &amp;lt;N1 as ArrayLength&amp;lt;T&amp;gt;&amp;gt;::ArrayType: Copy,
              &amp;lt;N1 as ArrayLength&amp;lt;Vector&amp;lt;T, M&amp;gt;&amp;gt;&amp;gt;::ArrayType: Copy,
              &amp;lt;N1 as ArrayLength&amp;lt;Vector&amp;lt;T, N&amp;gt;&amp;gt;&amp;gt;::ArrayType: Copy,
              N: ArrayLength&amp;lt;Vector&amp;lt;T, N1&amp;gt;&amp;gt;,
              &amp;lt;N as ArrayLength&amp;lt;Vector&amp;lt;T, N1&amp;gt;&amp;gt;&amp;gt;::ArrayType: Copy,
              Vector&amp;lt;T, N&amp;gt;: Copy
    {
        unsafe {
            let mut new_matrix: Matrix&amp;lt;T, M, N1&amp;gt; = mem::uninitialized();
            let other_transposed: Matrix&amp;lt;T, N, N1&amp;gt; = other.transpose();
            for j in 0..N1::to_usize() {
                for i in 0..M::to_usize() {
                    new_matrix.data[j].data[i] = self.data[j].dot(other_transposed.data[i]);
                }
            }
            new_matrix
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Obviously this looks horrendous and I am not even sure I had to write it like that. It was really annoying to repeatedly specify the copy constrain.&lt;/p&gt;

&lt;p&gt;The only good part was that it was super trivial to write. I did 0 thinking about any constrains, I just looked at the error messages and copy pasted the constrain. I did this until Rust stopped complaining. I was really surprised that how easy this was and it would probably not be too unreasonable to think that the constrains could possibly be generated with some external tool.&lt;/p&gt;

&lt;p&gt;My experience with cargo and crates.io was flawless so far. I didn&amp;rsquo;t run into any issue at all. I really like how intuitive it was to get up and running. Publishing a crate was also pretty simple, you can find it &lt;a href=&#34;https://crates.io/crates/rla&#34;&gt;here&lt;/a&gt;. Please note that the library is completely experimental and will probably never be finished.&lt;/p&gt;

&lt;p&gt;It was also possible to add a .git repository inside a cargo.toml, which I had to do with my task pool library. More on that in part 2.&lt;/p&gt;

&lt;p&gt;Also cargo allows you to directly install binaries into .cargo. For example you can install cargo watch like this &lt;code&gt;cargo install cargo-watch&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;This concludes Part 1, in Part 2 I will continue with my task pool library.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>