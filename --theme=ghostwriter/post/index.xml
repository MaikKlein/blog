<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Your site title</title>
    <link>http://replace-this-with-your-hugo-site.com/post/</link>
    <description>Recent content in Posts on Your site title</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Thu, 03 Mar 2016 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://replace-this-with-your-hugo-site.com/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>An objective comparison between D and C&#43;&#43;</title>
      <link>http://replace-this-with-your-hugo-site.com/2016/03/03/cpp-and-d</link>
      <pubDate>Thu, 03 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>http://replace-this-with-your-hugo-site.com/2016/03/03/cpp-and-d</guid>
      <description>&lt;p&gt;#Helo&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;www.google.com&#34;&gt;asd&lt;/a&gt;
ads&lt;/p&gt;

&lt;p&gt;##Hello&lt;/p&gt;

&lt;p&gt;asd&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Metaprogramming with type objects in D</title>
      <link>http://replace-this-with-your-hugo-site.com/2016/03/01/metaprogramming-typeobject</link>
      <pubDate>Tue, 01 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>http://replace-this-with-your-hugo-site.com/2016/03/01/metaprogramming-typeobject</guid>
      <description>&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #2f1e2e&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #5bc4bf&#34;&gt;section&lt;/span&gt; &lt;span style=&#34;color: #06b6ef&#34;&gt;id&lt;/span&gt;&lt;span style=&#34;color: #5bc4bf&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #48b685&#34;&gt;&amp;quot;main&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;&amp;gt;&lt;/span&gt;
  &lt;span style=&#34;color: #e7e9db&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #5bc4bf&#34;&gt;div&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;&amp;gt;&lt;/span&gt;
    &lt;span style=&#34;color: #e7e9db&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #5bc4bf&#34;&gt;h1&lt;/span&gt; &lt;span style=&#34;color: #06b6ef&#34;&gt;id&lt;/span&gt;&lt;span style=&#34;color: #5bc4bf&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #48b685&#34;&gt;&amp;quot;title&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;&amp;gt;&lt;/span&gt;{{ .Title }}&lt;span style=&#34;color: #e7e9db&#34;&gt;&amp;lt;/&lt;/span&gt;&lt;span style=&#34;color: #5bc4bf&#34;&gt;h1&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;&amp;gt;&lt;/span&gt;
    {{ range .Data.Pages }}
      {{ .Render &amp;quot;summary&amp;quot;}}
    {{ end }}
  &lt;span style=&#34;color: #e7e9db&#34;&gt;&amp;lt;/&lt;/span&gt;&lt;span style=&#34;color: #5bc4bf&#34;&gt;div&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #e7e9db&#34;&gt;&amp;lt;/&lt;/span&gt;&lt;span style=&#34;color: #5bc4bf&#34;&gt;section&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


I am going to introduce you to &lt;code&gt;Type Objects&lt;/code&gt; and why they might be useful in combination with metaprogramming.
This blog post is heavily inspired by &lt;a href=&#34;https://github.com/boostorg/hana&#34;&gt;Boost Hana&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Let us start with an example. If we would want to implement an &lt;code&gt;Algebraic Data Type&lt;/code&gt; we would need to find out the maximal size of the types it should contain. In D that is pretty easy
&lt;div class=&#34;highlight&#34; style=&#34;background: #2f1e2e&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #815ba4&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;std.meta:&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;AliasSeq;&lt;/span&gt;
&lt;span style=&#34;color: #815ba4&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;std.traits:&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;Largest;&lt;/span&gt;
&lt;span style=&#34;color: #815ba4&#34;&gt;alias&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;Types&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;AliasSeq!(&lt;/span&gt;&lt;span style=&#34;color: #fec418&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color: #fec418&#34;&gt;float&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color: #fec418&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color: #fec418&#34;&gt;double&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;);&lt;/span&gt;
&lt;span style=&#34;color: #815ba4&#34;&gt;enum&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;maxSize&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;Largest!(Types).sizeof;&lt;/span&gt;
&lt;span style=&#34;color: #e7e9db&#34;&gt;writeln(maxSize);&lt;/span&gt;&lt;span style=&#34;color: #776e71&#34;&gt;//8 bytes&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;Largest is implemented like this
&lt;div class=&#34;highlight&#34; style=&#34;background: #2f1e2e&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #815ba4&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;Largest(T...)&lt;/span&gt; &lt;span style=&#34;color: #815ba4&#34;&gt;if&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;(T.length&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span style=&#34;color: #f99b15&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;)&lt;/span&gt;
&lt;span style=&#34;color: #e7e9db&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color: #815ba4&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color: #815ba4&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;(T.length&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color: #f99b15&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;)&lt;/span&gt;
    &lt;span style=&#34;color: #e7e9db&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color: #815ba4&#34;&gt;alias&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;Largest&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;T[&lt;/span&gt;&lt;span style=&#34;color: #f99b15&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;];&lt;/span&gt;
    &lt;span style=&#34;color: #e7e9db&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color: #815ba4&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color: #815ba4&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color: #815ba4&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;(T.length&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color: #f99b15&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;)&lt;/span&gt;
    &lt;span style=&#34;color: #e7e9db&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color: #815ba4&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color: #815ba4&#34;&gt;if&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;(T[&lt;/span&gt;&lt;span style=&#34;color: #f99b15&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;].sizeof&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;T[&lt;/span&gt;&lt;span style=&#34;color: #f99b15&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;].sizeof)&lt;/span&gt;
        &lt;span style=&#34;color: #e7e9db&#34;&gt;{&lt;/span&gt;
            &lt;span style=&#34;color: #815ba4&#34;&gt;alias&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;Largest&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;T[&lt;/span&gt;&lt;span style=&#34;color: #f99b15&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;];&lt;/span&gt;
        &lt;span style=&#34;color: #e7e9db&#34;&gt;}&lt;/span&gt;
        &lt;span style=&#34;color: #815ba4&#34;&gt;else&lt;/span&gt;
        &lt;span style=&#34;color: #e7e9db&#34;&gt;{&lt;/span&gt;
            &lt;span style=&#34;color: #815ba4&#34;&gt;alias&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;Largest&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;T[&lt;/span&gt;&lt;span style=&#34;color: #f99b15&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;];&lt;/span&gt;
        &lt;span style=&#34;color: #e7e9db&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color: #e7e9db&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color: #815ba4&#34;&gt;else&lt;/span&gt;
    &lt;span style=&#34;color: #e7e9db&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color: #815ba4&#34;&gt;alias&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;Largest&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;Largest!(Largest!(T[&lt;/span&gt;&lt;span style=&#34;color: #f99b15&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;..&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;$/&lt;/span&gt;&lt;span style=&#34;color: #f99b15&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;]),&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;Largest!(T[$/&lt;/span&gt;&lt;span style=&#34;color: #f99b15&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;..&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;$]));&lt;/span&gt;
    &lt;span style=&#34;color: #e7e9db&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color: #e7e9db&#34;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;But if &lt;code&gt;Largest&lt;/code&gt; wouldn&amp;rsquo;t be available, it would be quite annoying to always create a new template. Alternatively we could implement &lt;code&gt;Largest&lt;/code&gt; like this
&lt;div class=&#34;highlight&#34; style=&#34;background: #2f1e2e&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #815ba4&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;std.meta:&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;AliasSeq,&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;staticMap;&lt;/span&gt;
&lt;span style=&#34;color: #815ba4&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;std.traits:&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;Largest;&lt;/span&gt;
&lt;span style=&#34;color: #815ba4&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;std.algorithm.comparison:&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;max;&lt;/span&gt;
&lt;span style=&#34;color: #815ba4&#34;&gt;alias&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;Types&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;AliasSeq!(&lt;/span&gt;&lt;span style=&#34;color: #fec418&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color: #fec418&#34;&gt;float&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color: #fec418&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color: #fec418&#34;&gt;double&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;);&lt;/span&gt;
&lt;span style=&#34;color: #815ba4&#34;&gt;enum&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;size(T)&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;T.sizeof;&lt;/span&gt;
&lt;span style=&#34;color: #815ba4&#34;&gt;enum&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;maxSize&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;max(staticMap!(size,&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;Types));&lt;/span&gt;
&lt;span style=&#34;color: #e7e9db&#34;&gt;writeln(maxSize);&lt;/span&gt;&lt;span style=&#34;color: #776e71&#34;&gt;//8 byte&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

Not much worse because we can reuse the standard library but we also had to create a new template to convert types into sizes. This is a general pattern in metaprogramming. If you want to do type level metaprogramming you have to use templates but wouldn&amp;rsquo;t it be nice if we could use ordinary functions?&lt;/p&gt;

&lt;p&gt;Instead of doing type computations with templates we will create &lt;code&gt;Type Objects&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #2f1e2e&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #815ba4&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;std.traits:&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;isInstanceOf;&lt;/span&gt;
&lt;span style=&#34;color: #815ba4&#34;&gt;enum&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;isType(T)&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;isInstanceOf!(Type,&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;T);&lt;/span&gt;
&lt;span style=&#34;color: #815ba4&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;Type(T){&lt;/span&gt;
    &lt;span style=&#34;color: #815ba4&#34;&gt;alias&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;T;&lt;/span&gt;
    &lt;span style=&#34;color: #e7e9db&#34;&gt;string&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;toString()&lt;/span&gt;
    &lt;span style=&#34;color: #e7e9db&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color: #815ba4&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color: #48b685&#34;&gt;&amp;quot;Type!(&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;~T.stringof~&lt;/span&gt;&lt;span style=&#34;color: #48b685&#34;&gt;&amp;quot;)&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color: #e7e9db&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color: #e7e9db&#34;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #2f1e2e&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #815ba4&#34;&gt;enum&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;t&lt;/span&gt;  &lt;span style=&#34;color: #e7e9db&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;Type!(&lt;/span&gt;&lt;span style=&#34;color: #fec418&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;)();&lt;/span&gt;
&lt;span style=&#34;color: #815ba4&#34;&gt;enum&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;t1&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;Type!(string)();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;You may wonder why we do this. The answer is simple, we now can use &lt;code&gt;Types&lt;/code&gt; like ordinary objects. Let us create a simple &lt;code&gt;equals&lt;/code&gt; function that checks if two &lt;code&gt;Types&lt;/code&gt; are actually the same.
&lt;div class=&#34;highlight&#34; style=&#34;background: #2f1e2e&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #815ba4&#34;&gt;enum&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;equals(A,B)(Type!A,&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;Type!B){&lt;/span&gt;
    &lt;span style=&#34;color: #815ba4&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color: #815ba4&#34;&gt;is&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;(A&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;B);&lt;/span&gt;
&lt;span style=&#34;color: #e7e9db&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color: #815ba4&#34;&gt;enum&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;t&lt;/span&gt;  &lt;span style=&#34;color: #e7e9db&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;Type!(&lt;/span&gt;&lt;span style=&#34;color: #fec418&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;)();&lt;/span&gt;
&lt;span style=&#34;color: #815ba4&#34;&gt;enum&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;t1&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;Type!(string)();&lt;/span&gt;

&lt;span style=&#34;color: #e7e9db&#34;&gt;writeln(t.equals(t1));&lt;/span&gt; &lt;span style=&#34;color: #776e71&#34;&gt;// false&lt;/span&gt;
&lt;span style=&#34;color: #e7e9db&#34;&gt;writeln(equals(t,&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;t1));&lt;/span&gt; &lt;span style=&#34;color: #776e71&#34;&gt;// false&lt;/span&gt;
&lt;span style=&#34;color: #e7e9db&#34;&gt;writeln(equals(Type!&lt;/span&gt;&lt;span style=&#34;color: #fec418&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;(),&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;Type!&lt;/span&gt;&lt;span style=&#34;color: #fec418&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;()));&lt;/span&gt; &lt;span style=&#34;color: #776e71&#34;&gt;// true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

Types itself are not that interesting, let us create a &lt;code&gt;TypeTuple&lt;/code&gt; that can hold any number of &lt;code&gt;Types&lt;/code&gt;.
&lt;div class=&#34;highlight&#34; style=&#34;background: #2f1e2e&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #815ba4&#34;&gt;enum&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;isTypeTuple(T)&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;isInstanceOf!(TypeTuple,&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;T);&lt;/span&gt;

&lt;span style=&#34;color: #815ba4&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;TypeTuple(Types...){&lt;/span&gt;
    &lt;span style=&#34;color: #815ba4&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;std.meta:&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;allSatisfy;&lt;/span&gt;
    &lt;span style=&#34;color: #815ba4&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color: #815ba4&#34;&gt;assert&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;(allSatisfy!(isType,&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;Types),&lt;/span&gt; &lt;span style=&#34;color: #48b685&#34;&gt;&amp;quot;Variadic parameters need to be of type &amp;#39;Type!&amp;#39;&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;);&lt;/span&gt;
    &lt;span style=&#34;color: #e7e9db&#34;&gt;Types&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;expand;&lt;/span&gt;
    &lt;span style=&#34;color: #815ba4&#34;&gt;alias&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;expand&lt;/span&gt; &lt;span style=&#34;color: #815ba4&#34;&gt;this&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color: #e7e9db&#34;&gt;string&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;toString()&lt;/span&gt;
    &lt;span style=&#34;color: #e7e9db&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color: #815ba4&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;std.range;&lt;/span&gt;
        &lt;span style=&#34;color: #e7e9db&#34;&gt;string[]&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;s;&lt;/span&gt;
        &lt;span style=&#34;color: #815ba4&#34;&gt;foreach&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;(t;&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;expand){&lt;/span&gt;
            &lt;span style=&#34;color: #e7e9db&#34;&gt;s~=&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;t.toString();&lt;/span&gt;
        &lt;span style=&#34;color: #e7e9db&#34;&gt;}&lt;/span&gt;
        &lt;span style=&#34;color: #815ba4&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color: #48b685&#34;&gt;&amp;quot;TypeTuple!(&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;~&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;s.join(&lt;/span&gt;&lt;span style=&#34;color: #48b685&#34;&gt;&amp;quot;, &amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;~&lt;/span&gt;&lt;span style=&#34;color: #48b685&#34;&gt;&amp;quot;)&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color: #e7e9db&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color: #e7e9db&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color: #815ba4&#34;&gt;enum&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;typeTuple(Types...)(Types){&lt;/span&gt;
    &lt;span style=&#34;color: #815ba4&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;TypeTuple!Types();&lt;/span&gt;
&lt;span style=&#34;color: #e7e9db&#34;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

By the way you may wonder why we created a &lt;code&gt;toString&lt;/code&gt; method here. This is because &lt;code&gt;D&lt;/code&gt; sometimes doesn&amp;rsquo;t like to print types that were generated and it might not print the actual type and inserts some pseudo symbols like &lt;code&gt;F!int&lt;/code&gt; instead of &lt;code&gt;Type!int&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We can use &lt;code&gt;TypeTuple&lt;/code&gt; like this:
&lt;div class=&#34;highlight&#34; style=&#34;background: #2f1e2e&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #815ba4&#34;&gt;enum&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;types&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;TypeTuple!(Type!&lt;/span&gt;&lt;span style=&#34;color: #fec418&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;Type!&lt;/span&gt;&lt;span style=&#34;color: #fec418&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;Type!&lt;/span&gt;&lt;span style=&#34;color: #fec418&#34;&gt;float&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;Type!&lt;/span&gt;&lt;span style=&#34;color: #fec418&#34;&gt;double&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;)();&lt;/span&gt;
&lt;span style=&#34;color: #776e71&#34;&gt;//or&lt;/span&gt;
&lt;span style=&#34;color: #815ba4&#34;&gt;enum&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;types&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;typeTuple(Type!&lt;/span&gt;&lt;span style=&#34;color: #fec418&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;Type!&lt;/span&gt;&lt;span style=&#34;color: #fec418&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;Type!&lt;/span&gt;&lt;span style=&#34;color: #fec418&#34;&gt;float&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;Type!&lt;/span&gt;&lt;span style=&#34;color: #fec418&#34;&gt;double&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

It is just a bit of boilerplate which we can easily avoid with a helper function
&lt;div class=&#34;highlight&#34; style=&#34;background: #2f1e2e&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #815ba4&#34;&gt;enum&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;tupleFromTypes(Ts...)(){&lt;/span&gt;
    &lt;span style=&#34;color: #815ba4&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;std.meta:&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;staticMap;&lt;/span&gt;
    &lt;span style=&#34;color: #815ba4&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;TypeTuple!(staticMap!(Type,&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;Ts))();&lt;/span&gt;
&lt;span style=&#34;color: #e7e9db&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color: #815ba4&#34;&gt;enum&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;types&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;tupleFromTypes!(&lt;/span&gt;&lt;span style=&#34;color: #fec418&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color: #fec418&#34;&gt;double&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color: #fec418&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color: #fec418&#34;&gt;float&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

Now we can start to implement some nice metafunctions. We start by implementing &lt;code&gt;filter&lt;/code&gt;.
&lt;div class=&#34;highlight&#34; style=&#34;background: #2f1e2e&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #815ba4&#34;&gt;enum&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;filter(&lt;/span&gt;&lt;span style=&#34;color: #815ba4&#34;&gt;alias&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;f,&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;Tup)(Tup){&lt;/span&gt;
    &lt;span style=&#34;color: #815ba4&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color: #815ba4&#34;&gt;assert&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;(isTypeTuple!(Tup),&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;tup.stringof~&lt;/span&gt;&lt;span style=&#34;color: #48b685&#34;&gt;&amp;quot; is not a TypeTuple.&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;);&lt;/span&gt;
    &lt;span style=&#34;color: #815ba4&#34;&gt;enum&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;tup&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;Tup();&lt;/span&gt;
    &lt;span style=&#34;color: #815ba4&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color: #815ba4&#34;&gt;if&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;(tup.length&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color: #f99b15&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;){&lt;/span&gt;
        &lt;span style=&#34;color: #815ba4&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;typeTuple();&lt;/span&gt;
    &lt;span style=&#34;color: #e7e9db&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color: #815ba4&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color: #815ba4&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color: #815ba4&#34;&gt;if&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;(f(tup[&lt;/span&gt;&lt;span style=&#34;color: #f99b15&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;])){&lt;/span&gt;
        &lt;span style=&#34;color: #815ba4&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;typeTuple(tup[&lt;/span&gt;&lt;span style=&#34;color: #f99b15&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;],&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;filter!(f)(typeTuple(tup[&lt;/span&gt;&lt;span style=&#34;color: #f99b15&#34;&gt;1.&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;.$])).expand);&lt;/span&gt;
    &lt;span style=&#34;color: #e7e9db&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color: #815ba4&#34;&gt;else&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color: #815ba4&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;filter!(f)(typeTuple(tup[&lt;/span&gt;&lt;span style=&#34;color: #f99b15&#34;&gt;1.&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;.$]));&lt;/span&gt;
    &lt;span style=&#34;color: #e7e9db&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color: #e7e9db&#34;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

We can now use it like this:&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #2f1e2e&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #815ba4&#34;&gt;enum&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;types&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;tupleFromTypes!(&lt;/span&gt;&lt;span style=&#34;color: #fec418&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color: #fec418&#34;&gt;double&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;string,&lt;/span&gt; &lt;span style=&#34;color: #fec418&#34;&gt;float&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;);&lt;/span&gt;
&lt;span style=&#34;color: #815ba4&#34;&gt;enum&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;biggerThan4&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;filter!(t&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;t.type.sizeof&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #f99b15&#34;&gt;4&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;)(types);&lt;/span&gt;
&lt;span style=&#34;color: #e7e9db&#34;&gt;writeln(biggerThan4);&lt;/span&gt;&lt;span style=&#34;color: #776e71&#34;&gt;// TypeTuple!(Type!(double), Type!(string))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

The code above filters our &lt;code&gt;TypeTuple&lt;/code&gt; with an ordinary lambda function. The resulting &lt;code&gt;Types&lt;/code&gt; must be bigger than 4 bytes. We can also implement &lt;code&gt;map&lt;/code&gt;
&lt;div class=&#34;highlight&#34; style=&#34;background: #2f1e2e&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #815ba4&#34;&gt;enum&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;map(&lt;/span&gt;&lt;span style=&#34;color: #815ba4&#34;&gt;alias&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;f,&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;Tup)(Tup){&lt;/span&gt;
    &lt;span style=&#34;color: #815ba4&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color: #815ba4&#34;&gt;assert&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;(isTypeTuple!(Tup),&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;tup.stringof~&lt;/span&gt;&lt;span style=&#34;color: #48b685&#34;&gt;&amp;quot; is not a TypeTuple.&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;);&lt;/span&gt;
    &lt;span style=&#34;color: #815ba4&#34;&gt;enum&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;tup&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;Tup();&lt;/span&gt;
    &lt;span style=&#34;color: #815ba4&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color: #815ba4&#34;&gt;if&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;(tup.length&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color: #f99b15&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;){&lt;/span&gt;
        &lt;span style=&#34;color: #815ba4&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;typeTuple!();&lt;/span&gt;
    &lt;span style=&#34;color: #e7e9db&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color: #815ba4&#34;&gt;else&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color: #815ba4&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;typeTuple(f(tup[&lt;/span&gt;&lt;span style=&#34;color: #f99b15&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;]),&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;map!(f)(typeTuple(tup[&lt;/span&gt;&lt;span style=&#34;color: #f99b15&#34;&gt;1.&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;.$])).expand);&lt;/span&gt;
    &lt;span style=&#34;color: #e7e9db&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color: #e7e9db&#34;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #2f1e2e&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #815ba4&#34;&gt;enum&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;types&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;tupleFromTypes!(&lt;/span&gt;&lt;span style=&#34;color: #fec418&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color: #fec418&#34;&gt;double&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;string,&lt;/span&gt; &lt;span style=&#34;color: #fec418&#34;&gt;float&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;);&lt;/span&gt;
&lt;span style=&#34;color: #815ba4&#34;&gt;enum&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;onlyInts&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;map!(t&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;Type!&lt;/span&gt;&lt;span style=&#34;color: #fec418&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;())(types);&lt;/span&gt;
&lt;span style=&#34;color: #e7e9db&#34;&gt;writeln(onlyInts);&lt;/span&gt;&lt;span style=&#34;color: #776e71&#34;&gt;// TypeTuple!(Type!(int), Type!(int), Type!(int), Type!(int))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

We replace every &lt;code&gt;Type&lt;/code&gt; with &lt;code&gt;Type!int&lt;/code&gt; which is probably not that useful. We could also replace only types that are actually bigger than 4 bytes with &lt;code&gt;Type!int&lt;/code&gt;.
&lt;div class=&#34;highlight&#34; style=&#34;background: #2f1e2e&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #815ba4&#34;&gt;enum&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;types&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;tupleFromTypes!(&lt;/span&gt;&lt;span style=&#34;color: #fec418&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color: #fec418&#34;&gt;double&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;string,&lt;/span&gt; &lt;span style=&#34;color: #fec418&#34;&gt;float&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;);&lt;/span&gt;
&lt;span style=&#34;color: #815ba4&#34;&gt;enum&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;smallerThan5&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;map!((t){&lt;/span&gt;
    &lt;span style=&#34;color: #815ba4&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color: #815ba4&#34;&gt;if&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;(t.type.sizeof&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #f99b15&#34;&gt;4&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;){&lt;/span&gt;
        &lt;span style=&#34;color: #815ba4&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;Type!&lt;/span&gt;&lt;span style=&#34;color: #fec418&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;();&lt;/span&gt;
    &lt;span style=&#34;color: #e7e9db&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color: #815ba4&#34;&gt;else&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color: #815ba4&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;t;&lt;/span&gt;
    &lt;span style=&#34;color: #e7e9db&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color: #e7e9db&#34;&gt;})(types);&lt;/span&gt;&lt;span style=&#34;color: #776e71&#34;&gt;// TypeTuple!(Type!(int), Type!(int), Type!(int), Type!(float))&lt;/span&gt;
&lt;span style=&#34;color: #e7e9db&#34;&gt;writeln(smallerThan5);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

The possibilities are almost endless and you can use it like any other function. Just remember that it needs to be executed at compile time which means you have to use &lt;code&gt;static if&lt;/code&gt; instead of an ordinary &lt;code&gt;if&lt;/code&gt;.
&lt;div class=&#34;highlight&#34; style=&#34;background: #2f1e2e&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #815ba4&#34;&gt;enum&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;indexOf(T,Tup)(T,&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;Tup){&lt;/span&gt;
    &lt;span style=&#34;color: #815ba4&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color: #815ba4&#34;&gt;assert&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;(isTypeTuple!(Tup),&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;tup.stringof~&lt;/span&gt;&lt;span style=&#34;color: #48b685&#34;&gt;&amp;quot; is not a TypeTuple.&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;);&lt;/span&gt;
    &lt;span style=&#34;color: #815ba4&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color: #815ba4&#34;&gt;assert&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;(isType!(T),&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;T.stringof~&lt;/span&gt;&lt;span style=&#34;color: #48b685&#34;&gt;&amp;quot; is not a Type.&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;);&lt;/span&gt;
    &lt;span style=&#34;color: #815ba4&#34;&gt;enum&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;t&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;T();&lt;/span&gt;
    &lt;span style=&#34;color: #815ba4&#34;&gt;enum&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;tup&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;Tup();&lt;/span&gt;
    &lt;span style=&#34;color: #815ba4&#34;&gt;foreach&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;(index,&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;type;&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;tup.expand){&lt;/span&gt;
        &lt;span style=&#34;color: #815ba4&#34;&gt;if&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;(type.equals(t)){&lt;/span&gt;
            &lt;span style=&#34;color: #815ba4&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;index;&lt;/span&gt;
        &lt;span style=&#34;color: #e7e9db&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color: #e7e9db&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color: #815ba4&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color: #f99b15&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;;&lt;/span&gt;
&lt;span style=&#34;color: #e7e9db&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color: #815ba4&#34;&gt;enum&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;types&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;tupleFromTypes!(&lt;/span&gt;&lt;span style=&#34;color: #fec418&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color: #fec418&#34;&gt;double&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;string,&lt;/span&gt; &lt;span style=&#34;color: #fec418&#34;&gt;float&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;);&lt;/span&gt;
&lt;span style=&#34;color: #815ba4&#34;&gt;enum&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;index&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;indexOf(Type!string(),&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;types);&lt;/span&gt;
&lt;span style=&#34;color: #e7e9db&#34;&gt;writeln(index);&lt;/span&gt;&lt;span style=&#34;color: #776e71&#34;&gt;// 2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

And last but not least, we can implement quicksort for types.
&lt;div class=&#34;highlight&#34; style=&#34;background: #2f1e2e&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #815ba4&#34;&gt;enum&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;partition(&lt;/span&gt;&lt;span style=&#34;color: #815ba4&#34;&gt;alias&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;f,&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;Tup)(Tup){&lt;/span&gt;
    &lt;span style=&#34;color: #815ba4&#34;&gt;enum&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;tup&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;Tup();&lt;/span&gt;
    &lt;span style=&#34;color: #815ba4&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;partitionImpl!(f)(tup,&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;typeTuple(),&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;typeTuple());&lt;/span&gt;
&lt;span style=&#34;color: #e7e9db&#34;&gt;}&lt;/span&gt;

&lt;span style=&#34;color: #815ba4&#34;&gt;enum&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;partitionImpl(&lt;/span&gt;&lt;span style=&#34;color: #815ba4&#34;&gt;alias&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;f,&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;Tup,&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;TupLeft,&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;TupRight)(Tup,&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;TupLeft,&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;TupRight){&lt;/span&gt;
    &lt;span style=&#34;color: #815ba4&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;std.typecons:&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;tuple;&lt;/span&gt;
    &lt;span style=&#34;color: #815ba4&#34;&gt;enum&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;tup&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;Tup();&lt;/span&gt;
    &lt;span style=&#34;color: #815ba4&#34;&gt;enum&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;l&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;TupLeft();&lt;/span&gt;
    &lt;span style=&#34;color: #815ba4&#34;&gt;enum&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;r&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;TupRight();&lt;/span&gt;

    &lt;span style=&#34;color: #815ba4&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color: #815ba4&#34;&gt;if&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;(tup.length&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color: #f99b15&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;){&lt;/span&gt;
        &lt;span style=&#34;color: #815ba4&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;tuple(l,&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;r);&lt;/span&gt;
    &lt;span style=&#34;color: #e7e9db&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color: #815ba4&#34;&gt;else&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color: #815ba4&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color: #815ba4&#34;&gt;if&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;(f(tup[&lt;/span&gt;&lt;span style=&#34;color: #f99b15&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;])){&lt;/span&gt;
            &lt;span style=&#34;color: #815ba4&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;partitionImpl!(f)(typeTuple(tup[&lt;/span&gt;&lt;span style=&#34;color: #f99b15&#34;&gt;1.&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;.$]),&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;typeTuple(tup[&lt;/span&gt;&lt;span style=&#34;color: #f99b15&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;],&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;l.expand),&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;typeTuple(r.expand));&lt;/span&gt;
        &lt;span style=&#34;color: #e7e9db&#34;&gt;}&lt;/span&gt;
        &lt;span style=&#34;color: #815ba4&#34;&gt;else&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;{&lt;/span&gt;
            &lt;span style=&#34;color: #815ba4&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;partitionImpl!(f)(typeTuple(tup[&lt;/span&gt;&lt;span style=&#34;color: #f99b15&#34;&gt;1.&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;.$]),&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;typeTuple(l.expand),&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;typeTuple(tup[&lt;/span&gt;&lt;span style=&#34;color: #f99b15&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;],&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;r.expand));&lt;/span&gt;
        &lt;span style=&#34;color: #e7e9db&#34;&gt;}&lt;/span&gt;

    &lt;span style=&#34;color: #e7e9db&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color: #e7e9db&#34;&gt;}&lt;/span&gt;

&lt;span style=&#34;color: #815ba4&#34;&gt;enum&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;sort(&lt;/span&gt;&lt;span style=&#34;color: #815ba4&#34;&gt;alias&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;f,Tup)(Tup){&lt;/span&gt;
    &lt;span style=&#34;color: #815ba4&#34;&gt;enum&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;tup&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;Tup();&lt;/span&gt;
    &lt;span style=&#34;color: #815ba4&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color: #815ba4&#34;&gt;if&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;(tup.length&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color: #f99b15&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;){&lt;/span&gt;
        &lt;span style=&#34;color: #815ba4&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;typeTuple();&lt;/span&gt;
    &lt;span style=&#34;color: #e7e9db&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color: #815ba4&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color: #815ba4&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color: #815ba4&#34;&gt;if&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;(tup.length&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color: #f99b15&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;){&lt;/span&gt;
        &lt;span style=&#34;color: #815ba4&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;typeTuple(tup[&lt;/span&gt;&lt;span style=&#34;color: #f99b15&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;]);&lt;/span&gt;
    &lt;span style=&#34;color: #e7e9db&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color: #815ba4&#34;&gt;else&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color: #815ba4&#34;&gt;enum&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;middle=&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;tup[&lt;/span&gt;&lt;span style=&#34;color: #f99b15&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;];&lt;/span&gt;
        &lt;span style=&#34;color: #815ba4&#34;&gt;enum&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;t&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;partition!(t&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;f(t,&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;middle))(typeTuple(tup[&lt;/span&gt;&lt;span style=&#34;color: #f99b15&#34;&gt;1.&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;.$]));&lt;/span&gt;
        &lt;span style=&#34;color: #815ba4&#34;&gt;enum&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;left&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;t[&lt;/span&gt;&lt;span style=&#34;color: #f99b15&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;];&lt;/span&gt;
        &lt;span style=&#34;color: #815ba4&#34;&gt;enum&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;right&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;t[&lt;/span&gt;&lt;span style=&#34;color: #f99b15&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;];&lt;/span&gt;
        &lt;span style=&#34;color: #815ba4&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;typeTuple(left.expand,&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;middle,&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;right.expand);&lt;/span&gt;
    &lt;span style=&#34;color: #e7e9db&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color: #e7e9db&#34;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

I needed to create another helper function &lt;code&gt;partition&lt;/code&gt; which just splits a &lt;code&gt;TypeTuple&lt;/code&gt; into two &lt;code&gt;TypeTuples&lt;/code&gt; based on a predicate.
&lt;div class=&#34;highlight&#34; style=&#34;background: #2f1e2e&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #815ba4&#34;&gt;enum&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;types&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;tupleFromTypes!(&lt;/span&gt;&lt;span style=&#34;color: #fec418&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color: #fec418&#34;&gt;double&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;string,&lt;/span&gt; &lt;span style=&#34;color: #fec418&#34;&gt;float&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;);&lt;/span&gt;
&lt;span style=&#34;color: #815ba4&#34;&gt;enum&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;sortedTypes&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;sort!((t1,&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;t2)&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;t1.type.sizeof&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;t2.type.sizeof)(types);&lt;/span&gt;
&lt;span style=&#34;color: #e7e9db&#34;&gt;writeln(sortedTypes);&lt;/span&gt;&lt;span style=&#34;color: #776e71&#34;&gt;// TypeTuple!(Type!(string), Type!(double), Type!(int), Type!(float))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

Now it is also trivial to get the maximum size
&lt;div class=&#34;highlight&#34; style=&#34;background: #2f1e2e&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #815ba4&#34;&gt;enum&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;types&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;tupleFromTypes!(&lt;/span&gt;&lt;span style=&#34;color: #fec418&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color: #fec418&#34;&gt;double&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;string,&lt;/span&gt; &lt;span style=&#34;color: #fec418&#34;&gt;float&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;);&lt;/span&gt;
&lt;span style=&#34;color: #815ba4&#34;&gt;enum&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;sortedTypes&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;sort!((t1,&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;t2)&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;t1.type.sizeof&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;t2.type.sizeof)(types);&lt;/span&gt;
&lt;span style=&#34;color: #815ba4&#34;&gt;enum&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;maxSize&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #e7e9db&#34;&gt;sortedTypes[&lt;/span&gt;&lt;span style=&#34;color: #f99b15&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;].sizeof;&lt;/span&gt;
&lt;span style=&#34;color: #e7e9db&#34;&gt;writeln(maxSize);&lt;/span&gt;&lt;span style=&#34;color: #776e71&#34;&gt;// 8 bytes&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Type Objects&lt;/code&gt; allow metaprogramming to look like normal functional programming just with types.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>The general design of my flawed compile time entity component system in C&#43;&#43;14</title>
      <link>http://replace-this-with-your-hugo-site.com/2016/01/14/entity-component-system</link>
      <pubDate>Thu, 14 Jan 2016 00:00:00 +0000</pubDate>
      
      <guid>http://replace-this-with-your-hugo-site.com/2016/01/14/entity-component-system</guid>
      <description>&lt;p&gt;{% highlight c++ %}
{% endhighlight %}
A lot of people are talking about entity component systems and how they could potentially improve your code base. Most of the articles are theoretical and it is hard to find examples that actually convey some advantages.&lt;/p&gt;

&lt;p&gt;There are actually a lot of entity component systems available for many different programming languages, but most seem to sacrifice performance for expressiveness.&lt;/p&gt;

&lt;p&gt;But I am curious and I really like the general idea of an entity component system but I don&amp;rsquo;t want to just accept the opinion of other game developers. It&amp;rsquo;s time to get some actual experience and I have implemented a very small entity component system in C++14 with template metaprogramming.&lt;/p&gt;

&lt;p&gt;This post will be about the general design of my entity component system.&lt;/p&gt;

&lt;p&gt;##Features&lt;/p&gt;

&lt;p&gt;The core features of my entity component system are:&lt;/p&gt;

&lt;p&gt;{% highlight c++ %}
Contiguous memory layout
Components are grouped at compile time
Compile time filtering of components
Components are always added in the correct group automatically
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;##Overview&lt;/p&gt;

&lt;p&gt;{% highlight c++ %}
struct world{
  //component_group &amp;lsquo;moveable_object&amp;rsquo;
  std::vector&lt;position&gt; moveable_object_position;
  std::vector&lt;velocity&gt; moveable_object_velocity;&lt;/p&gt;

&lt;p&gt;//component_group &amp;lsquo;entity&amp;rsquo;
  std::vector&lt;position&gt; entity_position;
  std::vector&lt;velocity&gt; entity_velocity;
  std::vector&lt;name&gt; entity_name;
  &amp;hellip;
};
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;This is the core of the entity component system, we group components together at compile time. The layout is called &lt;code&gt;SoA&lt;/code&gt; (structures of arrays) and a specific object is referred to by id.&lt;/p&gt;

&lt;p&gt;For example instead of having
{% highlight c++ %}
struct moveable_object{
  velocity vel;
  position pos;
};
std::vector&lt;moveable_object&gt; mv_objects;
{% endhighlight %}
we have
{% highlight c++ %}
std::vector&lt;position&gt; moveable_object_position;
std::vector&lt;velocity&gt; moveable_object_velocity;
{% endhighlight %}
And I refer to &lt;code&gt;moveable_object_position[index], moveable_object_velocity[index]&lt;/code&gt; as an object in this post.
{% highlight c++ %}
{% endhighlight %}
Each &lt;code&gt;component_group&lt;/code&gt; has a list of constrains, for example an &lt;code&gt;entity&lt;/code&gt; needs to have a &lt;code&gt;position&lt;/code&gt;, &lt;code&gt;velocity&lt;/code&gt; and &lt;code&gt;name&lt;/code&gt; component. The advantage of this approach is that filtering is essentially free, because we can just iterate over &lt;code&gt;entity_position&lt;/code&gt;,&lt;code&gt;entity_velocity&lt;/code&gt; and&lt;code&gt;entity_name&lt;/code&gt; at the same time. Another advantage is that we don&amp;rsquo;t have to worry about the memory layout as much, because we group everything at compile time.&lt;/p&gt;

&lt;p&gt;It is also possible to filter &lt;code&gt;component_groups&lt;/code&gt; based on the components they own. For example if we want to iterate over every &lt;code&gt;object&lt;/code&gt; that has a &lt;code&gt;position&lt;/code&gt; and &lt;code&gt;velocity&lt;/code&gt; component, we would have to iterate over &lt;code&gt;entity_position&lt;/code&gt;, &lt;code&gt;entity_velocity&lt;/code&gt; and &lt;code&gt;moveable_object_position&lt;/code&gt;, &lt;code&gt;moveable_object_velocity&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Obviously maintaining something like this by hand is extremely tedious. This is where metaprogramming will help us to convey our meaning. The following code snippet is a small example from my experimental entity component system.&lt;/p&gt;

&lt;p&gt;{% highlight c++ %}
struct position {
  float x, y;
};
struct velocity {
  float x, y;
};
struct name {
  std::string name;
};&lt;/p&gt;

&lt;p&gt;struct print_name {
  template &lt;class World&gt; void update(World&amp;amp; w) {
    w.template update&lt;name&gt;([](auto&amp;amp; name) { print(name.name); });
  }
};
struct print_pos_vel {
  template &lt;class World&gt; void update(World&amp;amp; w) {
    w.template update&lt;position, velocity&gt;([](auto&amp;amp; pos, auto&amp;amp; vel) {
      print(pos.x, pos.y);
      print(vel.x, vel.y);
    });
  }
};
auto make_monster(float x, float y, std::string n) {
  return hana::make_tuple(position{ x, y }, velocity{ 0, 0 }, name{ n });
}&lt;/p&gt;

&lt;p&gt;template &lt;class... Ts&gt;
using component_group_handle = ecs::core::component_group&amp;lt;
    breeze::util::container::handle_container, Ts&amp;hellip;&amp;gt;;&lt;/p&gt;

&lt;p&gt;int main() {
  using moveable_object = component_group_handle&lt;position, velocity&gt;;
  using entity = component_group_handle&lt;position, velocity, name&gt;;
  using cg = ecs::core::component_groups&lt;moveable_object, entity&gt;;
  auto w = ecs::core::world&lt;cg&gt;{};
  auto sg = ecs::core::make_systems_group(w, print_name{}, print_pos_vel{});
  w.add(make_monster(10, 5, &amp;ldquo;Monster3&amp;rdquo;));
  w.add(make_monster(11, 5, &amp;ldquo;Monster2&amp;rdquo;));
  w.add(position{ 42, 24 }, velocity{ 5, 5 }, name{ &amp;ldquo;Monster1&amp;rdquo; });&lt;/p&gt;

&lt;p&gt;// moveable_object
  w.add(position{ 0, 0 }, velocity{ 10, 5 });
  sg.update();
}
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;Don&amp;rsquo;t worry if you don&amp;rsquo;t understand what is going on, I&amp;rsquo;ll try to explain everything you need to know in the following section.&lt;/p&gt;

&lt;p&gt;{% highlight c++ %}
struct print_pos_vel {
  template &lt;class World&gt; void update(World&amp;amp; w) {
    w.template update&lt;position, velocity&gt;([](auto&amp;amp; pos, auto&amp;amp; vel) {
      print(pos.x, pos.y);
      print(vel.x, vel.y);
    });
  }
};
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;This is a simple system, which filters out every &lt;code&gt;component_group&lt;/code&gt;that does not have a &lt;code&gt;position&lt;/code&gt; and &lt;code&gt;velocity&lt;/code&gt; component, it then extracts the correct components for every &lt;code&gt;component_group&lt;/code&gt; that we are interested in. We then zip the iterators for &lt;code&gt;position&lt;/code&gt; and &lt;code&gt;velocity&lt;/code&gt; together and we repeat this for every &lt;code&gt;component_group&lt;/code&gt; that satisfies the &lt;code&gt;position&lt;/code&gt; and &lt;code&gt;velocity&lt;/code&gt; constrain. We are then left with a tuple of zipped iterators which we
concatenate into one big iterator. After that we can iterate over every &lt;code&gt;position&lt;/code&gt; and &lt;code&gt;velocity&lt;/code&gt; component and print it to the console.&lt;/p&gt;

&lt;p&gt;The only thing that is done at runtime is accessing the iterator for every component and concatenate them.&lt;/p&gt;

&lt;p&gt;{% highlight c++ %}
using moveable_object = component_group_handle&lt;position, velocity&gt;;
using entity = component_group_handle&lt;position, velocity, name&gt;;
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;These are our &lt;code&gt;component_groups&lt;/code&gt; which we have to declare once. Technically those could be inferred but I decided that it would serve as a good way to document all the different &lt;code&gt;component_groups&lt;/code&gt; that are used by the entity component system.
{% highlight c++ %}
using cg = ecs::core::component_groups&lt;moveable_object, entity&gt;;
auto w = ecs::core::world&lt;cg&gt;{};
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;After declaring all the &lt;code&gt;component_group&lt;/code&gt;&amp;rsquo;s that we want to use, we can finally create our &lt;code&gt;world&lt;/code&gt; object.&lt;/p&gt;

&lt;p&gt;The world object itself doesn&amp;rsquo;t do much and its purpose is to store our data.&lt;/p&gt;

&lt;p&gt;{% highlight c++ %}
auto sg = ecs::core::make_systems_group(w, print_name{}, print_pos_vel{});
&amp;hellip;
sg.update();
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;A &lt;code&gt;system_group&lt;/code&gt; just groups different systems together and allows to call &lt;code&gt;update&lt;/code&gt; on every system that has been registered at compile-time.&lt;/p&gt;

&lt;p&gt;{% highlight c++ %}
// entity
w.add(position{ 42, 24 }, velocity{ 5, 5 }, name{ &amp;ldquo;Monster1&amp;rdquo; });&lt;/p&gt;

&lt;p&gt;// moveable_object
w.add(position{ 0, 0 }, velocity{ 10, 5 });
{% endhighlight %}
Every &lt;code&gt;object&lt;/code&gt; is added into the correct &lt;code&gt;component_group&lt;/code&gt;. If you call add with &lt;code&gt;&amp;lt;position, velocity&amp;gt;&lt;/code&gt; it will look at all the &lt;code&gt;component_group&lt;/code&gt;&amp;rsquo;s and that were declared before and insert it into the correct one.
Because we have declared &lt;code&gt;using moveable_object = component_group_handle&amp;lt;position, velocity&amp;gt;;&lt;/code&gt;  the components &lt;code&gt;w.add(position{ 0, 0 }, velocity{ 10, 5 });&lt;/code&gt; will be inserted into the &lt;code&gt;component_group&lt;/code&gt; &lt;code&gt;moveable_object&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Deleting &lt;code&gt;objects&lt;/code&gt; is also very simple. Because we have grouped everything at compile-time, we just have to look at the &lt;code&gt;component_group&lt;/code&gt; that the object belongs to and delete it. To preserve contiguous elements we swap the last element with the element that we want to delete and then we simply remove the last element.&lt;/p&gt;

&lt;p&gt;Most entity component system allow to add and remove components from &lt;code&gt;objects&lt;/code&gt; at runtime. If we want to take a &lt;code&gt;moveable_object&lt;/code&gt; and add a &lt;code&gt;name&lt;/code&gt; component, it would become an &lt;code&gt;entity&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We would need to move the components from the &lt;code&gt;component_group&lt;/code&gt; &lt;code&gt;moveable_object&lt;/code&gt; to the &lt;code&gt;component_group&lt;/code&gt; &lt;code&gt;entity&lt;/code&gt; and add then simply add the &lt;code&gt;name&lt;/code&gt; component.&lt;/p&gt;

&lt;p&gt;##Dealbreaker&lt;/p&gt;

&lt;p&gt;The biggest problem is the compilation time. Every query of update &lt;code&gt;w.template update&amp;lt;T0,T1,...TN&amp;gt;&lt;/code&gt; costs around 2 seconds on my machine, that is just unacceptable.&lt;/p&gt;

&lt;p&gt;You can find the code &lt;a href=&#34;https://github.com/BreezeEngine/breeze/blob/master/src/ecs/core/core.hpp&#34;&gt;here&lt;/a&gt; and &lt;a href=&#34;https://github.com/BreezeEngine/breeze/blob/master/examples/ecs/main.cpp&#34;&gt;here&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Please note that the code is in a highly experimental state and will most likely not even compile on your machine.&lt;/p&gt;

&lt;p&gt;##What have I learned?
I really love metaprogramming in C++ with &lt;a href=&#34;https://github.com/boostorg/hana&#34;&gt;hana&lt;/a&gt;. It is expressive, concise and doesn&amp;rsquo;t look odd if you are familiar with functional conecpts.&lt;/p&gt;

&lt;p&gt;Compile errors are horrifying and tools for compile-time debugging/profiling are pretty much non existent.&lt;/p&gt;

&lt;p&gt;Compile times can quickly blow up and it&amp;rsquo;s hard to track down where and why they are blowing up.&lt;/p&gt;

&lt;p&gt;I don&amp;rsquo;t think the entity component system that I envision is practical to create in C++ and I will most likely abandon it. I am not quite ready the abandon the idea and I will try to create a similar entity component system in &lt;code&gt;D&lt;/code&gt;.
{% highlight c++ %}
{% endhighlight %}
{% highlight c++ %}
{% endhighlight %}
{% highlight c++ %}
{% endhighlight %}
{% highlight c++ %}
{% endhighlight %}
{% highlight c++ %}
{% endhighlight %}
{% highlight c++ %}
{% endhighlight %}
{% highlight c++ %}
{% endhighlight %}
{% highlight c++ %}
{% endhighlight %}
{% highlight c++ %}
{% endhighlight %}
{% highlight c++ %}
{% endhighlight %}
{% highlight c++ %}
{% endhighlight %}&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Type safe OpenGL - Converting strings into types in D</title>
      <link>http://replace-this-with-your-hugo-site.com/2015/11/14/converting-strings-to-types</link>
      <pubDate>Sat, 14 Nov 2015 00:00:00 +0000</pubDate>
      
      <guid>http://replace-this-with-your-hugo-site.com/2015/11/14/converting-strings-to-types</guid>
      <description>&lt;p&gt;Writing glsl code is usually not that hard but it is easy to make mistakes, especially if you are changing some glsl files and forgetting to update the OpenGL calls.&lt;/p&gt;

&lt;p&gt;We will parse a glsl shader and extract the types as a string at compile time, then we use those strings to create actual types. After we have obtained the types we will generate a wrapper for that glsl shader at compile time.&lt;/p&gt;

&lt;p&gt;The benefit is that we will get a nice interface that won&amp;rsquo;t allow you to make any mistakes. Another benefit will be that if the glsl shader changes the wrapper will change too, which helps you to keep the code in sync by generating helpful compiler errors.&lt;/p&gt;

&lt;p&gt;In this blog post we will learn how we can turn strings into actual types at compile time.
{% highlight d %}
&amp;hellip;
in vec2 fragTexCoord;
in vec3 fragNormal;
in vec3 fragVert;
&amp;hellip;
[&amp;ldquo;vec2&amp;rdquo;,&amp;ldquo;vec3&amp;rdquo;,&amp;ldquo;vec3&amp;rdquo;] to AliasSeq!(Vector2,Vector2,Vector3)
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;{% highlight d %}
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;{% highlight d %}
{% endhighlight %}
Converting strings to types is very easy in D
{% highlight d %}
template glslStringtoTypeV1(string stringType){
  static if(stringType == &amp;ldquo;int&amp;rdquo;){
    alias glslStringtoTypeV1 = int;
  }
  else static if(stringType == &amp;ldquo;float&amp;rdquo;){
    alias glslStringtoTypeV1 = float;
  }
}
void main()
{
  glslStringtoTypeV1!&amp;ldquo;float&amp;rdquo; f; //f is of type float
}
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;But &lt;a href=&#34;https://www.opengl.org/registry/doc/GLSLangSpec.4.40.pdf&#34;&gt;glsl has actually quite a few types&lt;/a&gt; and it would be annoying to  write that many &lt;code&gt;static if&lt;/code&gt; blocks.&lt;/p&gt;

&lt;p&gt;D also has template specializations like C++, maybe this would make the code easier to write?&lt;/p&gt;

&lt;p&gt;{% highlight d %}
template glslStringtoTypeV2(string s){
  static assert(false, s ~ &amp;ldquo; is not a GLSL type&amp;rdquo;);
}
template glslStringtoTypeV2(string s: &amp;ldquo;int&amp;rdquo;){
  alias glslStringtoTypeV2 = int;
}
template glslStringtoTypeV2(string s: &amp;ldquo;float&amp;rdquo;){
  alias glslStringtoTypeV2 = float;
}
void main()
{
  glslStringtoTypeV2!&amp;ldquo;float&amp;rdquo; f; //f is of type float
}
{% endhighlight %}
The nice thing about D is that we can pass almost any value into a template, in this case we use &lt;code&gt;string&lt;/code&gt;. I think the code already looks much easier to write and read but it still has a lot of noise. Maybe we can reduce the noise with &lt;code&gt;template mixins&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Template mixins&lt;/code&gt; allow you to expand a template with the &lt;code&gt;mixin&lt;/code&gt; keyword.&lt;/p&gt;

&lt;p&gt;{% highlight d %}
mixin template AddShader(T,string stringType){
  template glslStringtoTypeV2(string s: stringType){
    alias glslStringtoTypeV2 = T;
  }
}
template glslStringtoTypeV2(string s){
  static assert(false, s ~ &amp;ldquo; is not a GLSL type&amp;rdquo;);
}
mixin AddShader!(int,&amp;ldquo;int&amp;rdquo;);
mixin AddShader!(int,&amp;ldquo;float&amp;rdquo;);
void main()
{
  glslStringtoTypeV2!&amp;ldquo;float&amp;rdquo; f; //err
}
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;This looks much better unfortunately this doesn&amp;rsquo;t compile because &lt;code&gt;template mixins&lt;/code&gt; expand into a different scope. D also allows us to insert strings at compile time with &lt;code&gt;mixins&lt;/code&gt;. You can think of them like macros from C but they are more powerful because they are ordinary strings which can be manipulated.&lt;/p&gt;

&lt;p&gt;{% highlight d %}
template AddShader(T,string stringType){
  enum AddShader =
    &amp;ldquo;template glslStringtoTypeV2(string s: &amp;ldquo;~stringType.stringof~&amp;ldquo;){
         alias glslStringtoTypeV2 = &amp;ldquo; ~ T.stringof ~ &amp;ldquo;;&amp;rdquo; ~
    &amp;ldquo;}&amp;rdquo;;
}
template glslStringtoTypeV2(string s){
  static assert(false, s ~ &amp;ldquo; is not a GLSL type&amp;rdquo;);
}
mixin(AddShader!(int,&amp;ldquo;int&amp;rdquo;));
mixin(AddShader!(float,&amp;ldquo;float&amp;rdquo;));&lt;/p&gt;

&lt;p&gt;void main()
{
  glslStringtoTypeV2!&amp;ldquo;float&amp;rdquo; f; //f is of type float
}
{% endhighlight %}
This is almost as nice as &lt;code&gt;template mixins&lt;/code&gt; but I am not the biggest fan of writing source code as a string. Maybe there is still some room for improvement.&lt;/p&gt;

&lt;p&gt;{% highlight d %}
struct ShaderType(T,string s){
  alias Type = T;
  enum string stringType = s;
}
enum isShaderType(T) = std.traits.isInstanceOf!(ShaderType,T);&lt;/p&gt;

&lt;p&gt;template StringTypeGen(string stringType, ShaderTypes&amp;hellip;)
  if(allSatisfy!(isShaderType, ShaderTypes)
     &amp;amp;&amp;amp; ShaderTypes.length &amp;gt; 0)
{
  static if(ShaderTypes[0].stringType == stringType ){
    alias StringTypeGen = ShaderTypes[0].Type;
  }
  else static if(ShaderTypes.length == 1){
    static assert(false,stringType ~ &amp;ldquo; is not a recognized type.&amp;rdquo;);
  }
  else{
    alias StringTypeGen = StringTypeGen!(stringType, ShaderTypes[1..$]);
  }
}
struct Matrix3{}
struct Vector3{}
alias glslStringToType(string s) = StringTypeGen!(s
    ,ShaderType!(int, &amp;ldquo;int&amp;rdquo;)
    ,ShaderType!(float, &amp;ldquo;float&amp;rdquo;)
    ,ShaderType!(double, &amp;ldquo;double&amp;rdquo;)
    ,ShaderType!(uint, &amp;ldquo;uint&amp;rdquo;)
    ,ShaderType!(bool, &amp;ldquo;bool&amp;rdquo;)
    ,ShaderType!(Matrix3, &amp;ldquo;mat3&amp;rdquo;)
    ,ShaderType!(Vector3, &amp;ldquo;vec3&amp;rdquo;)
    //&amp;hellip;.
);
void main()
{
  glslStringToType!&amp;ldquo;float&amp;rdquo; f; //f is of type float
}
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;This is the final version which was a bit more work to create but it&amp;rsquo;s easy to add glsl types, has nice error messages and is reusable. The last missing part is how we can turn a list of strings into a list of types.&lt;/p&gt;

&lt;p&gt;{% highlight d %}
void main()
{
  alias VertexInput = AliasSeq!(&amp;ldquo;mat3&amp;rdquo;,&amp;ldquo;int&amp;rdquo;,&amp;ldquo;vec3&amp;rdquo;,&amp;ldquo;double&amp;rdquo;);
  alias VertexInputTypes = staticMap!(glslStringToType,VertexInput);
  //VertexInputTypes is of type AliasSeq!(Matrix3,int,Vector3,double)
}
{% endhighlight %}&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Metaprogramming in D - From a beginner&#39;s perspective</title>
      <link>http://replace-this-with-your-hugo-site.com/2015/08/11/metaprogramming-d</link>
      <pubDate>Tue, 11 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>http://replace-this-with-your-hugo-site.com/2015/08/11/metaprogramming-d</guid>
      <description>&lt;p&gt;{% highlight d %}
Disclaimer: I have only started learning D a few days ago and I wanted to document my experience.
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;Let us create a small gameplay framework that can update &lt;code&gt;GameObjects&lt;/code&gt;. Sometimes you will see that &lt;code&gt;GameObjects&lt;/code&gt; are stored in a vector using some kind of pointers.&lt;/p&gt;

&lt;p&gt;{% highlight d %}
std::vector&lt;GameObjects*&gt;;
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;There are a few problems with this code, one problem would be that only the pointers are stored contiguously in memory. This could lead to a memory fragmentation problem which could be solved by using a custom allocator. Another problem is that only the pointers are prefetched and not the objects themselves which might result in a performance penalty.&lt;/p&gt;

&lt;p&gt;We are going to address this problem in D with metaprogramming. Every &lt;code&gt;GameObject&lt;/code&gt; will get it&amp;rsquo;s own container.&lt;/p&gt;

&lt;p&gt;{% highlight d %}
struct Engine{
  std::vector&lt;Monster&gt; monsters;
  std::vector&lt;Player&gt; players;
  &amp;hellip;
  void updateAll(){
    for(auto&amp;amp; player: players){
      player.update();
    }
    for(auto&amp;amp; monster: monsters){
      monster.update();
    }
    &amp;hellip;
  }
};
{% endhighlight %}
You could do this by hand, but it would be very tedious and error prone. This could be easily implemented in C++ but from now on we will make use of D&amp;rsquo;s metaprogramming features. Don&amp;rsquo;t worry if you don&amp;rsquo;t understand every thing, I will go over everything in detail.
{% highlight d %}
class Engine(alias Container, GameObjects&amp;hellip;){
  alias GameObjectsContainer = staticMap!(Container, GameObjects);
  GameObjectsContainer gameObjectsContainer;&lt;/p&gt;

&lt;p&gt;ref Container!T getContainer(T)(){
    enum indexOfT = IndexOf!(T, GameObjects);
    return gameObjectsContainer[indexOfT];
  }&lt;/p&gt;

&lt;p&gt;ref T getGameObject(T)(Handle!T handle){
    return getContainer!T()[handle.id];
  }&lt;/p&gt;

&lt;p&gt;Handle!T spawn(T)(T t){
    return Handle!T(getContainer!T().insertBack(t) - 1);
  }&lt;/p&gt;

&lt;p&gt;void updateAll(){
    foreach(container;gameObjectsContainer){
      foreach(gameobject;container){
        gameobject.update();
      }
    }
  }
}
struct Handle(T){
  size_t id;
  this(size_t id){
    this.id = id;
  }
}
{% endhighlight %}
It can be used like this:
{% highlight d %}
struct Monster{
  string name;
  this(string name){
    this.name = name;
  }
  void update(){
    writeln(&amp;ldquo;Updating Monster: &amp;ldquo;, name);
  }
}
struct Player{
  string name;
  this(string name){
    this.name = name;
  }
  void update(){
    writeln(&amp;ldquo;Updating Player: &amp;ldquo;, name);
  }
}
void main()
{
  alias GameObjects = AliasSeq!(Monster, Player);
  alias ArrayEngine = Engine!(Array, GameObjects);
  auto engine = new ArrayEngine;
  auto monster1Id = engine.spawn(Monster(&amp;ldquo;Monster1&amp;rdquo;));
  auto player1Id = engine.spawn(Player(&amp;ldquo;Player1&amp;rdquo;));
  auto monster2Id = engine.spawn(Monster(&amp;ldquo;Monster2&amp;rdquo;));
  auto player2Id = engine.spawn(Player(&amp;ldquo;Player2&amp;rdquo;));&lt;/p&gt;

&lt;p&gt;writeln(monster1Id);
  Monster monster1 = engine.getGameObject(monster1Id);
  engine.updateAll();&lt;/p&gt;

&lt;p&gt;}
{% endhighlight %}
Output:
{% highlight d %}
Updating Monster: Monster1
Updating Monster: Monster2
Updating Player: Player1
Updating Player: Player2
{% endhighlight %}
I am aware that this code won&amp;rsquo;t win any awards, I tried to keep it simple and short and don&amp;rsquo;t go into specifics like invalidating the handles.&lt;/p&gt;

&lt;p&gt;{% highlight d %}
class Engine(alias Container, GameObjects&amp;hellip;){
  alias GameObjectsContainer = staticMap!(Container, GameObjects);
  GameObjectsContainer gameObjectsContainer;
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;This is the heart of our &lt;code&gt;Engine&lt;/code&gt; class and it makes use of type-level metaprogramming. Everything in the parentheses are &lt;code&gt;templates&lt;/code&gt; while &lt;code&gt;Container&lt;/code&gt;is a symbol and &lt;code&gt;GameObjects...&lt;/code&gt; is a variadic template.&lt;/p&gt;

&lt;p&gt;{% highlight d %}
(alias Container, GameObjects&amp;hellip;)&lt;/p&gt;

&lt;p&gt;{% endhighlight %}
&lt;code&gt;Container&lt;/code&gt; will be our type function which will transform a type into a container of that type. For example it will transform from &lt;code&gt;T to Container!T&lt;/code&gt;. Note the &lt;code&gt;!&lt;/code&gt; in D is a template invocation. In C++ you would use &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;.
&lt;code&gt;map&lt;/code&gt; is usually well know to functional programmers, it takes a list and a function and applies that function to every element of that list. &lt;code&gt;staticMap&lt;/code&gt; is a &lt;code&gt;map&lt;/code&gt; for types and type values.&lt;/p&gt;

&lt;p&gt;{% highlight d %}
  alias GameObjectsContainer = staticMap!(Container, GameObjects);
{% endhighlight %}
If we call &lt;code&gt;staticMap&lt;/code&gt; with &lt;code&gt;AliasSeq!(Monster, Player, Weapon)&lt;/code&gt; as our list of types and &lt;code&gt;Container&lt;/code&gt; as the type level function. The resulting type would be &lt;code&gt;AliasSeq!(Container!(Monster), Container!(Player), Container!(Weapon))&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;D has a thin wrapper for variadic sequences called &lt;code&gt;AliasSeq&lt;/code&gt;. If you are coming from C++ this would roughly be
{% highlight d%}
template&lt;class ...Ts&gt;
struct AliasSeq{};
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;We now have a small problem, we can not access &lt;code&gt;gameObjectsContainer&lt;/code&gt; directly and we need to create a small helper function.
{% highlight d %}
ref Container!T getContainer(T)(){
  enum indexOfT = IndexOf!(T, GameObjects);
  return gameObjectsContainer[indexOfT];
}
{% endhighlight %}
&lt;code&gt;IndexOf&lt;/code&gt; is also a metafunction that will take a type and a type sequence and will return the index to the first occurrence of the type in the type sequence. After we have obtained the index we are able to access the container that we want with &lt;code&gt;gameObjectsContainer[indexOfT]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Spawning &lt;code&gt;GameObjects&lt;/code&gt; is very simple.
{% highlight d %}
Handle!T spawn(T)(T t){
  return Handle!T(getContainer!T().insertBack(t) - 1);
}
{% endhighlight %}
We instantiate a &lt;code&gt;GameObject&lt;/code&gt; and pass it to the spawn function. The spawn function knows the type of the &lt;code&gt;GameObject&lt;/code&gt; which allows us to access the right container with &lt;code&gt;getContainer&lt;/code&gt;. After that we just insert the &lt;code&gt;GameObject&lt;/code&gt; at the end of the container. We then wrap the index in a &lt;code&gt;Handle!T&lt;/code&gt;, which prevents accidental access of a wrong container.&lt;/p&gt;

&lt;p&gt;{% highlight d %}
ref T getGameObject(T)(Handle!T handle){
  return getContainer!T()[handle.id];
}
{% endhighlight %}
Because a &lt;code&gt;Handle&lt;/code&gt; stores the type of the &lt;code&gt;GameObject&lt;/code&gt; we can just use the type to access the right container and retrieve the our &lt;code&gt;GameObject&lt;/code&gt;.
{% highlight d %}
void updateAll(){
  foreach(container;gameObjectsContainer){
    foreach(gameobject;container){
      gameobject.update();
    }
  }
}
{% endhighlight %}
The first forloop loops over all containers at compile time, the second for loop will update every &lt;code&gt;GameObject&lt;/code&gt; at run time.&lt;/p&gt;

&lt;p&gt;We are now storing every &lt;code&gt;GameObject&lt;/code&gt; in its own container which gives us several benefits. All &lt;code&gt;GameObjects&lt;/code&gt; are stored contiguously in memory without any indirection and we have now a lot of type information. It&amp;rsquo;s is now very simple to loop over all &lt;code&gt;Monsters&lt;/code&gt;, or maybe you want to apply damage to nearby players.&lt;/p&gt;

&lt;p&gt;Usually when I learn a new language I also try to come up with some strange ideas to see how the language will behave with not so common problems.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Goal:&lt;/code&gt; Create a function that takes a variable length of arguments and creates the sum of all integers and the sum of all floats.&lt;/p&gt;

&lt;p&gt;Example:
{% highlight d %}
writeln(sumIntFloat(1, 2.0f, 3, 4.0f, 5.0f, 6, 7));
//Tuple!(int, float)(17, 11)
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;The first version of this function is rather elegant:
{% highlight d %}
enum isIntegral(alias i) = std.traits.isIntegral!(typeof(i));
enum isFloatingPoint(alias f) = std.traits.isFloatingPoint!(typeof(f));
Tuple!(int, float) sumIntFloat(Ts&amp;hellip;)(Ts ts){
  int intSum = Filter!(isIntegral, ts)
    .only()
    .reduce!((a,b) =&amp;gt; a + b);
  float floatSum = Filter!(isFloatingPoint, ts)
    .only()
    .reduce!((a,b) =&amp;gt; a + b);
  return tuple(intSum, floatSum);
}
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;&lt;code&gt;isIntegral&lt;/code&gt; will take a value and check with &lt;code&gt;typeof&lt;/code&gt; if it is an integer. &lt;code&gt;Filter&lt;/code&gt; is a metafuction that will filter our variadic sequence &lt;code&gt;Ts...&lt;/code&gt;. Combining &lt;code&gt;Filter&lt;/code&gt; with &lt;code&gt;isIntegral&lt;/code&gt; will filter the sequence &lt;code&gt;Ts...&lt;/code&gt; so that it will only contain integer values. &lt;code&gt;only()&lt;/code&gt; transforms the sequence to a &lt;a href=&#34;http://dlang.org/phobos/std_range.html&#34;&gt;range&lt;/a&gt; which allows us to reuse functions from &lt;a href=&#34;http://dlang.org/phobos/std_algorithm.html&#34;&gt;std.algorithm&lt;/a&gt; like &lt;code&gt;reduce&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;I think it looks quite elegant but sadly &lt;code&gt;only()&lt;/code&gt; will result in a copy. Let us see if we can improve on that.&lt;/p&gt;

&lt;p&gt;Before we start, let us generalize our isIntegral and isFloatingPoint &amp;ldquo;functions&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;{% highlight d %}
static template Is(T){
   enum SameAs(alias t) = is(T == typeof(t));
}
{% endhighlight %}
We can call it like this
{% highlight d %}
int i;
float f;
Is!float.SameAs(f);
Is!int.SamAs(i);
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;Sequences can be wrapped in an &lt;code&gt;AliasSeq&lt;/code&gt; as we have seen before.&lt;/p&gt;

&lt;p&gt;{% highlight d %}
alias IntFloatString = AliasSeq!(int, float, string);
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;But it is also possible to actually pass values into templates&lt;/p&gt;

&lt;p&gt;{% highlight d %}
alias IntFloatString = AliasSeq!(1, 2.0f, &amp;ldquo;Hello World&amp;rdquo;);
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;We need to create a new functon that takes a sequence and produces a value, just like &lt;code&gt;reduce&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;{% highlight d %}
template staticFold(alias Func, alias B, Ts&amp;hellip;){
  static if(Ts.length == 0){
    alias staticFold = B;
  }
  else{
    alias staticFold = staticFold!(Func, Func!(B,Ts[0]), Ts[1..$]);
  }
}
{% endhighlight %}
Personally I think that the &lt;code&gt;[1..$]&lt;/code&gt; is rather elegant and will simplify the code greatly compared to C++ where you have to great another template.&lt;/p&gt;

&lt;p&gt;It can be used like this:
{% highlight d %}
template Sum(alias A, alias B){
  alias Sum = AliasSeq!(A + B);
}
template SumIntFloatV2(Ts&amp;hellip;){
  alias IntSum   = staticFold!(Sum, 0, Filter!(Is!int.SameAs, Ts));
  alias FloatSum = staticFold!(Sum, 0.0f, Filter!(Is!float.SameAs, Ts));
}
void main()
{
  alias IntFloat = SumIntFloatV2!(1, 2.0f, 3, 4.0f, 5.0f, 6, 7);
  writeln(IntFloat.IntSum);
  writeln(IntFloat.FloatSum);
}
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;This doesn&amp;rsquo;t look so bad either, but there are also a few problems. First, we have to write our &lt;code&gt;Sum&lt;/code&gt; function as a template and the second problem is that we can only use this at compile time.&lt;/p&gt;

&lt;p&gt;But one of D&amp;rsquo;s features is to be able to evaluate almost any function at compile time so it should be possible to create a function that works at compile time as well as at run time.&lt;/p&gt;

&lt;p&gt;This led to me ask a &lt;a href=&#34;http://stackoverflow.com/a/33588960/944430&#34;&gt;question&lt;/a&gt; on StackOverflow.&lt;/p&gt;

&lt;p&gt;{% highlight d %}
struct Answer {
        int IntSum = 0;
        float FloatSum = 0.0;
}
Answer SumIntFloatV4(Ts&amp;hellip;)(Ts ts) {
        Answer a;
        foreach(t; ts) {
                static if(is(typeof(t) == int))
                        a.IntSum += t;
                else static if(is(typeof(t) == float))
                        a.FloatSum += t;
        }&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    return a;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;void main() {
        // compile time
        pragma(msg, SumIntFloatV4(1,1.0,2,3,2.0,3.0));
        pragma(msg, SumIntFloatV4(1,1,2,3,1.0,2.0));
        // runtime
        import std.stdio;
        writeln(SumIntFloatV4(1,1.0,2,3,2.0,3.0));
        writeln(SumIntFloatV4(1,1,2,3,1.0,2.0));
}
{% endhighlight %}
I knew before hand that I could do it like this but in my opinion this looks much worse compared to version 1 and 2. I really wanted to reuse staticFold in my run time version but it didn&amp;rsquo;t seem possible and I almost quit.&lt;/p&gt;

&lt;p&gt;Luckily I went back to the drawing board and redefined what my goal was.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Goal:&lt;/code&gt; Generate an efficient function at compile time that can be called at run/compile time.&lt;/p&gt;

&lt;p&gt;With a much better defined goal I was able to create a new version of &lt;code&gt;staticFold&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;{% highlight d %}
B fold(F, B, Ts&amp;hellip;)(F f, B init, Ts ts){
  static if(ts.length == 0){
    return init;
  }
  else{
    return fold(f, f(init, ts[0]), ts[1..$]);
  }
}
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;{% highlight d %}
Tuple!(int, float) sumIntFloatV3(Ts&amp;hellip;)(Ts ts){
  int intSum = fold((int a, int b) =&amp;gt; a + b
                   ,0, Filter!(Is!int.SameAs, ts));
  float floatSum = fold((float a, float b) =&amp;gt; a + b
                   ,0.0f, Filter!(Is!float.SameAs, ts));
  return tuple(intSum, floatSum);
}
void main()
{
  writeln(sumIntFloatV3(1, 2.0f, 3, 4.0f, 5.0f, 6, 7));
}
{% endhighlight %}
The nice thing about &lt;code&gt;fold&lt;/code&gt; is that it can be called with almost anything.&lt;/p&gt;

&lt;p&gt;{% highlight d %}
void main()
{
  writeln(sumIntFloatV3(AliasSeq!(1, 2.0f, 3.0f)));
  auto t = tuple(1, 2, 3, 4.0f, 5.0f);
  writeln(sumIntFloatV3(t.expand));
  int i = 5;
  int i2 = 10;
  float f = 5.0f;
  float f2 = 10.0f;
  writeln(sumIntFloatV3(i, f, i2, f2));
}
{% endhighlight %}
I have experimented a lot metaprogramming in various languages. For example macros, AST manipulation, two phase compilation with substitution and I think that template metaprogramming in D is rather elegant.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Gamedev Math: Vector projection</title>
      <link>http://replace-this-with-your-hugo-site.com/2015/07/30/unreal-math</link>
      <pubDate>Thu, 30 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>http://replace-this-with-your-hugo-site.com/2015/07/30/unreal-math</guid>
      <description>&lt;p&gt;Today we will learn how we can project a vector onto another vector.&lt;/p&gt;

&lt;p&gt;Vector projection is defined in UE4 like this:&lt;/p&gt;

&lt;p&gt;{% highlight c++ %}
FORCEINLINE FVector FVector::ProjectOnTo( const FVector&amp;amp; A ) const
{
    return (A * ((*this | A) / (A | A)));
}
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;Depending on your familiarity with math or UE4 this can look at bit strange to you.&lt;/p&gt;

&lt;p&gt;The | operator in UE4 is defined as the &lt;a href=&#34;https://en.wikipedia.org/wiki/Dot_product&#34;&gt;dot product&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Also there exists an interesting equality for the dot product, which you can get by using the &lt;a href=&#34;https://en.wikipedia.org/wiki/Law_of_cosines&#34;&gt;Law of Cosines&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;$$\vec{a} {\cdot} \vec{b}= ||\vec{a}|| * ||\vec{b}|| * cos(\alpha)$$&lt;/p&gt;

&lt;p&gt;The notation \( ||\vec{v}|| \) is known as the &lt;a href=&#34;https://en.wikipedia.org/wiki/Euclidean_vector#Length&#34;&gt;length of a vector&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;{{ site.url }}/assets/pictures/math-vector-projection.png&#34; alt=&#34;proj&#34; /&gt;&lt;/p&gt;

&lt;p&gt;We want to project \( \vec{a}\) onto \( \vec{b}\). The yellow \( \vec{p}\) is the vector that we are interested in and as you can see they form a right angled triangle.&lt;/p&gt;

&lt;p&gt;First let me show you a regular triangle&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;{{ site.url }}/assets/pictures/triangle.png&#34; alt=&#34;triangle&#34; /&gt;&lt;/p&gt;

&lt;p&gt;$$ cos(\alpha) = \dfrac{adjacent}{hypotenuse}$$&lt;/p&gt;

&lt;p&gt;or&lt;/p&gt;

&lt;p&gt;$$ cos(\alpha) = \dfrac{b}{a}$$&lt;/p&gt;

&lt;p&gt;If we know \(a\) and \(cos(\alpha)\) we can easily compute the value of \(b\)&lt;/p&gt;

&lt;p&gt;$$ cos(\alpha) * a = b $$&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s get back to the dot product&lt;/p&gt;

&lt;p&gt;$$\vec{a} {\cdot} \vec{b}= ||\vec{a}|| * ||\vec{b}|| * cos(\alpha)$$&lt;/p&gt;

&lt;p&gt;which is the same thing as&lt;/p&gt;

&lt;p&gt;$$cos(\alpha) * ||\vec{a}|| = \dfrac{\vec{a} {\cdot} \vec{b}} {||\vec{b}||}$$&lt;/p&gt;

&lt;p&gt;Now remember that we can compute \(b\) in a triangle&lt;/p&gt;

&lt;p&gt;$$ cos(\alpha) * a = b $$&lt;/p&gt;

&lt;p&gt;which means that we can use $$\dfrac{\vec{a} {\cdot} \vec{b}} {||\vec{b}||} = ||\vec{p}|| $$ to compute the length of our projected vector \( \vec{p} \).&lt;/p&gt;

&lt;p&gt;By &lt;a href=&#34;https://en.wikipedia.org/wiki/Unit_vector&#34;&gt;normalizing&lt;/a&gt; \( \vec{b}\) and multiplying it by our computed length we get \( \vec{p} \).&lt;/p&gt;

&lt;p&gt;$$ \vec{p} = \dfrac{\vec{b}}{||\vec{b}||} * \dfrac{\vec{a} {\cdot} \vec{b}} {||\vec{b}||} =  \vec{b}* \dfrac{\vec{a} {\cdot} \vec{b}} {||\vec{b}||^2} =  \vec{b}* \dfrac{\vec{a} {\cdot} \vec{b}} {\vec{b} {\cdot} {\vec{b}} }$$&lt;/p&gt;

&lt;p&gt;{% highlight c++ %}
FORCEINLINE FVector FVector::ProjectOnTo( const FVector&amp;amp; A ) const
{
    return (A * ((*this | A) / (A | A)));
}
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;I hope that you understand now how this function works.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Unreal Engine 4 vs Unity 5 (Part 1)</title>
      <link>http://replace-this-with-your-hugo-site.com/2015/07/20/unreal-vs-unity</link>
      <pubDate>Mon, 20 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>http://replace-this-with-your-hugo-site.com/2015/07/20/unreal-vs-unity</guid>
      <description>&lt;p&gt;#Debugging
Debugging is very important for me, I want to know every thing that happens in my application.
In UE4 you can just hit F5 and start the editor in debug mode. You can still change the code but unfortunately you can not compile in VS while you are debugging. Luckily you can compile the game code within the editor which makes development a breeze because you can set breakpoints at any time that you like and it just works.&lt;/p&gt;

&lt;p&gt;Debugging even works in a networked game which is super awesome. Consider the following scenario, 4 clients one server and you set a breakpoint at a function that is called on all clients.&lt;/p&gt;

&lt;p&gt;The breakpoint will trigger 4 times. At any point you can inspect any value that you like.&lt;/p&gt;

&lt;p&gt;Unity has also the possibility to debug game code but it is not as streamlined as in UE4. There is a plugin called &amp;lsquo;UnityVS&amp;rsquo; which can attach itself to either the editor or to a standalone game. Unfortunately the debugger is very slow on my machine, if I attach UnityVS to the editor and hit play it will take around 10 seconds to enter the playmode.&lt;/p&gt;

&lt;p&gt;Also it seems you can only debug one instance at a time which is a bit annoying if you are creating a networked game. UnityVS doesn&amp;rsquo;t allow you to edit the code while you are debugging.&lt;/p&gt;

&lt;p&gt;#Stability
This is actually a very strange point, I would consider Unity as well as UE4 to be somewhat unstable. It only took me 2 days to corrupt my project in Unity and I wasn&amp;rsquo;t able to fix it easily. After a few hours of fiddling around I was able to find the culprit. I had written myself a custom tool that built a standalone game inside the asset folder which results in some very strange error messages to say the least.
Unity also crashed several times while I was developing my editor script.&lt;/p&gt;

&lt;p&gt;UE4 has frequent editor crashes and the hot reloading system is not very reliable. Changes to blueprints sometimes just don&amp;rsquo;t get detected which means that you have to restart the editor very often. The same thing applies to C++ changes but at least you get a visual representation that something is wrong because the compile button in the editor will have disappeared.&lt;/p&gt;

&lt;p&gt;UE4 always crashes when you mess up. For example if you forgot to do a nullptr check and you access a nullptr the editor will crash.You should always be in debug mode because you get very weird messages if you are not.&lt;/p&gt;

&lt;p&gt;I haven&amp;rsquo;t had a code crash in Unity so far. If you access a nullptr in Unity it will just log it.&lt;/p&gt;

&lt;p&gt;#Project Upgrades
This is a major downside for UE4. Every time Epic release a minor version upgrade something breaks in some unexpected ways. My only recommendation is too wait and stay at least one version behind. For example if 4.9 is released you should upgrade from 4.7 to 4.8. At least by then the community will have found some common issues. Also you should probably never upgrade to a newly released version like 4.8.0 unless it includes a must have feature. Those versions are usually very
buggy.&lt;/p&gt;

&lt;p&gt;I recently upgraded from 4.7.6 to 4.8.1 and I only recognized that the compile times were much slower after a few weeks and switching back to 4.7.6 would require some changes.&lt;a href=&#34;https://forums.unrealengine.com/showthread.php?75217-Slower-build-times-in-4-8&#34;&gt;Link to the forum post&lt;/a&gt;
The problem was that Epic forgot to integrate some changes from 4.7 to 4.8 which results in longer compile times. They went up from 7sec to 18sec on my machine.&lt;/p&gt;

&lt;p&gt;Unfortunately I have never upgraded a project in Unity but I would assume that this only happens in major version upgrades.&lt;/p&gt;

&lt;p&gt;#Accessible Source
Open/Accessible source is very important for me because if I have a problem I need to solve it myself. It is also very helpful to understand how the API is working. To be very honest I don&amp;rsquo;t even have the whole source code of UE4 on my machine because those millions lines of C++ in Visual Studio is just too much for my tiny processor.&lt;/p&gt;

&lt;p&gt;But it is very nice to have the source of the gameplay framework and I am constantly browsing though it.&lt;/p&gt;

&lt;p&gt;Unity is the definition of closed source. I know that they have some open source projects on Bitbucket but that is pretty much it. I have never seen such a closed environment.&lt;/p&gt;

&lt;p&gt;Let me give you a small example. Unity recently released UNET, a multilayer solution for Unity. They ship with scripts like a NetworkManagerHUD which is a prototyping script that gives you a simple GUI and allows you to start a server and connect as a client to a server. Even the implementation of such a simple script is hidden from you which is very strange because it would serve as a great example.&lt;/p&gt;

&lt;p&gt;#Coding
UE4 uses a custom C++ solution, you basically write C++ with a lot of macros and those macros produce some code that gets picked up by the UE4 Header Tool which generates some code.&lt;/p&gt;

&lt;p&gt;UE4 has some gotchas that you need to look out for. For example if you write&lt;/p&gt;

&lt;p&gt;{% highlight c++ %}
UFooComponent* FooComponent;
&amp;hellip;.&lt;/p&gt;

&lt;p&gt;FooComponent = CreateDefaultSubComponent(TEXT(&amp;ldquo;Foo&amp;rdquo;));
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;This pointer will be reset to null at one point. You have to annotate such a pointer with a macro like so.&lt;/p&gt;

&lt;p&gt;{% highlight c++ %}
UPROPERTY()
UFooComponent* FooComponent;
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;Unity comes with a custom C# soltuion which is far less weird than in UE4. I know for a fact that they are doing IL rewriting in UNET and I am pretty sure that they do the same thing with MonoBehaviors because I can not find the Start method.&lt;/p&gt;

&lt;p&gt;In Unity you can just write&lt;/p&gt;

&lt;p&gt;{% highlight c# %}
[SyncVar]
float health;
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;and it will synchronize the value from the server to the clients.&lt;/p&gt;

&lt;p&gt;The same thing would look like this in UE4:&lt;/p&gt;

&lt;p&gt;{% highlight c++ %}
UPROPERTY(Replicated,Reliable)
float Health;
&amp;hellip;
DOREPLIFETIME(AFooSomething, Health);
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;Unfortunately Unity is still stuck on .NET 3.5 which may soon change with IL2CPP, but for the time being you have to stick with .NET 3.5.&lt;/p&gt;

&lt;p&gt;Unity&amp;rsquo;s gameplay framework is very low level. You have complete freedom to do what and how you want. UE4 forces you to use it&amp;rsquo;s gameplay framework which to be fair can fit many games genres but you have not much freedom in your architecture. A lot of stuff in UE4&amp;rsquo;s gameplay framwork uses inheritance which makes it very rigid.&lt;/p&gt;

&lt;p&gt;The good thing is that you are free to create you own stuff from scratch.&lt;/p&gt;

&lt;p&gt;In Unity you have to use a GameObject and then you can attach MonoBehaviours to it. UE4 has something similar called Actors and ActorComponents. The main difference is that you can subclass an Actor. For example you could create&lt;/p&gt;

&lt;p&gt;{% highlight c++ %}
  class AMonster: public AActor
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;And at runtime you can check if some actor is a monster&lt;/p&gt;

&lt;p&gt;{% highlight c++ %}
  AMonster* Monster = Cast&lt;AMonster&gt;(SomeActor);
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;While in Unity you would probably create a monster component like this&lt;/p&gt;

&lt;p&gt;{% highlight c# %}
public class Monster: MonoBehevaior
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;{% highlight c# %}
Monster monster = gameObject.GetComponent&lt;Monster&gt;();
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;Alternatively you could use tags
{% highlight c# %}
gameObject.tag = &amp;ldquo;Monster&amp;rdquo;;
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;But I heavily dislike to use strings this way.&lt;/p&gt;

&lt;p&gt;#Examples
Unity as well as UE4 have an insane amount of learning content. Unfortunately most if it is how to use the engine in general. There are almost no advanced coding examples at all.&lt;/p&gt;

&lt;p&gt;A big plus point for UE4 is that Epic Games &amp;lsquo;openly&amp;rsquo; develops Unreal Tournament which you can use to learn how Epic uses the engine internally.&lt;/p&gt;

&lt;p&gt;#Networking
UE4s networking workflow is super awesome. You can just hit play and the editor will spawn multiple game instances and connect them automatically. Unity doesn&amp;rsquo;t really have a workflow for multiplayer games. The main advantage of C# for me is the compilation speed but in Unity you have to build a standalone game if you want to have multiple game instances and building those binaries takes some time.&lt;/p&gt;

&lt;p&gt;That is the reason why I have wrote my self a super hacky editor script that spawns 4 game instances, puts them on my second monitor, tiles them perfectly, starts the editor as a server and connects the 4 clients to it.&lt;/p&gt;

&lt;p&gt;You can find the script here &lt;a href=&#34;https://github.com/MaikKlein/UNetHelpers&#34;&gt;UNetHelpers&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;In general UE4&amp;rsquo;s networking and Unity&amp;rsquo;s UNet feel very similar, but UNet comes with additional features. Unity has a matchmaking service, nat punchthough, a lobby system and it is easy to create a master server. Unity can also host your game on the AWS cloud for a small fee and it is even free for a small number of users which makes it very attractive to an &amp;lsquo;indie&amp;rsquo; developer like me.&lt;/p&gt;

&lt;p&gt;I can host my prototype game right now and play with my friends. In UE4 this is a bit more tricky, there is no nat punchthough so you have to open some ports. But at least in UE4 you have the option to build a dedicated server, if you are willing to build from source.&lt;/p&gt;

&lt;p&gt;In Unity you have the possibility to send messages on different channel. For example you can send position updates on channel 0 and more important messages on channel 1. You can also only set the message protocol on a specific channel. For example you can set channel 0 to unreliable and channel 1 to reliable.&lt;/p&gt;

&lt;p&gt;UE4 in contrast marks individual properties as reliable/unreliable and creates a channel for every actor that you create. It then uses &lt;a href=&#34;https://docs.unrealengine.com/latest/INT/API/Runtime/Engine/Net/FObjectReplicator/index.html&#34;&gt;FObjectReplicator&lt;/a&gt; to replicate the properties.&lt;/p&gt;

&lt;p&gt;You can then control the priority of an actor with &lt;a href=&#34;https://docs.unrealengine.com/latest/INT/API/Runtime/Engine/GameFramework/AActor/GetNetPriority/2/index.html&#34;&gt;GetNetPriority&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;#Pricing
UE4 comes without any restrictions but wants a cut from your revenue. Unity ships with two different versions, Personal and Professional. The Personal edition has almost no restrictions besides that you have to earn less than $100k a year, a non customizable splash screen and no dark editor ui. The Professional includes a bunch of services. You can read more about it &lt;a href=&#34;https://unity3d.com/get-unity&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;What I find really annoying is that you can not customize the splash screen in Unity Personal. I don&amp;rsquo;t really care if my users can see the Unity splash screen, what I care about is that I have to build a standalone game to develop with Unity UNet. That means I have two watch the splash screen every time I want to test something. Unity should allow you to disable the splash screen in dev builds.&lt;/p&gt;

&lt;p&gt;#Community
This comes up a lot but I don&amp;rsquo;t really think it matters that much. If you are a lone developer like me you will rarely find help in forums even if you isolate your problems very well.&lt;/p&gt;

&lt;p&gt;Unity has probably a much bigger community than UE4. If you would compare the numbers of the two reddit&amp;rsquo;s then Unity&amp;rsquo;s community would be 2.7 times bigger.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.reddit.com/r/unrealengine&#34;&gt;UE4&lt;/a&gt; / &lt;a href=&#34;https://www.reddit.com/r/unity3d&#34;&gt;Unity&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Still a huge community is always a good thing especially if you run into some common bugs.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Evaluating D for games</title>
      <link>http://replace-this-with-your-hugo-site.com/2015/01/11/evaluating-d-for-games</link>
      <pubDate>Sun, 11 Jan 2015 00:00:00 +0000</pubDate>
      
      <guid>http://replace-this-with-your-hugo-site.com/2015/01/11/evaluating-d-for-games</guid>
      <description>&lt;p&gt;{% highlight d %}
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;Disclaimer: I have absolutely no experience with D nor am I a good programmer so please take everything that I say with a grain of salt.&lt;/p&gt;

&lt;p&gt;My current impression of D is that is a mixture of Java and C++. D seems to offer metaprogramming with templates, compiles to native code, but also seems to make heavy use of the GC. If those statements are true I do not know but I will take some time to evaluate D.&lt;/p&gt;

&lt;p&gt;The first code that I wrote:&lt;/p&gt;

&lt;p&gt;{% highlight d %}&lt;/p&gt;

&lt;p&gt;import std.stdio;
import std.typecons;
class Foo(T){
public:
  T i;
}
class Bar{
public:
  int hello = 0;
}&lt;/p&gt;

&lt;p&gt;void main()
{
  Foo!(Bar) f;
  int i = f.i.hello;
}
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;I wrote that code without any knowledge of D. Unfortunately if you run this code, you will get a segfault. I think that was my personal record of creating a segault in a new language.&lt;/p&gt;

&lt;p&gt;The reason why it segfaults is because classes are heap allocated and f is a nullpointer. Of course that is completely my fault, but I am already a little bit annoyed that classes are by default heap allocated.&lt;/p&gt;

&lt;p&gt;It seems that D is differentiating between structs and classes. Structs are value types and live on the stack while classes are heap allocated. That already makes me somewhat uncomfortable because if I would use 3rd party libraries which would use classes it may use the GC in the background. I also assume that the majority of the D community will make use of the GC.&lt;/p&gt;

&lt;p&gt;This makes me wonder how much of the standard library relies on the GC.&lt;/p&gt;

&lt;p&gt;I am trying to find an alternative to std::vector and it seems that would the std.container.Array&lt;/p&gt;

&lt;p&gt;{% highlight d %}
import std.stdio;
import std.container;
void main()
{
  Array!int arr;
  arr.insertBack(10);
  writeln(arr);
}
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;It will output
{% highlight d %}&lt;/p&gt;

&lt;p&gt;Array!int(RefCounted!(Payload, cast(RefCountedAutoInitialize)0)(RefCountedStore(20D9590)))&lt;/p&gt;

&lt;p&gt;{% endhighlight %}
Of course it does not automatically convert arr to a string, I should have expected that but this is actually quite interesting.&lt;/p&gt;

&lt;p&gt;At this point I should probably mention that I am using &lt;a href=&#34;https://github.com/Hackerpilot/DCD&#34;&gt;DCD&lt;/a&gt;, an autocompletion engine for D. I can easily jump to the definition of Array which is quite awesome.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Array type with deterministic control of memory. The memory allocated for the array is reclaimed as soon as possible; there is no reliance on the garbage collector. Array uses malloc and free for managing its own memory.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Okay but what is RefCounted?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Defines a reference-counted object containing a T value as payload. RefCounted keeps track of all references of an object, and when the reference count goes down to zero, frees the underlying store. RefCounted uses malloc and free for operation.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;My first thought was why does it need to be RefCounted in the first place? There also does not seem a way to customize the container in any way. It is not that bad, I expected to write my own custom containers anyway. At least now I know that it is possible to do manual memory management.&lt;/p&gt;

&lt;p&gt;RefCounted seems to be the equivalent of std::shared_ptr. I wonder if there is something similar to std::unqiue_ptr.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;struct Unique(T);
Encapsulates unique ownership of a resource. Resource of type T is deleted at the end of the scope, unless it is transferred. The transfer can be explicit, by calling release, or implicit, when returning Unique from a function. The resource can be a polymorphic class object, in which case Unique behaves polymorphically too.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;{% highlight d %}
  Unique!Foo f = new Foo;
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;D seems to be better than I thought. Out of curiosity I read though some parts of the standard library and I found something interesting.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;template scoped(T) if (is(T == class))
Allocates a class object right inside the current scope, therefore avoiding the overhead of new. This facility is unsafe; it is the responsibility of the user to not escape a reference to the object outside the scope&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;{% highlight d %}
import std.stdio;
import std.container;
import std.typecons;
class Foo{
  int i;
  this(){
    i = 0;
  }
}
void main()
{
  auto f = scoped!Foo();
  f.i = 10;
  writeln(f.i);
}
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;So it seems that it is possible to completely avoid the allocation of a class.&lt;/p&gt;

&lt;p&gt;Let us see how we would achieve static dispatch in D.
{% highlight d %}
import std.stdio;&lt;/p&gt;

&lt;p&gt;bool isRenderer&amp;reg;(){
  return is(R : OpenGL) ||
         is(R : DirectDraw);
}
struct OpenGL{
  void print() const{
    writeln(&amp;ldquo;OpenGL&amp;rdquo;);
  }
}
struct DirectDraw{
  void print() const{
    writeln(&amp;ldquo;DirectDraw&amp;rdquo;);
  }
}&lt;/p&gt;

&lt;p&gt;void printRenderer&amp;reg;(const ref R r)
  if(isRenderer!R)
{
  r.print();
}&lt;/p&gt;

&lt;p&gt;void main()
{
  OpenGL gl;
  DirectDraw dd;&lt;/p&gt;

&lt;p&gt;printRenderer(gl);
  printRenderer(dd);
}
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;This almost looks exactly like C++. Note that the &amp;lsquo;if&amp;rsquo; between the function definition and the function body is called a &amp;lsquo;constrain&amp;rsquo;.&lt;/p&gt;

&lt;p&gt;{% highlight d %}
returnType functionName(param)
 if(condition)
{
  &amp;hellip;
}
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;I think it would basically translate to C++ like this
{% highlight d %}
template&lt;typename R&gt;
void printRenderer(const R &amp;amp;r){
  static_assert(!isRenderer::value,&amp;ldquo;Is not a valid renderer.&amp;rdquo;);
  r.print();
}
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;The problem with this approach is that once we want to add a new renderer we would have to change existing code.
{% highlight d %}
bool isRenderer&amp;reg;(){
  return is(R : OpenGL)     ||
         is(R : DirectDraw) ||
         is(R : Metal);
}
{% endhighlight %}
Which would not be that bad if we only have to change code at one place, but maybe there is a better way? Let us see how CRTP looks in D.
{% highlight d %}
import std.stdio;
import std.typecons;&lt;/p&gt;

&lt;p&gt;class Renderer(T){
  void print(){
    (cast(T)(this))._print();
  }
}
class OpenGL : Renderer!(OpenGL){
  void _print() const{
    writeln(&amp;ldquo;OpenGL&amp;rdquo;);
  }
}
class DirectDraw : Renderer!(DirectDraw){
  void _print() const{
    writeln(&amp;ldquo;DirectDraw&amp;rdquo;);
  }
}
void printRenderer(T)(Renderer!T r){
  r.print();
}&lt;/p&gt;

&lt;p&gt;void main()
{
  auto gl = scoped!OpenGL();
  auto dd = scoped!DirectDraw();
  printRenderer(gl);
  printRenderer(dd);
}
{% endhighlight %}
Please note that we have to use classes because only classes support inheritance which is required to implement CRTP. Also note that we have to use the &amp;lsquo;scoped&amp;rsquo; template in order to avoid the heap allocation.&lt;/p&gt;

&lt;p&gt;CRTP has the advantage that I can extend existing code without changing a single line. Still, personally I think it is quite inconvenient to use. It forces you to cast your base class to a derived class like this
{% highlight d %}
    (cast(T)(this))._print();
{% endhighlight %}
And you would have to implement your methods with a different name. I used the convention &amp;lsquo;_methodName&amp;rsquo;. Personally I would choose the first version with static ducktyping + constrains because I think it looks more natural.&lt;/p&gt;

&lt;p&gt;D has a features that I have never seen in a another language before. D calls it alias this.
{% highlight d %}
import std.stdio;&lt;/p&gt;

&lt;p&gt;struct Printer{
  string sentence;
  void print(){
    writeln(sentence);
  }
  this(string s){
    sentence = s;
  }
}
struct HelloWorld1{
  Printer printer = Printer(&amp;ldquo;Hello World 1&amp;rdquo;);
}
struct HelloWorld2{
  Printer printer = Printer(&amp;ldquo;Hello World 2&amp;rdquo;);
  alias printer this;
}
struct HelloWorld3{
  Printer printer = Printer(&amp;ldquo;Hello World 3&amp;rdquo;);
  alias printer this;
  void print(){
    writeln(&amp;ldquo;Error&amp;rdquo;);
  }
}
void main()
{
  HelloWorld1 hello1;
  hello1.printer.print();//prints Hello World 1&lt;/p&gt;

&lt;p&gt;HelloWorld2 hello2;
  hello2.print();//prints Hello World 2&lt;/p&gt;

&lt;p&gt;HelloWorld3 hello3;
  hello3.print();//prints Error&lt;/p&gt;

&lt;p&gt;}
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;Alias this could be a really nice feature, usually you would have to write&lt;/p&gt;

&lt;p&gt;{% highlight d %}
  hello1.printer.print();
{% endhighlight %}
if you are using composition. But with alias this you can just write
{% highlight d %}
  hello2.print();
{% endhighlight %}
The problem is that members/functions are getting shadowed if they already exist in that struct (see HelloWorld3). I am not sure how useful it will be.&lt;/p&gt;

&lt;p&gt;I have found a new keyword that could be very useful &amp;lsquo;@nogc&amp;rsquo;. It will guarantee at compile time that no function will use the GC.
{% highlight d %}
@nogc{
  //your code&lt;br /&gt;
}
{% endhighlight %}
Unfortunately this showed me how much of the standard library relies on the GC. Remember RefCounted, Unique and scoped? All of these helper functions rely on the GC. So I do not think that it is feasible anymore to completely disable the GC. Actually this is very strange, the RefCounted documentation clearly states&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;RefCounted uses malloc and free for operation.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I assume that RefCounted must use some nongc function under the hood which prevents me from using it without the GC.&lt;/p&gt;

&lt;p&gt;Before I go on I have to do some research of how the GC in D is actually implemented. Maybe the implementation is not that bad and if I only rely on a very small amount of allocations the GC might not even be noticeable.&lt;/p&gt;

&lt;p&gt;It is actually very hard to find some details of how the GC works, but I found this quote from the official D website.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The GC works by:&lt;/p&gt;

&lt;p&gt;Stopping all other threads than the thread currently trying to allocate GC memory.
‘Hijacking’ the current thread for GC work.
Scanning all ‘root’ memory ranges for pointers into GC allocated memory.
Recursively scanning all allocated memory pointed to by roots looking for more pointers into GC allocated memory.
Freeing all GC allocated memory that has no active pointers to it and do not need destructors to run.
Queueing all unreachable memory that needs destructors to run.
Resuming all other threads.
Running destructors for all queued memory.
Freeing any remaining unreachable memory.
Returning the current thread to whatever work it was doing.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This line makes me very sad&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Stopping all other threads than the thread currently trying to allocate GC memory&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This may be a deal breaker for me. But I give it the benefit of the doubt. I am going to read though Unqiue and Refcounted and see what actually uses the GC.
I read though &amp;lsquo;Unique&amp;rsquo; and it is actually below 30 loc. It seems that the only &amp;lsquo;function&amp;rsquo; that requires the GC is the destructor call &amp;lsquo;~this&amp;rsquo;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Error: @nogc function &amp;rsquo;D main&amp;rsquo; cannot call non-@nogc function &amp;lsquo;std.typecons.Unique!(Test).Unique.~this&amp;rsquo;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;But I actually do not know how it even allocates, I think it still relies on the GC for that.&lt;/p&gt;

&lt;p&gt;{% highlight d %}
struct Unique(T)
{
static if (is(T:Object))
    alias RefT = T;
else
    alias RefT = T*;&lt;/p&gt;

&lt;p&gt;public:
/+ Doesn&amp;rsquo;t work yet
    /**
    The safe constructor. It creates the resource and
    guarantees unique ownership of it (unless the constructor
    of $(D T) publishes aliases of $(D this)),
    */
    this(A&amp;hellip;)(A args)
    {
        _p = new T(args);
    }
+/&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
Constructor that takes an rvalue.
It will ensure uniqueness, as long as the rvalue
isn&#39;t just a view on an lvalue (e.g., a cast)
Typical usage:
----
Unique!(Foo) f = new Foo;
----
*/
this(RefT p)
{
    debug(Unique) writeln(&amp;quot;Unique constructor with rvalue&amp;quot;);
    _p = p;
}
/**
Constructor that takes an lvalue. It nulls its source.
The nulling will ensure uniqueness as long as there
are no previous aliases to the source.
*/
this(ref RefT p)
{
    _p = p;
    debug(Unique) writeln(&amp;quot;Unique constructor nulling source&amp;quot;);
    p = null;
    assert(p is null);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;/+ Doesn&amp;rsquo;t work yet
    /**
    Constructor that takes a Unique of a type that is convertible to our type:
    Disallow construction from lvalue (force the use of release on the source Unique)
    If the source is an rvalue, null its content, so the destrutctor doesn&amp;rsquo;t delete it&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Typically used by the compiler to return $(D Unique) of derived type as $(D Unique)
of base type.

Example:
----
Unique!(Base) create()
{
    Unique!(Derived) d = new Derived;
    return d; // Implicit Derived-&amp;gt;Base conversion
}
----
*/
this(U)(ref Unique!(U) u) = null;
this(U)(Unique!(U) u)
{
    _p = u._p;
    u._p = null;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;+/&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~this()
{
    debug(Unique) writeln(&amp;quot;Unique destructor of &amp;quot;, (_p is null)? null: _p);
    delete _p;
    _p = null;
}
bool isEmpty() const
{
    return _p is null;
}
/** Returns a unique rvalue. Nullifies the current contents */
Unique release()
{
    debug(Unique) writeln(&amp;quot;Release&amp;quot;);
    auto u = Unique(_p);
    assert(_p is null);
    debug(Unique) writeln(&amp;quot;return from Release&amp;quot;);
    return u;
}
/** Forwards member access to contents */
RefT opDot() { return _p; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;/+ doesn&amp;rsquo;t work yet!
    /**
    Postblit operator is undefined to prevent the cloning of $(D Unique) objects
    */
    this(this) = null;
 +/&lt;/p&gt;

&lt;p&gt;private:
    RefT _p;
}
&amp;lsquo;
{% endhighlight %}
As you can see it steals the pointer and nulls the original one. This may cause it to be unique but it still relies on the GC for the allocation. At least that is what I think. Also there are scary amount of &amp;lsquo;does not work yet&amp;rsquo; comments.&lt;/p&gt;

&lt;p&gt;D seemed like a nice language for me and I did not cover all of D&amp;rsquo;s features but it still seems to rely too much on the GC. I probably could reimplement many things in the standard library to not use the GC but I am not sure if want to do this right now. I probably will stay with C++.&lt;/p&gt;

&lt;p&gt;I know many of you reading this article will think I am mad for dismissing D because of the GC and I accept your judgement. It may be completely unreasonable to avoid the GC at all costs but I don&amp;rsquo;t want to work 2 years on my game just to realize in the end that the GC might become a problem that is really hard to fix.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Lifetimes explained</title>
      <link>http://replace-this-with-your-hugo-site.com/2013/08/27/lifetimes-explained</link>
      <pubDate>Tue, 27 Aug 2013 00:00:00 +0000</pubDate>
      
      <guid>http://replace-this-with-your-hugo-site.com/2013/08/27/lifetimes-explained</guid>
      <description>&lt;p&gt;{% highlight rust %}&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;So you want to learn about lifetimes in Rust? Okay let&amp;rsquo;s give it a try then. We are starting by creating a new struct let&amp;rsquo;s call it&lt;/p&gt;

&lt;p&gt;{% highlight rust %}
struct Foo{
    name: ~str
}
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;Okay that was easy right? Hm.. but it isn&amp;rsquo;t really useful right now. Let&amp;rsquo;s change that, but before we do that we need to know how borrowing works.&lt;/p&gt;

&lt;p&gt;{% highlight rust %}
struct Foo{
    name: ~str
}&lt;/p&gt;

&lt;p&gt;fn main() {
    let foo = Foo{name: ~&amp;ldquo;Bar&amp;rdquo;};
    let ref_foo   = &amp;foo;
    let ref_foo_2 = &amp;foo;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;printfln!(foo); // prints {name: ~&amp;quot;Bar&amp;quot;}
printfln!(ref_foo); // prints &amp;amp;{name: ~&amp;quot;Bar&amp;quot;}
printfln!(ref_foo_2); // prints &amp;amp;{name: ~&amp;quot;Bar&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;So what is going on here? Well we created our new object &lt;code&gt;foo&lt;/code&gt;, then we created two &amp;lsquo;borrows&amp;rsquo; to &lt;code&gt;foo&lt;/code&gt;. We called them &lt;code&gt;ref_foo&lt;/code&gt; and &lt;code&gt;ref_foo_2&lt;/code&gt;. You can see them as a pointer. &lt;code&gt;ref_foo&lt;/code&gt; and &lt;code&gt;ref_foo_2&lt;/code&gt; are currently pointing to &lt;code&gt;foo&lt;/code&gt;. So what happens if we change &lt;code&gt;foo&lt;/code&gt;?&lt;/p&gt;

&lt;p&gt;{% highlight rust %}
struct Foo{
    name: ~str
}&lt;/p&gt;

&lt;p&gt;fn main() {
    let mut foo = Foo{name: ~&amp;ldquo;Bar&amp;rdquo;};
    let ref_foo   = &amp;foo;
    let ref_foo_2 = &amp;foo;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;printfln!(foo); // prints {name: ~&amp;quot;Bar&amp;quot;}
printfln!(ref_foo); // prints &amp;amp;{name: ~&amp;quot;Bar&amp;quot;}
printfln!(ref_foo_2); // prints &amp;amp;{name: ~&amp;quot;Bar&amp;quot;}

foo.name = ~&amp;quot;SomeOtherName&amp;quot;;
/*
14:12 error: cannot assign to `foo.name` because it is borrowed
foo.name = ~&amp;quot;SomeOtherName&amp;quot;;
^~~~~~~~
*/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;Oh.. that is unfortunate. We just got an error. What this error is telling us is that we are currently borrowing the variable &lt;code&gt;foo&lt;/code&gt;. In other words &lt;code&gt;ref_foo&lt;/code&gt; and &lt;code&gt;ref_foo_2&lt;/code&gt; are currently pointing to &lt;code&gt;foo&lt;/code&gt; and Rust doesn&amp;rsquo;t let us modify &lt;code&gt;foo&lt;/code&gt; while &lt;code&gt;foo&lt;/code&gt; has pointers pointing on it. This is part of Rust&amp;rsquo;s memory safety guarantee.&lt;/p&gt;

&lt;p&gt;Okay what have we learned so far?&lt;/p&gt;

&lt;p&gt;1.) &amp;amp; acts like a pointer.
2.) We can not change borrowed variables.&lt;/p&gt;

&lt;p&gt;Okay what if we would write something like this?&lt;/p&gt;

&lt;p&gt;{% highlight rust %}
struct Foo{
    name: ~str
}&lt;/p&gt;

&lt;p&gt;fn weird_function()-&amp;gt; &amp;amp;Foo {
    let foo = Foo{name: ~&amp;ldquo;Barrr&amp;rdquo;};
    &amp;amp;foo
}
/*
7:8 error: borrowed value does not live long enough
 &amp;amp;foo
*/
fn main() {&lt;/p&gt;

&lt;p&gt;}
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;We are trying to return a borrowed Foo, but Rust doesn&amp;rsquo;t let us do that! It tells us that the value doesn&amp;rsquo;t live long enough. Okay so why is this happening? Let&amp;rsquo;s have a closer look.&lt;/p&gt;

&lt;p&gt;{% highlight rust %}
fn weird_function()-&amp;gt; &amp;amp;Foo {
    let foo = Foo{name: ~&amp;ldquo;Barrr&amp;rdquo;};
    &amp;amp;foo
}
/*
7:8 error: borrowed value does not live long enough
 &amp;amp;foo
*/
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;The problem with this function is that we are creating a new variable called &lt;code&gt;foo&lt;/code&gt;. Then we are trying to return the borrowed value. Okay but now it gets a little bit weird. The function block ends and the local variable &lt;code&gt;foo&lt;/code&gt; is freed. So we would return a pointer that points to no memory and that would be bad.&lt;/p&gt;

&lt;p&gt;Fortunately Rust is preventing this by telling us that the variable &lt;code&gt;foo&lt;/code&gt; is not living long enough.&lt;/p&gt;

&lt;p&gt;Okay let&amp;rsquo;s say our &lt;code&gt;struct Foo&lt;/code&gt; isn&amp;rsquo;t good enough anymore! We want another &lt;code&gt;struct Bar&lt;/code&gt; and Foo should borrow it.&lt;/p&gt;

&lt;p&gt;{% highlight rust %}
struct Foo{
    name: ~str,
    ref_bar: &amp;amp;Bar
}
struct Bar {
    name: ~str
}&lt;/p&gt;

&lt;p&gt;fn main() {&lt;/p&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;/*
3:17 error: Illegal anonymous lifetime: anonymous lifetimes are not permitted here
ref_bar: &amp;amp;Bar
*/
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;Oh come on Rust, again? What is this? &lt;code&gt;Illegal anonymous lifetime&lt;/code&gt;?
Well if you think about it, this error message makes sense. Remember how Rust only let&amp;rsquo;s us have borrows to valid memory? What if our
&lt;code&gt;ref_bar&lt;/code&gt; would get invalid in the life time of Foo?&lt;/p&gt;

&lt;p&gt;We need a way to tell Rust &amp;ldquo;Hey Rust, please let ref_bar be valid as long as Foo is alive&amp;rdquo;. So how would we do that?&lt;/p&gt;

&lt;p&gt;With lifetimes!&lt;/p&gt;

&lt;p&gt;{% highlight rust %}
struct Foo&amp;lt;&amp;lsquo;self&amp;gt;{
    name: ~str,
    ref_bar: &amp;amp;&amp;lsquo;self Bar
}
struct Bar {
    name: ~str
}&lt;/p&gt;

&lt;p&gt;fn main() {&lt;/p&gt;

&lt;p&gt;}
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;What is this weird symbol &lt;code&gt;&#39;self&lt;/code&gt;? This looks scary go away!
Okay basically &lt;code&gt;&#39;self&lt;/code&gt; denotes the life time of Foo. We are declaring lifetimes in &lt;code&gt;&amp;lt;..&amp;gt;&lt;/code&gt;. Lifetimes are declared with &lt;code&gt;&#39;+ any free keyword&lt;/code&gt;. Examples would be &lt;code&gt;&#39;r &#39;a &#39;t &#39;fortytwo &#39;mountain&lt;/code&gt; and so on. But &amp;lsquo;self is a somewhat special case. &lt;code&gt;&#39;self&lt;/code&gt; is the only lifetime allowed in a Struct / Enum.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Note this is going to change soon. &lt;code&gt;&#39;self&lt;/code&gt; is considered to be a bug. You will be able to name your name your lifetimes in structs as you like.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;So we know how to declare lifetimes but how do we use them?&lt;/p&gt;

&lt;p&gt;We are binding them to our borrows. This is done like &lt;code&gt;ref_bar: &amp;amp;&#39;self Bar&lt;/code&gt;. Now we can read this as &amp;ldquo;Our borrow has the lifetime of &lt;code&gt;&#39;self&lt;/code&gt;&amp;rdquo; Remember that we have declared &amp;lsquo;self in Foo. So &amp;lsquo;self means the life time of Foo.&lt;/p&gt;

&lt;p&gt;Okay now let&amp;rsquo;s look at more examples.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s say we want our struct Foo to return a borrow to it&amp;rsquo;s name. Piece of cake right? Okay let&amp;rsquo;s do it.&lt;/p&gt;

&lt;p&gt;{% highlight rust %}
struct Foo{
    name: ~str,
}
impl Foo {
    fn get_ref_name(&amp;amp;self) -&amp;gt; &amp;amp;~str{
        &amp;amp;self.name
    }
}&lt;/p&gt;

&lt;p&gt;fn main() {
}
/*
error: cannot infer an appropriate lifetime due to conflicting requirements
&amp;amp;self.name
*/
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;Pfffff again a life time error&amp;hellip;
Now what are we trying to do here? We are returning a borrow to self.name right? this seems reasonable but why is Rust complaining about it? Okay let&amp;rsquo;s think about what could happen.&lt;/p&gt;

&lt;p&gt;{% highlight rust %}
let foo = Foo{name: ~&amp;ldquo;foo&amp;rdquo;};
let ref_name = foo.get_ref_name();
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;Okay what would happen to our variable ref_name if &lt;code&gt;foo&lt;/code&gt; is freed? Right it would point to invalid memory! So again .. we need a way to tell rust that our variable &lt;code&gt;ref_name&lt;/code&gt; is valid as long as &lt;code&gt;foo&lt;/code&gt; is valid.&lt;/p&gt;

&lt;p&gt;{% highlight rust %}
struct Foo{
    name: ~str,
}
impl Foo {
    fn get_ref_name&amp;lt;&amp;lsquo;r&amp;gt; (&amp;amp;&amp;lsquo;r self) -&amp;gt; &amp;amp;&amp;lsquo;r ~str{
        &amp;amp;self.name
    }
}&lt;/p&gt;

&lt;p&gt;fn main() {
    let foo = Foo{name: ~&amp;ldquo;foo&amp;rdquo;};
    let ref_name = foo.get_ref_name();
    printfln!(ref_name); // prints &amp;amp;~&amp;ldquo;foo&amp;rdquo;
}
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;Okay let&amp;rsquo;s analyze it again. First we are declaring our life time in &lt;code&gt;&amp;lt;..&amp;gt;&lt;/code&gt; right? We are doing this like&amp;hellip;
{% highlight rust %}
fn get_ref_name&amp;lt;&amp;lsquo;r&amp;gt;
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;So now Rust knows that there is a lifetime. But how long does it live? Hm.. good question. I don&amp;rsquo;t know and Rust also doesn&amp;rsquo;t know. We need to bind it first.&lt;/p&gt;

&lt;p&gt;{% highlight rust %}
&amp;hellip; &amp;amp;&amp;lsquo;r self &amp;hellip;
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;By writing this Rust now knows that &lt;code&gt;&#39;r&lt;/code&gt; has the life time of Foo. Okay hm&amp;hellip; but something is missing right? Now we need to tell Rust that our returning borrow also has the lifetime of &lt;code&gt;&#39;r&lt;/code&gt;
{% highlight rust %}
fn get_ref_name&amp;lt;&amp;lsquo;r&amp;gt; (&amp;amp;&amp;lsquo;r self) -&amp;gt; &amp;amp;&amp;lsquo;r ~str{
        &amp;amp;self.name
}
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;Okay that&amp;rsquo;s it. We just told the returning borrow to have the lifetime of &lt;code&gt;&#39;r&lt;/code&gt;. Let&amp;rsquo;s have a look at our previous code again.&lt;/p&gt;

&lt;p&gt;{% highlight rust %}
let foo = Foo{name: ~&amp;ldquo;foo&amp;rdquo;};
let ref_name = foo.get_ref_name();
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;Rust now knows that ref_name is valid as long as foo is valid.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Vistor Pattern in Rust with dynamic and static dispatch</title>
      <link>http://replace-this-with-your-hugo-site.com/2013/06/22/vistor-pattern-in-rust-with-dynamic-and-static-dispatch</link>
      <pubDate>Sat, 22 Jun 2013 00:00:00 +0000</pubDate>
      
      <guid>http://replace-this-with-your-hugo-site.com/2013/06/22/vistor-pattern-in-rust-with-dynamic-and-static-dispatch</guid>
      <description>&lt;p&gt;{% highlight rust %}&lt;/p&gt;

&lt;p&gt;trait Visitor&lt;T&gt;{
    fn visit(&amp;amp;self, t: T);
}
struct PrintVisitor;
struct PrintReverseVisitor;&lt;/p&gt;

&lt;p&gt;impl Visitor&amp;lt;~str&amp;gt; for PrintVisitor {
    fn visit(&amp;amp;self, s: ~str){
        println(s);
    }
}&lt;/p&gt;

&lt;p&gt;impl Visitor&amp;lt;~str&amp;gt; for PrintReverseVisitor {
    fn visit(&amp;amp;self, s: ~str){
        let x: ~[char] = s.rev_iter().collect();
        println( std::str::from_chars(x));
    }
}&lt;/p&gt;

&lt;p&gt;struct SomeObjectWithStaticDispatch;
impl&lt;V: Visitor&lt;~str&gt;&amp;gt; SomeObjectWithStaticDispatch {
    fn do_sth&amp;lt;&amp;lsquo;r&amp;gt;(&amp;amp;self, v: &amp;amp;&amp;lsquo;r V , s: ~str){
        v.visit(s);
    }
}
struct SomeObjectWithDynamicDispatch;&lt;/p&gt;

&lt;p&gt;impl SomeObjectWithDynamicDispatch {
    fn do_sth&amp;lt;&amp;lsquo;r&amp;gt;(&amp;amp;self, v: &amp;amp;&amp;lsquo;r Visitor&amp;lt;~str&amp;gt;, s: ~str){
        v.visit(s);
    }
}
fn main(){&lt;/p&gt;

&lt;p&gt;let v = &amp;PrintVisitor;
let v1 = &amp;PrintReverseVisitor;&lt;/p&gt;

&lt;p&gt;let o_static = SomeObjectWithStaticDispatch;
let o_dynamic = SomeObjectWithDynamicDispatch;&lt;/p&gt;

&lt;p&gt;o_static.do_sth(v, ~&amp;ldquo;Hello&amp;rdquo;);
o_static.do_sth(v1, ~&amp;ldquo;Hello&amp;rdquo;);&lt;/p&gt;

&lt;p&gt;o_dynamic.do_sth(v as &amp;amp;Visitor&amp;lt;~str&amp;gt;, ~&amp;ldquo;Hello&amp;rdquo;);
o_dynamic.do_sth(v1 as &amp;amp;Visitor&amp;lt;~str&amp;gt;, ~&amp;ldquo;Hello&amp;rdquo;);
}&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Nitro: A quick and simple profiler for Go</title>
      <link>http://replace-this-with-your-hugo-site.com/post/nitro/</link>
      <pubDate>Fri, 21 Jun 2013 11:27:27 -0400</pubDate>
      
      <guid>http://replace-this-with-your-hugo-site.com/post/nitro/</guid>
      <description>

&lt;h1 id=&#34;nitro:b128b7694e4de962e0088bcb1bcb254f&#34;&gt;Nitro&lt;/h1&gt;

&lt;p&gt;Quick and easy performance analyzer library for &lt;a href=&#34;http://golang.org/&#34;&gt;Go&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;overview:b128b7694e4de962e0088bcb1bcb254f&#34;&gt;Overview&lt;/h2&gt;

&lt;p&gt;Nitro is a quick and easy performance analyzer library for Go.
It is useful for comparing A/B against different drafts of functions
or different functions.&lt;/p&gt;

&lt;h2 id=&#34;implementing-nitro:b128b7694e4de962e0088bcb1bcb254f&#34;&gt;Implementing Nitro&lt;/h2&gt;

&lt;p&gt;Using Nitro is simple. First, use &lt;code&gt;go get&lt;/code&gt; to install the latest version
of the library.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go get github.com/spf13/nitro
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, include nitro in your application.
&lt;div class=&#34;highlight&#34; style=&#34;background: #2f1e2e&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #5bc4bf&#34;&gt;section&lt;/span&gt; &lt;span style=&#34;color: #06b6ef&#34;&gt;id&lt;/span&gt;&lt;span style=&#34;color: #5bc4bf&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #48b685&#34;&gt;&amp;quot;main&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;&amp;gt;&lt;/span&gt;
  &lt;span style=&#34;color: #e7e9db&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #5bc4bf&#34;&gt;div&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;&amp;gt;&lt;/span&gt;
    &lt;span style=&#34;color: #e7e9db&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #5bc4bf&#34;&gt;h1&lt;/span&gt; &lt;span style=&#34;color: #06b6ef&#34;&gt;id&lt;/span&gt;&lt;span style=&#34;color: #5bc4bf&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #48b685&#34;&gt;&amp;quot;title&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;&amp;gt;&lt;/span&gt;{{ .Title }}&lt;span style=&#34;color: #e7e9db&#34;&gt;&amp;lt;/&lt;/span&gt;&lt;span style=&#34;color: #5bc4bf&#34;&gt;h1&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;&amp;gt;&lt;/span&gt;
    {{ range .Data.Pages }}
      {{ .Render &amp;quot;summary&amp;quot;}}
    {{ end }}
  &lt;span style=&#34;color: #e7e9db&#34;&gt;&amp;lt;/&lt;/span&gt;&lt;span style=&#34;color: #5bc4bf&#34;&gt;div&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #e7e9db&#34;&gt;&amp;lt;/&lt;/span&gt;&lt;span style=&#34;color: #5bc4bf&#34;&gt;section&lt;/span&gt;&lt;span style=&#34;color: #e7e9db&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>How to hack rustc</title>
      <link>http://replace-this-with-your-hugo-site.com/2013/06/08/how-to-hack-rustc</link>
      <pubDate>Sat, 08 Jun 2013 00:00:00 +0000</pubDate>
      
      <guid>http://replace-this-with-your-hugo-site.com/2013/06/08/how-to-hack-rustc</guid>
      <description>&lt;p&gt;We are going to hack rustc. Our goal is to extend the functionality of rustc so that we can write &amp;ldquo;rustc &amp;ndash;printString&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Note this tutorial assumes that you are using linux&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Open the following file:
{% highlight rust %}
/rust/src/librustc/driver/driver.rs
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;Now search for the function&lt;/p&gt;

&lt;p&gt;{% highlight rust %}
pub fn optgroups() -&amp;gt; ~[getopts::groups::OptGroup] {
{% endhighlight %}
This is the main function where we will pattern match the input. Add the following line
{% highlight rust %}
  optflag(&amp;ldquo;&amp;rdquo;,  &amp;ldquo;printString&amp;rdquo;, &amp;ldquo;Prints a string&amp;rdquo;),
{% endhighlight %}
Your function should look like this
{% highlight rust %}
pub fn optgroups() -&amp;gt; ~[getopts::groups::OptGroup] {
 ~[
  optflag(&amp;ldquo;&amp;rdquo;,  &amp;ldquo;printString&amp;rdquo;, &amp;ldquo;Prints a string&amp;rdquo;),
  optflag(&amp;ldquo;&amp;rdquo;,  &amp;ldquo;bin&amp;rdquo;, &amp;ldquo;Compile an executable crate (default)&amp;rdquo;),
  optflag(&amp;ldquo;c&amp;rdquo;, &amp;ldquo;&amp;rdquo;,    &amp;ldquo;Compile and assemble, but do not link&amp;rdquo;),
  &amp;hellip;.
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;Now you have to open
{% highlight rust %}
/rust/src/librustc/rustc.rc
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;and search for the following function&lt;/p&gt;

&lt;p&gt;{% highlight rust %}
pub fn run_compiler(args: &amp;amp;~[~str], demitter: diagnostic::Emitter) {
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;Now you can pattern match the argument like this
{% highlight rust %}
if opt_present(matches, &amp;ldquo;printString&amp;rdquo;) {
        io::println(&amp;ldquo;Rustc says: Hello&amp;rdquo;);&lt;br /&gt;
        return;
}
{% endhighlight %}
Your function should look like this
{% highlight rust %}
pub fn run_compiler(args: &amp;amp;~[~str], demitter: diagnostic::Emitter) {
    // Don&amp;rsquo;t display log spew by default. Can override with RUST_LOG.
    ::core::logging::console_off();&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let mut args = /*bad*/copy *args;
let binary = @args.shift();

if args.is_empty() { usage(*binary); return; }

let matches =
    &amp;amp;match getopts::groups::getopts(args, optgroups()) {
      Ok(m) =&amp;gt; m,
      Err(f) =&amp;gt; {
        early_error(demitter, getopts::fail_str(f));
      }
    };

if opt_present(matches, &amp;quot;h&amp;quot;) || opt_present(matches, &amp;quot;help&amp;quot;) {
    usage(*binary);
    return;
}
if opt_present(matches, &amp;quot;printString&amp;quot;) {
    io::println(&amp;quot;Rustc says: Hello&amp;quot;);  
    return;
}
....
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;Now save and go to your main rust folder and type
{% highlight rust %}
make rustc-stage1
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;Goto
{% highlight rust %}
/rust/x86_64-unknown-linux-gnu/stage1/bin/rustc
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;And now you can call your flag like this&lt;/p&gt;

&lt;p&gt;{% highlight rust %}
./rustc &amp;ndash;printString
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;And it will hopefully output the following:&lt;/p&gt;

&lt;p&gt;{% highlight rust %}
Rustc says: Hello
{% endhighlight %}&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Tasks in Rust</title>
      <link>http://replace-this-with-your-hugo-site.com/2013/06/02/tasks-in-rust</link>
      <pubDate>Sun, 02 Jun 2013 00:00:00 +0000</pubDate>
      
      <guid>http://replace-this-with-your-hugo-site.com/2013/06/02/tasks-in-rust</guid>
      <description>&lt;p&gt;{% highlight rust %}&lt;/p&gt;

&lt;p&gt;use std::comm::{stream, Chan,Port};&lt;/p&gt;

&lt;p&gt;fn main() {&lt;/p&gt;

&lt;p&gt;// creates 100 tasks
let chans = do vec::from_fn(100) |tasknumber| {
    let (port, chan) = stream::&lt;int&gt;();
    do spawn {
        let value = port.recv();
        print(fmt!(&amp;ldquo;I am task # %? -&amp;gt; %? \n&amp;rdquo;,tasknumber,value));
    }
    chan
};
// send 42 to all tasks
for chans.each |chan| {
  chan.send(42);&lt;/p&gt;

&lt;p&gt;}
/* Prints:
&lt;em&gt;printing order is arbitrary&lt;/em&gt;
I am task # 23 -&amp;gt; 42
I am task # 31 -&amp;gt; 42
I am task # 47 -&amp;gt; 42
I am task # 71 -&amp;gt; 42
I am task # 75 -&amp;gt; 42
I am task # 83 -&amp;gt; 42
I am task # 99 -&amp;gt; 42
I am task # 35 -&amp;gt; 42
&amp;hellip;
*/&lt;/p&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Macro&#39;s in Rust</title>
      <link>http://replace-this-with-your-hugo-site.com/2013/05/29/macros-in-rust</link>
      <pubDate>Wed, 29 May 2013 00:00:00 +0000</pubDate>
      
      <guid>http://replace-this-with-your-hugo-site.com/2013/05/29/macros-in-rust</guid>
      <description>&lt;p&gt;{% highlight rust %}&lt;/p&gt;

&lt;p&gt;macro_rules! add(
    ($sp:ident) =&amp;gt; (
        $sp + $sp
    );
)
fn main() {&lt;/p&gt;

&lt;p&gt;let s = ~&amp;ldquo;Hello World &amp;ldquo;;
println(fmt!(&amp;ldquo;%?&amp;rdquo;,add!(s))); // prints ~&amp;ldquo;Hello World Hello World &amp;ldquo;&lt;/p&gt;

&lt;p&gt;let i = 10;
println(fmt!(&amp;ldquo;%?&amp;rdquo;,add!(i))); // prints 20&lt;/p&gt;

&lt;p&gt;let v =  ~[1,2,3,4,5];
println(fmt!(&amp;ldquo;%?&amp;rdquo;,add!(v))); // prints ~[1, 2, 3, 4, 5, 1, 2, 3, 4, 5]&lt;/p&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;How cool is that?&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>